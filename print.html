<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Alternative Haskell Infrastructure for Nixpkgs</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="motivation.html"><strong aria-hidden="true">2.</strong> Motivation</a></li><li class="chapter-item expanded "><a href="architecture.html"><strong aria-hidden="true">3.</strong> Architecture</a></li><li class="chapter-item expanded "><a href="tutorials/index.html"><strong aria-hidden="true">4.</strong> Tutorials</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tutorials/getting-started.html"><strong aria-hidden="true">4.1.</strong> Getting started</a></li><li class="chapter-item expanded "><a href="tutorials/getting-started-flakes.html"><strong aria-hidden="true">4.2.</strong> Getting started with Flakes</a></li><li class="chapter-item expanded "><a href="tutorials/getting-started-hix.html"><strong aria-hidden="true">4.3.</strong> Getting started with Hix</a></li><li class="chapter-item expanded "><a href="tutorials/development.html"><strong aria-hidden="true">4.4.</strong> Creating a development environment</a></li><li class="chapter-item expanded "><a href="tutorials/clean-git.html"><strong aria-hidden="true">4.5.</strong> Sourcing files only part of git repository using cleanGit</a></li><li class="chapter-item expanded "><a href="tutorials/source-repository-hashes.html"><strong aria-hidden="true">4.6.</strong> Handling git repositories in projects</a></li><li class="chapter-item expanded "><a href="tutorials/pkg-map.html"><strong aria-hidden="true">4.7.</strong> Mapping non-Haskell dependencies to Nixpkgs</a></li><li class="chapter-item expanded "><a href="tutorials/hackage-stackage.html"><strong aria-hidden="true">4.8.</strong> Bumping Hackage and Stackage snapshots</a></li><li class="chapter-item expanded "><a href="tutorials/materialization.html"><strong aria-hidden="true">4.9.</strong> Materialization: Speeding up Nix evaluation</a></li><li class="chapter-item expanded "><a href="tutorials/cross-compilation.html"><strong aria-hidden="true">4.10.</strong> Cross-compiling your project</a></li><li class="chapter-item expanded "><a href="tutorials/coverage.html"><strong aria-hidden="true">4.11.</strong> Generating coverage information</a></li><li class="chapter-item expanded "><a href="tutorials/building-package-from-stackage-hackage.html"><strong aria-hidden="true">4.12.</strong> Build a specific package from Hackage or Stackage</a></li><li class="chapter-item expanded "><a href="tutorials/ca-derivations.html"><strong aria-hidden="true">4.13.</strong> Content addressed derivations</a></li></ol></li><li class="chapter-item expanded "><a href="reference/index.html"><strong aria-hidden="true">5.</strong> Reference</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reference/supported-ghc-versions.html"><strong aria-hidden="true">5.1.</strong> Supported GHC versions</a></li><li class="chapter-item expanded "><a href="reference/commands.html"><strong aria-hidden="true">5.2.</strong> Command-line tools</a></li><li class="chapter-item expanded "><a href="reference/library.html"><strong aria-hidden="true">5.3.</strong> Haskell.nix Library</a></li><li class="chapter-item expanded "><a href="reference/modules.html"><strong aria-hidden="true">5.4.</strong> Module options</a></li><li class="chapter-item expanded "><a href="troubleshooting.html"><strong aria-hidden="true">5.5.</strong> Troubleshooting</a></li></ol></li><li class="chapter-item expanded "><a href="template/index.html"><strong aria-hidden="true">6.</strong> Templates / Abstraction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="template/iohk-nix.html"><strong aria-hidden="true">6.1.</strong> IOHKs nix library</a></li></ol></li><li class="chapter-item expanded "><a href="dev/index.html"><strong aria-hidden="true">7.</strong> Dev Notes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="dev/dev-architecture.html"><strong aria-hidden="true">7.1.</strong> Architecture</a></li><li class="chapter-item expanded "><a href="dev/installing-nix-tools.html"><strong aria-hidden="true">7.2.</strong> Installing nix-tools</a></li><li class="chapter-item expanded "><a href="dev/nix-tools-pin.html"><strong aria-hidden="true">7.3.</strong> How to update nix-tools</a></li><li class="chapter-item expanded "><a href="dev/manually-generating-nix-expressions.html"><strong aria-hidden="true">7.4.</strong> Manually generating Nix expressions</a></li><li class="chapter-item expanded "><a href="dev/maintainer-scripts.html"><strong aria-hidden="true">7.5.</strong> Maintainer Scripts</a></li><li class="chapter-item expanded "><a href="dev/nixpkgs-pin.html"><strong aria-hidden="true">7.6.</strong> Nixpkgs Pin</a></li><li class="chapter-item expanded "><a href="dev/removing-with-package-wrapper.html"><strong aria-hidden="true">7.7.</strong> Removing withPackage wrapper</a></li><li class="chapter-item expanded "><a href="dev/tests.html"><strong aria-hidden="true">7.8.</strong> Test Suite</a></li><li class="chapter-item expanded "><a href="dev/adding-new-ghc.html"><strong aria-hidden="true">7.9.</strong> Adding a new GHC version</a></li><li class="chapter-item expanded "><a href="dev/coverage.html"><strong aria-hidden="true">7.10.</strong> Coverage</a></li><li class="chapter-item expanded "><a href="dev/hix.html"><strong aria-hidden="true">7.11.</strong> Making changes to Hix</a></li><li class="chapter-item expanded "><a href="changelog.html"><strong aria-hidden="true">7.12.</strong> ChangeLog</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Alternative Haskell Infrastructure for Nixpkgs</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="haskellnix"><a class="header" href="#haskellnix">haskell.nix</a></h1>
<p><code>haskell.nix</code> is an alternative Haskell infrastructure for Nix<sup class="footnote-reference"><a href="#1">1</a></sup>.</p>
<h2 id="features"><a class="header" href="#features">Features</a></h2>
<ul>
<li>Drop-in support for Cabal projects</li>
<li>Drop-in support for Stack projects</li>
<li>Build any package of specific version in Stackage or Hackage</li>
<li>Overridable configuration</li>
<li>Cross compile Haskell packages</li>
</ul>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>See <a href="https://haskell4nix.readthedocs.io/">Nixpkgs current Users' Guide to Haskell Infrastructure</a> for comparison.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="motivation"><a class="header" href="#motivation">Motivation</a></h1>
<p>Why do we need another Haskell infrastructure for Nix?</p>
<p>Doesn't nixpkgs
provide a sufficiently good Haskell infrastructure already?</p>
<p>Problems with
the nixpkgs haskell infrastructure are covered in the following sections:</p>
<h2 id="cross-compilation"><a class="header" href="#cross-compilation">Cross compilation</a></h2>
<p><code>nixpkgs</code> has quite good support for cross compilation, however the
Haskell infrastructure suffers from the fact that it heavily relies on
the <code>cabal2nix</code> tool.  <code>cabal2nix</code> (as well as tools that depend on it
like <code>stack2nix</code>) flattens the <code>.cabal</code> file at conversion time to a
given os/arch/flags configuration.  Thus to make cross compilation
work with <code>cabal2nix</code> you will have to generate a separate <code>nix</code>
expression for each configuration.  This becomes a major maintenance
burden over time.  Therefore the tooling that translates cabal files
into nix-expressions for use with Haskell.nix retains the full
conditional tree from the cabal file and exposes it to <code>nix</code>.  In
addition it will also expose the <code>build-type</code> value, which allows us
to cache the <code>Setup.hs</code> for build-type simple and not have to rebuild
it every time.</p>
<h2 id="package-sets"><a class="header" href="#package-sets">Package sets</a></h2>
<p>We often rely on either package sets as provided by stackage or
computed by cabal.  <code>nixpkgs</code> provides its own curated package set
which might or might not work for the projects we work on.
<code>stack2nix</code> tries to solve this issue, here we go one step further and
provide the infrastructure to allow any form of package set.</p>
<h2 id="per-component-level-control"><a class="header" href="#per-component-level-control">Per component level control</a></h2>
<p>The Haskell builder in <code>nixpkgs</code> provides control over executables and
libraries, to build a specific executable only however is rather
tricky to do.  This also leads to the cyclic dependencies issue.</p>
<h2 id="cyclic-dependencies"><a class="header" href="#cyclic-dependencies">Cyclic dependencies</a></h2>
<p>The Haskell builder in <code>nixpkgs</code> exposes packages at the
package level. If packages mutually depend on each other through tests
and libraries, this leads to cyclic dependencies that nix can't resolve. By
exposing the components to nix as separate derivations this will only
occur if you have mutually dependent components.</p>
<h2 id="build-times"><a class="header" href="#build-times">Build times</a></h2>
<p>The Haskell builder in nixpkgs builds a package sequentially, first the
library then the executables and finally the tests.  It then executes
the tests before the package is considered done.  The upshot of this
is that packages are only considered done if the test-suites
passed.  The downside is that if you have to compile multiple packages
the likelihood of them failing is low, you have unnecessarily
serialized your build.  In a more aggressive setting libraries could
start building as early as their dependent libraries are built.  Of
course they will have to be invalidated later should the test-suites
of their dependencies fail, but this way we can make use of parallel
building.  In an ideal scenario this will reduce build times close to
the optimum.</p>
<h2 id="more-logic-in-nix"><a class="header" href="#more-logic-in-nix">More logic in nix</a></h2>
<p>The <code>cabal2nix</code> tool has a resolver that resolves system dependencies
and licenses to values in <code>nixpkgs</code>.  This logic ends up being a simple
dictionary lookup and therefore can be a simple nix expression. This also
offloads some of the work the cabal to nix translation tool needs to
do into nix, and as such if changes are necessary (or needed to be
performed ad hoc) there is no need to rebuild the conversion tool and
subsequently mark every derived expression as out of date.</p>
<h2 id="decoupling"><a class="header" href="#decoupling">Decoupling</a></h2>
<p>Finally, by treating Haskell.nix and nixpkgs as separate entities we
can decouple the Haskell packages and infrastructure from the nixpkgs
package set, and rely on it to provide us with system packages while
staying up to date with Haskell packages from hackage while retaining
a stable (or known to be good) nixpkgs revision.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="architecture"><a class="header" href="#architecture">Architecture</a></h1>
<p>There are multiple components that play a part in the haskell.nix
infrastructure.  These are <code>nix-tools</code>, <code>haskell.nix</code>, <code>hackage.nix</code>,
and <code>stackage.nix</code>.</p>
<pre><code class="language-no-highlight">                                             .-------------.     .-------------.
.- nix-tools ------.                         | haskell.nix |  .- | hackage.nix |
| .--------------. |   .----------------.    '-------------'  |  '-------------'
| | stack-to-nix |---&gt; | stack-pkgs.nix |-.         |         |         |
| '--------------' |   '----------------' |         v         |         v
| .-------------.  |   .----------.       '--&gt; .----------. &lt;-'  .--------------.
| | plan-to-nix |----&gt; | plan.nix |------.---&gt; | pkgs.nix | &lt;--- | stackage.nix |
| '-------------'  |   '----------'      |     '----------'      '--------------'
| .--------------. |   .--------------.  |          |
| | cabal-to-nix |---&gt; | $package.nix |--'          v
| '--------------' |   '--------------'       .-------------.
'------------------'                          | default.nix |
                                              '-------------'
                                                    |
                                                    v
                                              .-------------.
                                              | release.nix |
                                              '-------------'
</code></pre>
<p>haskell.nix diagram</p>
<h2 id="nix-tools"><a class="header" href="#nix-tools"><a href="https://github.com/input-output-hk/nix-tools">nix-tools</a></a></h2>
<p>nix-tools is a Haskell package that provides the following tools:</p>
<ul>
<li>
<p><code>cabal-to-nix</code>: a <code>.cabal</code> to <code>.nix</code> transformer that retains
conditional expressions.</p>
</li>
<li>
<p><code>stack-to-nix</code>: a <code>stack.yaml</code> to <code>.nix</code> transformer that will read
in a <code>stack.yaml</code> expression an generate a <code>pkgs.nix</code> file suited for
use with <code>haskell.nix</code>.</p>
</li>
<li>
<p><code>plan-to-nix</code>: a <code>plan.json</code> to <code>.nix</code> transformer that will read in
a <code>plan.json</code> file and generate a <code>pkgs.nix</code> file suited for use
with <code>haskell.nix</code>.</p>
</li>
</ul>
<p>as well as a few other tools used to generate <code>hackage.nix</code> and <code>stackage.nix</code>.</p>
<h2 id="haskellnix-1"><a class="header" href="#haskellnix-1"><a href="https://github.com/input-output-hk/haskell.nix">haskell.nix</a></a></h2>
<p><a href="https://github.com/input-output-hk/haskell.nix">Haskell.nix</a> is the runtime system for this Haskell infrastructure.
It contains the component builder, as well as the system package and
license mapping.  Without haskell.nix the expressions generated by
either of the <code>nix-tools</code> tools make little sense on their own.</p>
<h2 id="hackagenix"><a class="header" href="#hackagenix"><a href="https://github.com/input-output-hk/hackage.nix">hackage.nix</a></a></h2>
<p><a href="https://github.com/input-output-hk/hackage.nix">hackage.nix</a> provides all cabal expressions from hackage as nix
expressions.  It is periodically updated to keep in sync with the set
of packages available on hackage.</p>
<h2 id="stackagenix"><a class="header" href="#stackagenix"><a href="https://github.com/input-output-hk/stackage.nix">stackage.nix</a></a></h2>
<p><a href="https://github.com/input-output-hk/stackage.nix">stackage.nix</a> is similar to hackage.nix but provides all stackage
snapshots (lts, and nightly) as nix expressions.  It naturally depends
on hackage.nix to resolve package names, versions and revisions to the
respective packages from hackage.nix.</p>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting started</a></h1>
<p><code>haskell.nix</code> can automatically translate your
<a href="https://cabal.readthedocs.io/en/latest/cabal-project.html">Cabal</a>
or <a href="https://docs.haskellstack.org/en/stable/README/#quick-start-guide">Stack</a>
project and its dependencies into Nix code.</p>
<p>Assuming you have <a href="https://nixos.org/download.html">Nix</a> installed, you can
start setting up your project.</p>
<h2 id="setting-up-the-binary-cache"><a class="header" href="#setting-up-the-binary-cache">Setting up the binary cache</a></h2>
<p>IMPORTANT: you <em>must</em> do this or you <em>will</em> build several copies of GHC!</p>
<p>You can configure Nix to use our binary cache, which is pushed to by CI, so should contain the artifacts that you need.</p>
<p>You need to add the following sections to <code>/etc/nix/nix.conf</code> or, if you are a trusted user, <code>~/.config/nix/nix.conf</code> (if you don't know what a &quot;trusted user&quot; is, you probably want to do the former). <code>[...]</code> denote any existing entries.</p>
<pre><code>trusted-public-keys = [...] hydra.iohk.io:f/Ea+s+dFdN+3Y/G+FDgSq+a5NEWhJGzdjvKNGv0/EQ= [...]
substituters = [...] https://cache.iog.io [...]
</code></pre>
<p>If you're running NixOS, you need to add/update the following in your <code>/etc/nixos/configuration.nix</code> files instead.</p>
<pre><code class="language-nix"># Binary Cache for Haskell.nix
nix.settings.trusted-public-keys = [
  &quot;hydra.iohk.io:f/Ea+s+dFdN+3Y/G+FDgSq+a5NEWhJGzdjvKNGv0/EQ=&quot;
];
nix.settings.substituters = [
  &quot;https://cache.iog.io&quot;
];
</code></pre>
<p>NixOS-21.11 and older use slightly different settings.</p>
<pre><code class="language-nix"># Binary Cache for Haskell.nix  
nix.binaryCachePublicKeys = [
  &quot;hydra.iohk.io:f/Ea+s+dFdN+3Y/G+FDgSq+a5NEWhJGzdjvKNGv0/EQ=&quot;
];
nix.binaryCaches = [
  &quot;https://cache.iog.io&quot;
];   
</code></pre>
<p>This can be tricky to get setup properly. If you're still having trouble getting cache hits, consult the corresponding <a href="tutorials/../troubleshooting.html#why-am-i-building-ghc">troubleshooting section</a>.</p>
<h2 id="niv"><a class="header" href="#niv">Niv</a></h2>
<p><a href="https://github.com/nmattia/niv">Niv</a> is a command line tool for keeping track of Nix project dependencies.</p>
<p>This guide assumes that the <code>sources.haskellNix</code> will be set to point
a pinned copy of the haskell.nix github repo.  One easy way to do this
is to use Niv.  If you prefer not to use Niv another option is described
in the in the &quot;Using haskell.nix without niv&quot; section of this document.</p>
<p>If you want to use Nix Flakes to pin your dependencies then you should
consider following the <a href="tutorials/./getting-started-flakes.html">Getting started with flakes</a>
document instead of this one.</p>
<p>After installing niv you can initialize niv and pin the latest haskell.nix
commit by running the following in the root directory of the project:</p>
<pre><code class="language-shell">niv init
niv add input-output-hk/haskell.nix -n haskellNix
</code></pre>
<p>Then when you want to update to the latest version of haskellNix use:</p>
<pre><code class="language-shell">niv update haskellNix
</code></pre>
<h2 id="scaffolding"><a class="header" href="#scaffolding">Scaffolding</a></h2>
<p>The following work with <code>stack.yaml</code> and <code>cabal.project</code> based
projects.</p>
<p>Add <code>default.nix</code>:</p>
<pre><code class="language-nix">let
  # Read in the Niv sources
  sources = import ./nix/sources.nix {};
  # If ./nix/sources.nix file is not found run:
  #   niv init
  #   niv add input-output-hk/haskell.nix -n haskellNix

  # Fetch the haskell.nix commit we have pinned with Niv
  haskellNix = import sources.haskellNix {};
  # If haskellNix is not found run:
  #   niv add input-output-hk/haskell.nix -n haskellNix

  # Import nixpkgs and pass the haskell.nix provided nixpkgsArgs
  pkgs = import
    # haskell.nix provides access to the nixpkgs pins which are used by our CI,
    # hence you will be more likely to get cache hits when using these.
    # But you can also just use your own, e.g. '&lt;nixpkgs&gt;'.
    haskellNix.sources.nixpkgs-unstable
    # These arguments passed to nixpkgs, include some patches and also
    # the haskell.nix functionality itself as an overlay.
    haskellNix.nixpkgsArgs;
in pkgs.haskell-nix.project {
  # 'cleanGit' cleans a source directory based on the files known by git
  src = pkgs.haskell-nix.haskellLib.cleanGit {
    name = &quot;haskell-nix-project&quot;;
    src = ./.;
  };
  # Specify the GHC version to use.
  compiler-nix-name = &quot;ghc925&quot;; # Not required for `stack.yaml` based projects.
}
</code></pre>
<blockquote>
<p><strong>Note:</strong> Git dependencies</p>
<p>If you have git dependencies in your project, you'll need
to <a href="tutorials/./source-repository-hashes.html">calculate sha256 hashes for them</a>.</p>
</blockquote>
<h3 id="working-with-a-project"><a class="header" href="#working-with-a-project">Working with a project</a></h3>
<p>Top-level attributes are Haskell packages (incl. dependencies) part of your project.</p>
<p>To build the library component of a package in the project run:</p>
<pre><code class="language-shell">nix-build -A your-package-name.components.library
</code></pre>
<p>There are also other components such as <code>exes</code>, <code>tests</code>, <code>benchmarks</code> and <code>all</code>.
To build an executable:</p>
<pre><code class="language-shell">nix-build -A your-package-name.components.exes.your-exe-name
</code></pre>
<p>To cross compile use the <code>projectCross</code> attribute:</p>
<pre><code>nix-build -A projectCross.ghcjs.hsPkgs.your-package-name.components.exes.your-exe-name
nix-build -A projectCross.mingwW64.hsPkgs.your-package-name.components.exes.your-exe-name
</code></pre>
<p>To open a shell for use with <code>cabal</code>, <code>hlint</code> and <code>haskell-language-server</code> add <code>shell.nix</code>:</p>
<pre><code class="language-nix">(import ./default.nix).shellFor {
  tools = {
    cabal = &quot;latest&quot;;
    hlint = &quot;latest&quot;;
    haskell-language-server = &quot;latest&quot;;
  };
}
</code></pre>
<p>Then run:</p>
<pre><code class="language-shell">nix-shell
cabal new-repl your-package-name:library:your-package-name
cabal new-build your-package-name
</code></pre>
<p>To open a shell for use with <code>stack</code> see <a href="https://github.com/input-output-hk/haskell.nix/issues/689#issuecomment-643832619">the following issue</a>.</p>
<h2 id="using-haskellnix-without-niv"><a class="header" href="#using-haskellnix-without-niv">Using haskell.nix without Niv</a></h2>
<p>If you would prefer not to use niv you can replace
<code>sources = import ./nix/sources.nix {};</code> in the examples with:</p>
<pre><code class="language-nix">let sources = {
    haskellNix = builtins.fetchTarball &quot;https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz&quot;;
  };
</code></pre>
<p>The <code>fetchTarball</code> call above will always get the latest version, and is
similar to an auto-updating Nix channel.</p>
<p>However, in your own project, you may wish to pin <a href="https://github.com/input-output-hk/haskell.nix">haskell.nix</a> (as
you would pin Nixpkgs). This will make your builds reproducible, more
predictable, and faster (because the fixed version is cached).</p>
<p>Straightforward way of doing this is to change the branch name to a revision.</p>
<pre><code class="language-nix">let sources = {
    haskellNix = builtins.fetchTarball &quot;https://github.com/input-output-hk/haskell.nix/archive/f1a94a4c82a2ab999a67c3b84269da78d89f0075.tar.gz&quot;;
  };
</code></pre>
<p>There are other possible schemes for pinning. See
<a href="tutorials/./hackage-stackage.html">Bumping Hackage and Stackage snapshots</a> and
<a href="https://nix.dev/tutorials/towards-reproducibility-pinning-nixpkgs.html">Nix tutorial on reproducibility using pinning</a>.</p>
<h2 id="going-forward"><a class="header" href="#going-forward">Going forward</a></h2>
<p>Read through <a href="tutorials/../reference/library.html#project">project</a> function reference to see how the API works.</p>
<p>There are a number of things to explore further in the tutorials section.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started-with-flakes"><a class="header" href="#getting-started-with-flakes">Getting started with flakes</a></h1>
<p>This version of the getting started guide is for users who
are using <a href="https://nixos.wiki/wiki/Flakes">Nix Flakes</a>.
The non flakes version of the guide is <a href="tutorials/getting-started.html">here</a>.</p>
<p><code>haskell.nix</code> can automatically translate your
<a href="https://cabal.readthedocs.io/en/latest/cabal-project.html">Cabal</a>
or <a href="https://docs.haskellstack.org/en/stable/README/#quick-start-guide">Stack</a>
project and its dependencies into Nix code.</p>
<p>Assuming you have <a href="https://nixos.org/download.html">Nix</a> installed, you can
start setting up your project.</p>
<h2 id="using-flake-init-and-nix"><a class="header" href="#using-flake-init-and-nix">Using <code>flake init</code> and <code>nix</code></a></h2>
<p>The <code>flake init</code> command create an example <code>hello</code> package from hackage
containing an <code>flake.nix</code> and <code>nix/hix.nix</code> file. The project can be used with
regular <code>nix</code> tools.</p>
<pre><code class="language-bash">nix flake init --template templates#haskell-nix --impure
# `--impure` is required by `builtins.currentSystem`
nix develop
cabal build
</code></pre>
<p>To view the contents of the flake run:</p>
<pre><code>nix flake show
</code></pre>
<p>To build a component with nix:</p>
<pre><code>nix build .#hello:exe:hello
</code></pre>
<p>To build and run a component:</p>
<pre><code>nix run .#hello:exe:hello
</code></pre>
<h2 id="setting-up-the-binary-cache-1"><a class="header" href="#setting-up-the-binary-cache-1">Setting up the binary cache</a></h2>
<p>IMPORTANT: you <em>must</em> do this or you <em>will</em> build several copies of GHC!</p>
<p>You can configure Nix to use our binary cache, which is pushed to by CI, so should contain the artifacts that you need.</p>
<p>You need to add the following sections to <code>/etc/nix/nix.conf</code> or, if you are a trusted user, <code>~/.config/nix/nix.conf</code> (if you don't know what a &quot;trusted user&quot; is, you probably want to do the former).</p>
<pre><code>trusted-public-keys = [...] hydra.iohk.io:f/Ea+s+dFdN+3Y/G+FDgSq+a5NEWhJGzdjvKNGv0/EQ= [...]
substituters = [...] https://cache.iog.io [...]
</code></pre>
<p>If you're running NixOS, you need to add/update the following in your <code>/etc/nixos/configuration.nix</code> files instead.</p>
<pre><code class="language-nix"># Binary Cache for Haskell.nix
nix.settings.trusted-public-keys = [
  &quot;hydra.iohk.io:f/Ea+s+dFdN+3Y/G+FDgSq+a5NEWhJGzdjvKNGv0/EQ=&quot;
];
nix.settings.substituters = [
  &quot;https://cache.iog.io&quot;
];
</code></pre>
<p>NixOS-21.11 and older use slightly different settings.</p>
<pre><code class="language-nix"># Binary Cache for Haskell.nix  
nix.binaryCachePublicKeys = [
  &quot;hydra.iohk.io:f/Ea+s+dFdN+3Y/G+FDgSq+a5NEWhJGzdjvKNGv0/EQ=&quot;
];
nix.binaryCaches = [
  &quot;https://cache.iog.io&quot;
];   
</code></pre>
<p>This can be tricky to get setup properly. If you're still having trouble getting cache hits, consult the corresponding <a href="tutorials/../troubleshooting.html#why-am-i-building-ghc">troubleshooting section</a>.</p>
<h2 id="scaffolding-1"><a class="header" href="#scaffolding-1">Scaffolding</a></h2>
<p>The following work with <code>stack.yaml</code> and <code>cabal.project</code> based
projects.</p>
<p>Add <code>flake.nix</code>:</p>
<pre><code class="language-nix">{
  description = &quot;A very basic flake&quot;;
  inputs.haskellNix.url = &quot;github:input-output-hk/haskell.nix&quot;;
  inputs.nixpkgs.follows = &quot;haskellNix/nixpkgs-unstable&quot;;
  inputs.flake-utils.url = &quot;github:numtide/flake-utils&quot;;
  outputs = { self, nixpkgs, flake-utils, haskellNix }:
    flake-utils.lib.eachSystem [ &quot;x86_64-linux&quot; &quot;x86_64-darwin&quot; ] (system:
    let
      overlays = [ haskellNix.overlay
        (final: prev: {
          # This overlay adds our project to pkgs
          helloProject =
            final.haskell-nix.project' {
              src = ./.;
              compiler-nix-name = &quot;ghc925&quot;;
              # This is used by `nix develop .` to open a shell for use with
              # `cabal`, `hlint` and `haskell-language-server`
              shell.tools = {
                cabal = {};
                hlint = {};
                haskell-language-server = {};
              };
              # Non-Haskell shell tools go here
              shell.buildInputs = with pkgs; [
                nixpkgs-fmt
              ];
              # This adds `js-unknown-ghcjs-cabal` to the shell.
              # shell.crossPlatforms = p: [p.ghcjs];
            };
        })
      ];
      pkgs = import nixpkgs { inherit system overlays; inherit (haskellNix) config; };
      flake = pkgs.helloProject.flake {
        # This adds support for `nix build .#js-unknown-ghcjs:hello:exe:hello`
        # crossPlatforms = p: [p.ghcjs];
      };
    in flake // {
      # Built by `nix build .`
      packages.default = flake.packages.&quot;hello:exe:hello&quot;;
    });
}
</code></pre>
<blockquote>
<p><strong>Note:</strong> Git dependencies</p>
<p>If you have git dependencies in your project, you'll need
to <a href="tutorials/./source-repository-hashes.html">calculate sha256 hashes for them</a>.</p>
</blockquote>
<h3 id="working-with-a-project-1"><a class="header" href="#working-with-a-project-1">Working with a project</a></h3>
<p>Top-level attributes are Haskell packages (incl. dependencies) part of your project.</p>
<p>To build the library component of a package in the project run:</p>
<pre><code class="language-shell">nix build .#your-package-name:lib:your-package-name
</code></pre>
<p>There are also other components such as <code>exe</code>, <code>test</code> and <code>benchmark</code>.
To build an executable:</p>
<pre><code class="language-shell">nix build .#your-package-name:exe:your-exe-name
</code></pre>
<p>To use the <code>devShell</code> provided by the flake run:</p>
<pre><code class="language-shell">nix develop .
cabal repl your-package-name:lib:your-package-name
cabal build your-package-name
</code></pre>
<p>To open a shell for use with <code>stack</code> see <a href="https://github.com/input-output-hk/haskell.nix/issues/689#issuecomment-643832619">the following issue</a>.</p>
<h2 id="going-forward-1"><a class="header" href="#going-forward-1">Going forward</a></h2>
<p>Read through <a href="tutorials/../reference/library.html#project">project</a> function reference to see how the API works.</p>
<p>There are a number of things to explore further in the tutorials section.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started-with-hix"><a class="header" href="#getting-started-with-hix">Getting started with Hix</a></h1>
<p>Hix is a command line tool that provides an easy way to add haskell.nix
support to existing haskell projects.</p>
<p>You will need <code>nix</code> installed and in you <code>PATH</code> with nix in PATH with
<code>experimental-features = [ &quot;nix-command&quot; &quot;flakes&quot; ];</code> configured.
See https://nixos.wiki/wiki/Flakes for details.</p>
<h2 id="using-hix-init-and-nix"><a class="header" href="#using-hix-init-and-nix">Using <code>hix init</code> and <code>nix</code></a></h2>
<p>The <code>hix init</code> command adds a <code>flake.nix</code> and <code>nix/hix.nix</code> file.
After that the project can be used with regular <code>nix</code> tools.</p>
<p>For instance to run <code>cabal build</code> on the <code>hello</code> package from hackage:</p>
<pre><code class="language-shell">cabal unpack hello
cd hello-1.0.0.2
nix run &quot;github:input-output-hk/haskell.nix#hix&quot; -- init
nix develop
cabal build
</code></pre>
<p>To view the contents of the flake run:</p>
<pre><code class="language-shell">nix flake show
</code></pre>
<p>To build a component with nix:</p>
<pre><code class="language-shell">nix build .#hello:exe:hello
</code></pre>
<p>To build and run a component:</p>
<pre><code class="language-shell">nix run .#hello:exe:hello
</code></pre>
<h2 id="installing-hix"><a class="header" href="#installing-hix">Installing Hix</a></h2>
<p>To use the other Hix features first install Hix with:</p>
<pre><code class="language-shell">nix-env -iA hix -f https://github.com/input-output-hk/haskell.nix/tarball/master
</code></pre>
<p>To update run to the latest version run:</p>
<pre><code class="language-shell">hix update
</code></pre>
<h2 id="using-hix-develop-hix-flake-hix-build-and-hix-run"><a class="header" href="#using-hix-develop-hix-flake-hix-build-and-hix-run">Using <code>hix develop</code>, <code>hix flake</code>, <code>hix build</code> and <code>hix run</code></a></h2>
<p>These commands work the same as the <code>nix</code> versions
without using the <code>flake.nix</code>.  Instead a boiler
plate haskell.nix flake.nix file is added to
<code>.hix-flake/flake.nix</code> and used from there.</p>
<p>The is can be useful if the project already includes a
<code>flake.nix</code> or if you do not intend to maintain one.</p>
<p>Then all of these should work without the need to
run <code>hix init</code>:</p>
<pre><code class="language-shell">hix develop
hix flake show
hix build .#hello:exe:hello
hix run .#hello:exe:hello
</code></pre>
<h2 id="using-hix-shell-and-hix-build"><a class="header" href="#using-hix-shell-and-hix-build">Using <code>hix-shell</code> and <code>hix-build</code></a></h2>
<p>These commands behave like <code>nix-build</code> and <code>hix-shell</code>
would if a boiler plate <code>default.nix</code> and <code>shell.nix</code>
we present.</p>
<pre><code class="language-shell">hix-shell --run 'cabal build all'
hix-build -A hsPkgs.hello.components.exes.hello
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>Haskell.nix also provides reproducible development environments for
your Haskell projects. These environments can contain not only GHC and
your Haskell package dependencies, but also the required system
libraries and build tools.</p>
<p>Inside the development shell, you can run commands such as <code>ghc</code>,
<code>ghci</code>, or <code>cabal new‑build</code> (<code>cabal build</code> on Cabal 3.0),
and they will have all dependencies available.</p>
<p>Every dependency will be cached in your Nix store. If you have set up
Hydra CI, then your team can share pre-built dependencies.</p>
<p>These examples assume that you have created your package set as
described in <a href="tutorials/getting-started.html">Creating Nix builds for your projects</a> and
it exists in a file called <code>default.nix</code>.</p>
<blockquote>
<p><strong>Note:</strong></p>
<p>Old-style <code>cabal build</code> and <code>stack</code> builds are not (yet)
supported. For example, <code>stack</code> will (by design) download and
rebuild all dependencies, even though they are available in the
shell. However, if you have a Stack project, you can generate the
package set with Haskell.nix, then use <code>cabal new‑build</code> to work
on it.  Starting Cabal 3.0 <code>cabal build</code> will work out of the box, as
new style builds are the default.</p>
</blockquote>
<h2 id="how-to-get-a-development-shell"><a class="header" href="#how-to-get-a-development-shell">How to get a development shell</a></h2>
<p>If you have a Cabal or Stack project with one or more packages
(i.e. multiple <code>.cabal</code> files, not a single package with multiple
components), then you will need a development environment that
contains the <em>dependencies</em> of your packages, but not the packages
themselves. This is what the <a href="tutorials/../reference/library.html#shellfor"><code>shellFor</code></a> function does.</p>
<pre><code class="language-nix"># shell.nix
let
  project = import ./default.nix;
in
  project.shellFor {
    # ALL of these arguments are optional.

    # List of packages from the project you want to work on in
    # the shell (default is all the projects local packages).
    packages = ps: with ps; [
      pkga
      pkgb
    ];

    # Builds a Hoogle documentation index of all dependencies,
    # and provides a &quot;hoogle&quot; command to search the index.
    withHoogle = true;

    # Some common tools can be added with the `tools` argument
    tools = {
      cabal = &quot;3.2.0.0&quot;;
      hlint = &quot;latest&quot;; # Selects the latest version in the hackage.nix snapshot
      haskell-language-server = &quot;latest&quot;;
    };
    # See overlays/tools.nix for more details

    # Some you may need to get some other way.
    buildInputs = [ (import &lt;nixpkgs&gt; {}).git ];

    # Sellect cross compilers to include.
    crossPlatforms = ps: with ps; [
      ghcjs      # Adds support for `js-unknown-ghcjs-cabal build` in the shell
      # mingwW64 # Adds support for `x86_64-W64-mingw32-cabal build` in the shell
    ];

    # Prevents cabal from choosing alternate plans, so that
    # *all* dependencies are provided by Nix.
    exactDeps = true;
  }
</code></pre>
<p>See also: <a href="tutorials/../reference/library.html#shellfor">Haskell.nix Library Reference: <code>shellFor</code></a></p>
<h2 id="how-to-get-a-local-hoogle-index"><a class="header" href="#how-to-get-a-local-hoogle-index">How to get a local Hoogle index</a></h2>
<p>If you need a local Hoogle for all the dependencies of your project create this file</p>
<pre><code class="language-nix"># shell-hoogle.nix
let
  project = import ./default.nix {};
in
  project.shellFor {
      packages = ps: [ps.my-package];
      withHoogle = true;
  }
</code></pre>
<p>and run <code>nix-shell shell-hoogle.nix --run &quot;hoogle server --local&quot;</code>.
This will open a local Hoogle server at <code>http://127.0.0.1:8080</code>.</p>
<h2 id="how-to-get-an-ad-hoc-development-shell-including-certain-packages"><a class="header" href="#how-to-get-an-ad-hoc-development-shell-including-certain-packages">How to get an ad-hoc development shell including certain packages</a></h2>
<p>This creates a development environment with the given packages
registered in the package database. The <code>ghcWithPackages</code> function
operates on a Haskell.nix package set, and accepts an argument that
selects packages from the larger package set.</p>
<pre><code class="language-nix"># shell.nix
let
  haskellNix = import (builtins.fetchTarball &quot;https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz&quot;) {};
  nixpkgs = import haskellNix.sources.nixpkgs haskellNix.nixpkgsArgs;
  haskell = nixpkgs.haskell-nix;
in
  haskell.haskellPackages.ghcWithPackages (ps: with ps;
    [ lens conduit conduit-extra ])
</code></pre>
<p>If you need a Hoogle documentation index, use <code>ghcWithHoogle</code> in place
of <code>ghcWithPackages</code>.</p>
<h2 id="how-to-get-packages-from-a-certain-stackage-snapshot"><a class="header" href="#how-to-get-packages-from-a-certain-stackage-snapshot">How to get packages from a certain Stackage snapshot</a></h2>
<p>Haskell.nix knows about every released Stackage snapshot. You can use
it to build packages from a given snapshot, without setting up a full
project.</p>
<pre><code class="language-nix">let
  haskellNix = import (builtins.fetchTarball &quot;https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz&quot;) {};
  nixpkgs = import haskellNix.sources.nixpkgs haskellNix.nixpkgsArgs;
  haskell = nixpkgs.haskell-nix;
in
  haskell.snapshots.&quot;lts-13.18&quot;.alex.components.exes.alex
</code></pre>
<p>There are Haskell.nix package sets for every Stackage snaphot under
<code>haskell.snapshots</code>.</p>
<p>The alias <code>haskell.haskellPackages</code> corresponds to the package set for
a recent LTS Haskell version.</p>
<p>You can use <code>ghcWithPackages</code> on any of these package sets to quickly
get a shell with some packages.</p>
<blockquote>
<p>⚠️ <strong>Warning:</strong></p>
<p>The build will not work if your Nixpkgs does not contain the version
of GHC specified in the snapshot. Nixpkgs only carries the
latest version of each recent release series, so many snapshots
can't be built.</p>
</blockquote>
<h2 id="emacs-ide-support"><a class="header" href="#emacs-ide-support">Emacs IDE support</a></h2>
<p>Once you have a development shell, then you can begin configuring
Emacs to use it. The way I do it is:</p>
<ol>
<li>
<p>Run <a href="https://github.com/target/lorri">lorri watch</a> to continuously
build the shell environment and maintain GC roots.</p>
</li>
<li>
<p>Use <a href="https://github.com/wbolster/emacs-direnv">emacs‑direnv</a> to
push the development environment into Emacs.</p>
</li>
<li>
<p>Use <a href="https://github.com/jyp/dante">Dante</a> for highlighting errors
and auto-completion. You must customize Dante to prevent it from
automatically using <code>nix‑shell</code> or <code>stack</code>. Trim <code>dante‑methods</code> to
just <code>new‑build</code> and <code>bare‑ghci</code>.</p>
<p>You can also use <a href="https://www.gnu.org/software/emacs/manual/html_node/emacs/Directory-Variables.html"><code>.dir‑locals.el</code></a>
for this. If your project has multiple targets, set <code>dante‑target</code>
per-directory.</p>
</li>
<li>
<p>For <a href="https://github.com/haskell/haskell-mode"><code>haskell‑mode</code></a>
interactive Haskell, set <code>haskell‑process‑type</code> to
<code>cabal‑new‑repl</code>.</p>
</li>
</ol>
<h2 id="using-nix-repl"><a class="header" href="#using-nix-repl">Using <code>nix repl</code></a></h2>
<p>It's sometimes useful to load <a href="https://github.com/input-output-hk/haskell.nix">Haskell.nix</a> in the <a href="https://nixos.org/manual/nix/unstable/command-ref/new-cli/nix3-repl.html">REPL</a> to explore
attrsets and try examples.</p>
<pre><code># example.nix
{ nixpkgs ? &lt;nixpkgs&gt; }:
rec {
  haskell = import nixpkgs (import (builtins.fetchTarball https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz) {}).nixpkgsArgs;
  pkgNames = haskell.pkgs.lib.attrNames haskell.haskell-nix.snapshots.&quot;lts-13.18&quot;;
}
</code></pre>
<p>Load the example file:</p>
<pre><code>$ nix repl
Welcome to Nix 2.10.3. Type :? for help.

nix-repl&gt; :l &lt;nixpkgs&gt;
Added 16938 variables.

nix-repl&gt; :l example.nix
Added 2 variables.

nix-repl&gt; lib.take 5 pkgNames
[ &quot;AC-Angle&quot; &quot;ALUT&quot; &quot;ANum&quot; &quot;Agda&quot; &quot;Allure&quot; ]

nix-repl&gt; :q
</code></pre>
<p>Now that you have <code>nix-tools</code> and are able to import <a href="https://github.com/input-output-hk/haskell.nix">Haskell.nix</a>,
you can continue to the next chapter.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cleangit"><a class="header" href="#cleangit">cleanGit</a></h1>
<p>To filter out just the files in your git index use
<code>haskell-nix.haskellLib.cleanGit { src = ./.; }</code> where <code>./.</code> is the
root of your git repo (or a git work tree).</p>
<p>First it filters just the files needed to run <code>git index</code>, then
it uses the results of that to filter your directory.  It does not
need to parse the <code>.gitignore</code> files at all, but we do need to
<code>git add</code> our files before they will be included.
<a href="https://github.com/input-output-hk/haskell.nix/blob/master/lib/clean-git.nix">cleanGit source</a>.</p>
<p>In addition haskell.nix (including <code>cleanGit</code>) uses a version
of <a href="https://github.com/input-output-hk/haskell.nix/blob/master/lib/clean-source-with.nix"><code>cleanSourceWith</code></a>
with a <code>subdir</code> argument to filter out just the package it is
building.  Then it uses the info from the <code>cabal</code> file to filter
just the source dirs for the component it is building.  That way
if we modify a test in a package nix will not rebuild the library
in that package (or anything that depends on that package's library).</p>
<p>There is a downside to this though.  If we have a test that depends
on something outside the scope of what is described in its entry in
the in the <code>.cabal</code> file it will not see it.  For instance perhaps
it needs to run <code>hlint</code> or <code>doctest</code> on the library source.  There
are ways to fix this with a module:</p>
<p>Use <code>extraSrcFiles</code> to add dirs the test needs (this will not result
in a change to the <code>.cabal</code> file the test will still be built the same).</p>
<pre><code class="language-nix">components.tests.test.extraSrcFiles = [ &quot;subdir-needed-by-test&quot; ];
</code></pre>
<p>Or alternatively, override the source with a suitable filter function.</p>
<pre><code class="language-nix">components.tests.test.src = haskell-nix.haskellLib.cleanSourceWith {
    inherit src;
    subdir = &quot;path-to-package&quot;;
    filter = ...
};
</code></pre>
<h2 id="multiple-git-repositories-with-cleangits"><a class="header" href="#multiple-git-repositories-with-cleangits">Multiple Git Repositories with cleanGits</a></h2>
<p>Some times it is handy to temporarily use a relative path between git
repos.  If the repos are individually cleaned this is not possible
(since the cleaned version of one repo will never include the files
of the other).</p>
<p>There are 3 options:</p>
<ul>
<li>
<p>We could <code>symlinkJoin</code> the cleaned directories together, but the
result could not be cleaned and any change would to either
repo would result in a rebuild of everything.</p>
</li>
<li>
<p>We could add one repo to the other as a submodule,
but adding and then removing a submodule is a pain and it does not
work well if you have more than one repo that needs to share the
submodule.</p>
</li>
<li>
<p>We could add a <code>source-repository-package</code> but then we would have
to commit each change before testing.</p>
</li>
</ul>
<p><code>cleanGits</code> allows us to specify a root directory and any number of
sub directories containing git repos.</p>
<p>For example if <code>repoA</code> and <code>repoB</code> are two git repos with
cabal packages and want to use the <code>repoB</code> package when building
<code>repoA</code>.  First we can add <code>../repoB</code> to <code>repoA/cabal.project</code>:</p>
<pre><code>packages:
  ./.
  ../repoB
</code></pre>
<p>Then in <code>repoA/default.nix</code> we can use:</p>
<pre><code class="language-nix">haskell-nix.project {
  src = haskell-nix.haskellLib.cleanSourceWith {
    src = haskell-nix.haskellLib.cleanGits {
      name = &quot;root&quot;;
      src = ../.;    # Parent dir that contains repoA and repoB
      gitDirs = [ &quot;repoA&quot; &quot;repoB&quot; ];
    };
    subDir = &quot;repoA&quot;;       # Where to look for the `cabal.project`
    includeSiblings = true; # Tells it not to exclude `repoB` dir
  };
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="handling-git-repositories-in-projects"><a class="header" href="#handling-git-repositories-in-projects">Handling git repositories in projects</a></h1>
<p>Both <code>stack.yaml</code> and <code>cabal.project</code> files can contain references
to git repositories containing the version of a particular package
that we wish to use.  This is mostly handled automatically by
<code>nix-tools</code> and <code>haskell.nix</code> however when we want to use a nix
system that is configured to use restricted mode (typically hydra)
it will need additional hashes for the referenced repositories.</p>
<p>When using <code>project</code>, <code>cabalProject</code> or <code>stackProject</code> functions
you can include the hash needed in a comment.</p>
<p>To calculate the hash use <code>nix-prefetch-git</code>:</p>
<pre><code>$ nix-prefetch-git https://github.com/input-output-hk/haskell.nix.git bc01ebc05a8105035c9449943046b46c8364b932
...
{
  &quot;url&quot;: &quot;https://github.com/input-output-hk/haskell.nix.git&quot;,
  &quot;rev&quot;: &quot;bc01ebc05a8105035c9449943046b46c8364b932&quot;,
  &quot;date&quot;: &quot;2019-05-30T13:13:18+08:00&quot;,
  &quot;sha256&quot;: &quot;003lm3pm024vhbfmii7xcdd9v2rczpflxf7gdl2pyxia7p014i8z&quot;,
  &quot;fetchSubmodules&quot;: false
}
</code></pre>
<h2 id="cabalproject"><a class="header" href="#cabalproject">Cabal.project</a></h2>
<p>Add a <code>--sha256</code> comment to the <code>cabal.project</code> file:</p>
<pre><code>source-repository-package
  type: git
  location: https://github.com/input-output-hk/haskell.nix.git
  tag: bc01ebc05a8105035c9449943046b46c8364b932
  subdir: test/cabal-simple
  --sha256: 003lm3pm024vhbfmii7xcdd9v2rczpflxf7gdl2pyxia7p014i8z
</code></pre>
<h2 id="stack"><a class="header" href="#stack">Stack</a></h2>
<p>Add a <code># nix-sha256</code> comment to the <code>stack.yaml</code> file:</p>
<pre><code>extra-deps:
- git: https://github.com/input-output-hk/haskell.nix.git
  commit: bc01ebc05a8105035c9449943046b46c8364b932
  subdirs:
    - test/cabal-simple
  # nix-sha256: 003lm3pm024vhbfmii7xcdd9v2rczpflxf7gdl2pyxia7p014i8z
</code></pre>
<h2 id="avoiding-modifying-cabalproject-and-stackyaml"><a class="header" href="#avoiding-modifying-cabalproject-and-stackyaml">Avoiding modifying cabal.project and stack.yaml</a></h2>
<p>In some cases we cannot modify the <code>cabal.project</code> or <code>stack.yaml</code> file to add
sha256 comments. As an alternative we can pass in a <code>sha256map</code>. For instance,
pandoc includes a <code>cabal.project</code> file on hackage which includes a
<code>source-repository-package</code> stanza for <code>pandoc-citeproc</code>:</p>
<pre><code class="language-nix">{ haskell-nix, testSrc } :
let
  pandoc = haskell-nix.hackage-package {
    name         = &quot;pandoc&quot;;
    version      = &quot;2.9.2.1&quot;;
    index-state  = &quot;2020-04-15T00:00:00Z&quot;; 
    # Function that returns a sha256 string by looking up the location
    # and tag in a nested attrset
    sha256map =
      { &quot;https://github.com/jgm/pandoc-citeproc&quot;.&quot;0.17&quot;
          = &quot;0dxx8cp2xndpw3jwiawch2dkrkp15mil7pyx7dvd810pwc22pm2q&quot;; };
  };
in
  pandoc.components.exes.pandoc
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mapping-non-haskell-dependencies-to-nixpkgs"><a class="header" href="#mapping-non-haskell-dependencies-to-nixpkgs">Mapping non-Haskell dependencies to Nixpkgs</a></h1>
<p>Cabal files may contain dependencies to external non-Haskell
dependencies via:</p>
<ul>
<li><a href="https://cabal.readthedocs.io/en/latest/cabal-package.html#pkg-field-build-tool-depends"><code>build-tool-depends</code></a></li>
<li><a href="https://cabal.readthedocs.io/en/latest/cabal-package.html#pkg-field-pkgconfig-depends"><code>pkgconfig-depends</code></a></li>
<li><a href="https://cabal.readthedocs.io/en/latest/cabal-package.html#pkg-field-frameworks"><code>frameworks</code></a></li>
<li><a href="https://cabal.readthedocs.io/en/latest/cabal-package.html#pkg-field-extra-libraries"><code>extra-libraries</code></a></li>
</ul>
<p>If there is a <code>pkgs</code> attribute in Nixpkgs that matches the name given
in the Cabal file, then it will be added as a dependency (see the
output of <code>cabal-to-nix</code>). Otherwise, there needs to be a mapping from
Cabal file names (decided by the package author) to Nix package
identifiers.</p>
<h3 id="nixpkgs-overlay"><a class="header" href="#nixpkgs-overlay">Nixpkgs overlay</a></h3>
<p>The user may solve it by themself by overriding Nixpkgs and adding a
package alias. For example:</p>
<pre><code class="language-nix">nixpkgs.overlays = [
  (self: super: {
    icuuc = self.icu;
    icui18n = self.icu;
    icudata = self.icu;
  })
];
</code></pre>
<p>The user can map package(s) in Nixpkgs to a <code>pkgconfig-depends</code> name by
overlaying the <code>haskell-nix.extraPkgconfigMappings</code> attribute:</p>
<pre><code class="language-nix">nixpkgs.overlays = [
  (self: super: {
    haskell-nix = super.haskell-nix // {
      extraPkgconfigMappings = super.haskell-nix.extraPkgconfigMappings // {
          # String pkgconfig-depends names are mapped to lists of Nixpkgs
          # package names
          &quot;SDL_gpu&quot; = [ &quot;SDL_gpu&quot; ];
      };
    };
  })
];
</code></pre>
<h3 id="replace-libraries-of-components"><a class="header" href="#replace-libraries-of-components">Replace libraries of components</a></h3>
<p>If a component is missing a dependency it can be added via modules. For example:</p>
<pre><code class="language-nix">project = pkgs.haskell-nix.project' {
  src = self;
  compiler-nix-name = &quot;ghc8102&quot;;
  modules = [{
    # Replace `extra-libraries` dependencies
    packages.X11.components.library.libs = pkgs.lib.mkForce (with pkgs.xorg;
        [ libX11 libXrandr libXext libXScrnSaver libXinerama ]);
  }];
};
</code></pre>
<h3 id="mapping-in-haskellnix"><a class="header" href="#mapping-in-haskellnix">Mapping in Haskell.nix</a></h3>
<p>Alternatively, if the name is commonly used, an alias can be added to
the Haskell.nix sources, so that it's solved for all users.</p>
<ul>
<li>
<p><a href="https://github.com/input-output-hk/haskell.nix/blob/master/lib/pkgconf-nixpkgs-map.nix"><code>lib/pkgconf-nixpkgs-map.nix</code></a>
— for <code>pkgconfig-depends</code>.</p>
<p>Each mapping entry is a list of packages.</p>
</li>
<li>
<p><a href="https://github.com/input-output-hk/haskell.nix/blob/master/lib/system-nixpkgs-map.nix"><code>lib/system-nixpkgs-map.nix</code></a>
— for <code>build-tool-depends</code>, <code>frameworks</code>, <code>extra-libraries</code>, etc.</p>
<p>Each name can be mapped to:</p>
<ol>
<li>A single package from nixpkgs.</li>
<li><code>null</code> — eliminates the dependency</li>
<li>A list of packages — sometimes needed for dependencies such as <code>X11</code>.</li>
</ol>
</li>
</ul>
<blockquote>
<p><strong>Tip:</strong> Open a PR</p>
<p>Please go ahead and open a <a href="https://github.com/input-output-hk/haskell.nix/pulls">pull request</a>
to improve the package mappings.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bumping-hackage-and-stackage-snapshots"><a class="header" href="#bumping-hackage-and-stackage-snapshots">Bumping Hackage and Stackage snapshots</a></h1>
<p><code>haskell.nix</code> relies on some generated data providing information about packages in Hackage and Stackage snapshots.
These are kept in <a href="https://github.com/input-output-hk/hackage.nix"><code>hackage.nix</code></a> and <a href="https://github.com/input-output-hk/stackage.nix"><code>stackage.nix</code></a> respectively.
If your project depends on a Hackage package, then the <code>hackage.nix</code> revision used must be new enough to contain that, and likewise for Stackage snaphots and <code>stackage.nix</code>.</p>
<h2 id="updating-and-pinning-hackagenix-and-stackagenix"><a class="header" href="#updating-and-pinning-hackagenix-and-stackagenix">Updating and pinning <code>hackage.nix</code> and <code>stackage.nix</code></a></h2>
<p><code>haskell.nix</code> pins particular revisions of these repositories internally, both for our own usage in testing, and so that users have a sensible default when getting started.
These revisions are updated nightly, so you can get newer revisions of <code>hackage.nix</code> and <code>stackage.nix</code> by updating your revision of <code>haskell.nix</code> itself.</p>
<p>However, this exposes you to changes in <code>haskell.nix</code> which you may not want, such as changes that force compiler rebuilds, or the occasional bug.
Instead, you can pin <code>hackage.nix</code> and <code>stackage.nix</code> independently. For example:</p>
<pre><code class="language-nix">let
  # You can use a tool like `niv` to manage this boilerplate
  hackageSrc = builtins.fetchTarball &quot;https://github.com/input-output-hk/hackage.nix/archive/master.tar.gz&quot;;
  stackageSrc = builtins.fetchTarball &quot;https://github.com/input-output-hk/stackage.nix/archive/master.tar.gz&quot;;
  haskellSrc = builtins.fetchTarball &quot;https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz&quot;;

  haskellNix = import haskellSrc {
    # This allows you to override the pins used by `haskell.nix` internally
    sourcesOverride = {
      hackage = hackageSrc;
      stackage = stackageSrc;
    };
  };
in {
  inherit haskellNix
  # ...
}
</code></pre>
<p>This way you can change the revisions of <code>hackage.nix</code> and <code>stackage.nix</code>
without changing <code>haskell.nix</code>.</p>
<p>However, bear in mind that Stackage refers to Hackage, so your Stackage pin
should never be newer than your Hackage pin.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="materialization"><a class="header" href="#materialization">Materialization</a></h1>
<h2 id="what-is-materialization"><a class="header" href="#what-is-materialization">What is materialization?</a></h2>
<p>Capturing and storing the Nix files for a project so that they do
not need to be built (or checked).  This allows us to cache the input
of an IFD (import from derivation).</p>
<h2 id="why-use-materialization"><a class="header" href="#why-use-materialization">Why use materialization?</a></h2>
<p>Using functions like <code>project</code>, <code>cabalProject</code>, <code>stackProject</code>
and <code>hackage-package</code> results in a lot of dependencies (all the
dependencies of nix-tools for instance).</p>
<ul>
<li>
<p>They can be slow to calculate (even if no work needs to be done it
is not unusual for it to take 5 seconds per project).</p>
</li>
<li>
<p>They can be slow to build (or download) on machines that do not
yet have them in the Nix store.</p>
</li>
<li>
<p>Hydra does not show progress because it does not provide feedback until it
has a list of jobs and the list of jobs cannot depend on the Nix expressions
being present (although this is often blamed on IFD it would be the same if
it wrote out JSON files and read them in)</p>
</li>
</ul>
<h2 id="when-is-it-ok-to-materialize"><a class="header" href="#when-is-it-ok-to-materialize">When is it OK to materialize?</a></h2>
<ul>
<li>
<p>The Nix expressions are unlikely to change frequently (and when it does you
are happy to manually update it).</p>
</li>
<li>
<p>You are happy to script something to update the materialized Nix files
automatically.</p>
</li>
<li>
<p>You are certain that the IFD you materialize is not <code>system</code>-dependent. If it
was you'd obtain different Nix expressions depending on which <code>system</code> the
IFD was evaluated.</p>
</li>
</ul>
<h2 id="how-can-we-materialize-the-nix-files"><a class="header" href="#how-can-we-materialize-the-nix-files">How can we materialize the Nix files?</a></h2>
<p>Lets say we want to build <code>hlint</code>.  We might start with an <code>hlint.nix</code>
file that looks like this:</p>
<pre><code class="language-nix">let inherit (import ./. {}) sources nixpkgsArgs;
    pkgs = import sources.nixpkgs nixpkgsArgs;
    hlint = pkgs.haskell-nix.hackage-package {
      compiler-nix-name = &quot;ghc8102&quot;;
      name = &quot;hlint&quot;;
      version = &quot;2.2.11&quot;;
    };
in hlint
</code></pre>
<p>Building this may result in a lot of output, but if you build
it again it should give just:</p>
<pre><code>$ nix-build hlint.nix -A components.exes.hlint
trace: No index state specified for hlint, using the latest index state that we know about (2021-01-04T00:00:00Z)!
/nix/store/2ybrfmcp79gg75ad4pr1cbxjak70yg8b-hlint-exe-hlint-2.2.11
</code></pre>
<p>To materialize the Nix files we need to take care to pin down the inputs. Stack
projects have their inputs pinned through specifying the snapshot. For cabal
projects this means we must specify the <code>index-state</code> of hackage we want to
use:</p>
<pre><code class="language-nix">let inherit (import ./. {}) sources nixpkgsArgs;
    pkgs = import sources.nixpkgs nixpkgsArgs;
    hlint = pkgs.haskell-nix.hackage-package {
      compiler-nix-name = &quot;ghc8102&quot;;
      name = &quot;hlint&quot;;
      version = &quot;2.2.11&quot;;
      index-state = &quot;2021-01-04T00:00:00Z&quot;;
    };
in hlint
</code></pre>
<p>Now if we build again we get a hint telling use how to calculate a suitable
sha256 hash to turn the derivation containing the Nix files into a fixed-output
derivation:</p>
<pre><code>$ nix-build hlint.nix -A components.exes.hlint
trace: To make project.plan-nix for hlint a fixed-output derivation but not materialized, set `plan-sha256` to the output of the 'calculateMaterializedSha' script in 'passthru'.
trace: To materialize project.plan-nix for hlint entirely, pass a writable path as the `materialized` argument and run the 'updateMaterialized' script in 'passthru'.
/nix/store/2ybrfmcp79gg75ad4pr1cbxjak70yg8b-hlint-exe-hlint-2.2.11

$ nix-build hlint.nix -A project.plan-nix.passthru.calculateMaterializedSha | bash
trace: To make project.plan-nix for hlint a fixed-output derivation but not materialized, set `plan-sha256` to the output of the 'calculateMaterializedSha' script in 'passthru'.
trace: To materialize project.plan-nix for hlint entirely, pass a writable path as the `materialized` argument and run the 'updateMaterialized' script in 'passthru'.
04hdgqwpaswmyb0ili7fwi6czzihd6x0jlvivw52d1i7wv4gaqy7
</code></pre>
<p>For a Stack project all occurences of <code>plan-nix</code> and <code>plan-sha256</code> are replaced
by <code>stack-nix</code> and <code>stack-sha256</code>, respectively.  We can add the hash as
<code>plan-sha256</code>:</p>
<pre><code class="language-nix">let inherit (import ./. {}) sources nixpkgsArgs;
    pkgs = import sources.nixpkgs nixpkgsArgs;
    hlint = pkgs.haskell-nix.hackage-package {
      compiler-nix-name = &quot;ghc8102&quot;;
      name = &quot;hlint&quot;;
      version = &quot;2.2.11&quot;;
      index-state = &quot;2021-01-04T00:00:00Z&quot;;
      plan-sha256 = &quot;04hdgqwpaswmyb0ili7fwi6czzihd6x0jlvivw52d1i7wv4gaqy7&quot;;
    };
in hlint
</code></pre>
<p>Just adding the hash might help reuse of the cached Nix expressions, but Nix
will still calculate all the dependencies (which can add seconds to <code>nix-build</code>
and <code>nix-shell</code> commands when no other work is needed) and users who do not yet
have the dependencies in their store will have to wait while they are built or
downloaded.</p>
<p>Running <code>nix-build</code> again gives us a hint on what we can do next:</p>
<pre><code>$ nix-build hlint.nix -A components.exes.hlint
trace: To materialize project.plan-nix for hlint entirely, pass a writable path as the `materialized` argument and run the 'updateMaterialized' script in 'passthru'.
/nix/store/2ybrfmcp79gg75ad4pr1cbxjak70yg8b-hlint-exe-hlint-2.2.11
</code></pre>
<p>To capture the Nix expressions we can do something like:</p>
<pre><code class="language-nix">let inherit (import ./. {}) sources nixpkgsArgs;
    pkgs = import sources.nixpkgs nixpkgsArgs;
    hlint = pkgs.haskell-nix.hackage-package {
      compiler-nix-name = &quot;ghc8102&quot;;
      name = &quot;hlint&quot;;
      version = &quot;2.2.11&quot;;
      index-state = &quot;2021-01-04T00:00:00Z&quot;;
      plan-sha256 = &quot;04hdgqwpaswmyb0ili7fwi6czzihd6x0jlvivw52d1i7wv4gaqy7&quot;;
      materialized = ./hlint.materialized;
    };
in hlint
</code></pre>
<p>Now we can copy the Nix files needed and build with:</p>
<pre><code>$ nix-build hlint.nix 2&gt;&amp;1 | grep -om1 '/nix/store/.*-updateMaterialized' | bash
$ nix-build hlint.nix -A components.exes.hlint
building '/nix/store/wpxsgzl1z4jnhfqzmzg3xxv3ljpmzr5h-hlint-plan-to-nix-pkgs.drv'...
/nix/store/2ybrfmcp79gg75ad4pr1cbxjak70yg8b-hlint-exe-hlint-2.2.11
</code></pre>
<h2 id="how-can-we-check-sha256-and-materialized-are-up-to-date"><a class="header" href="#how-can-we-check-sha256-and-materialized-are-up-to-date">How can we check <code>sha256</code> and <code>materialized</code> are up to date?</a></h2>
<p>Let's pretend we had to go back to <code>hlint</code> version <code>2.2.10</code>.
We can tell haskell.nix to check the materialization either by:</p>
<ul>
<li>
<p>Removing the materialization files with <code>rm -rf hlint.materialized</code></p>
</li>
<li>
<p>Temporarily adding <code>checkMaterialization = true;</code></p>
</li>
</ul>
<p>If we choose to add the <code>checkMaterialization</code> flag you would have:</p>
<pre><code class="language-nix">let inherit (import ./. {}) sources nixpkgsArgs;
    pkgs = import sources.nixpkgs nixpkgsArgs;
    hlint = pkgs.haskell-nix.hackage-package {
      compiler-nix-name = &quot;ghc8102&quot;;
      name = &quot;hlint&quot;;
      version = &quot;2.2.10&quot;;
      index-state = &quot;2021-01-04T00:00:00Z&quot;;
      plan-sha256 = &quot;04hdgqwpaswmyb0ili7fwi6czzihd6x0jlvivw52d1i7wv4gaqy7&quot;;
      materialized = ./hlint.materialized;
      checkMaterialization = true;
    };
in hlint
</code></pre>
<p>This will fail and report the details of what is wrong and how to fix it:</p>
<pre><code>$ nix-build hlint.nix -A components.exes.hlint

...

Calculated hash for hlint-plan-to-nix-pkgs was not 04hdgqwpaswmyb0ili7fwi6czzihd6x0jlvivw52d1i7wv4gaqy7. New hash is :
    plan-sha256 = &quot;0jsgdmii0a6b35sd42cpbc83s4sp4fbx8slphzvamq8n9x49i5b6&quot;;
Materialized nix used for hlint-plan-to-nix-pkgs incorrect. To fix run: /nix/store/6wp0zzal40ls874f5ddpaac7qmii9y4z-updateMaterialized
builder for '/nix/store/61a0vginv76w4p9ycyd628pjanav06pl-hlint-plan-to-nix-pkgs.drv' failed with exit code 1
error: build of '/nix/store/61a0vginv76w4p9ycyd628pjanav06pl-hlint-plan-to-nix-pkgs.drv' failed
(use '--show-trace' to show detailed location information)
</code></pre>
<p>Checking the materialization requires Nix to do all the work that
materialization avoids.  So while it might be tempting to leave
<code>checkMaterialization = true</code> all the time, we would be better off just
removing <code>materialized</code> and <code>plan-sha256</code>.</p>
<h2 id="how-can-we-update-the-nix-files-with-a-script"><a class="header" href="#how-can-we-update-the-nix-files-with-a-script">How can we update the Nix files with a script?</a></h2>
<p>We can simply put the commands we used earlier in a script:</p>
<pre><code class="language-nix">#!/bin/sh

# Output new plan-sha256
nix-build hlint.nix -A project.plan-nix.passthru.calculateMaterializedSha | bash

# Update materialized Nix expressions
nix-build hlint.nix 2&gt;&amp;1 | grep -om1 '/nix/store/.*-updateMaterialized' | bash
</code></pre>
<h2 id="can-we-skip-making-a-copy-and-use-materialized--nixstore"><a class="header" href="#can-we-skip-making-a-copy-and-use-materialized--nixstore">Can we skip making a copy and use <code>materialized = /nix/store/...</code>?</a></h2>
<p>Yes and it gives us the same speed improvement, however:</p>
<ul>
<li>
<p>It does not help at all in <code>restricted-eval</code> mode (Hydra).</p>
</li>
<li>
<p>Users will still wind up building or downloading the dependencies
needed to build the Nix files (if they do not have them).</p>
</li>
</ul>
<p>For those reasons it might be best to make a copy instead
of using the <code>/nix/store/...</code> path directly.</p>
<p>If you really want to use the <code>/nix/store/...</code> path directly
you should guard against the path not existing as passing in
a non-existing path is now an error:</p>
<pre><code class="language-nix">let inherit (import ./. {}) sources nixpkgsArgs;
    pkgs = import sources.nixpkgs nixpkgsArgs;
    hlintPlan = /nix/store/63k3f8bvsnag7v36vb3149208jyx61rk-hlint-plan-to-nix-pkgs;
    hlint = pkgs.haskell-nix.hackage-package {
      compiler-nix-name = &quot;ghc8102&quot;;
      name = &quot;hlint&quot;;
      version = &quot;2.2.11&quot;;
      index-state = &quot;2021-01-04T00:00:00Z&quot;;
      plan-sha256 = &quot;04hdgqwpaswmyb0ili7fwi6czzihd6x0jlvivw52d1i7wv4gaqy7&quot;;
      materialized = if __pathExists hlintPlan then hlintPlan else null;
    };
in hlint
</code></pre>
<p>Running when no building is needed is still slow in restricted evaluation mode.</p>
<pre><code class="language-shell">$ time nix-build --option restrict-eval true -I . --option allowed-uris &quot;https://github.com/NixOS https://github.com/input-output-hk&quot; hlint.nix -A components.exes.hlint --show-trace
/nix/store/2ybrfmcp79gg75ad4pr1cbxjak70yg8b-hlint-exe-hlint-2.2.11

real	0m4.463s
user	0m4.440s
sys	0m0.461s
$ time nix-build hlint.nix -A components.exes.hlint
/nix/store/2ybrfmcp79gg75ad4pr1cbxjak70yg8b-hlint-exe-hlint-2.2.11

real	0m2.206s
user	0m1.665s
sys	0m0.332s
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cross-compilation-1"><a class="header" href="#cross-compilation-1">Cross compilation</a></h1>
<p>Cross compilation of Haskell projects involves building a version of
GHC that outputs code for the target platform, and providing builds of
all library dependencies for that platform.</p>
<p>First, understand how to cross-compile a normal package from
Nixpkgs. Matthew Bauer's <a href="https://matthewbauer.us/blog/beginners-guide-to-cross.html">Beginners' guide to cross compilation in
Nixpkgs</a> is a useful resource.</p>
<p>Using an example from the guide, this builds GNU Hello for a Raspberry
Pi:</p>
<pre><code>nix build -f '&lt;nixpkgs&gt;' pkgsCross.raspberryPi.hello
</code></pre>
<p>We will use the same principle in <a href="https://github.com/input-output-hk/haskell.nix">Haskell.nix</a> — replacing the normal
package set <code>pkgs</code> with a cross-compiling package set
<code>pkgsCross.raspberryPi</code>.</p>
<h3 id="raspberry-pi-example"><a class="header" href="#raspberry-pi-example">Raspberry Pi example</a></h3>
<p>This is an example of using <a href="https://github.com/input-output-hk/haskell.nix">Haskell.nix</a> to build the <a href="https://hackage.haskell.org/package/bench">Bench</a>
command-line utility, which is a Haskell program.</p>
<pre><code class="language-nix">{ pkgs ? import &lt;nixpkgs&gt; {} }:
let
  haskellNix = import (builtins.fetchTarball https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz);
  native = haskellNix { inherit pkgs; };
in
  native.haskellPackages.bench.components.exes.bench
</code></pre>
<p>Now switch the package set as in the previous example:</p>
<pre><code class="language-nix">{ pkgs ? import &lt;nixpkgs&gt; {} }:
let
  haskellNix = import (builtins.fetchTarball https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz);
  raspberryPi = haskellNix { pkgs = pkgs.pkgsCross.raspberryPi; };
in
  raspberryPi.haskellPackages.bench.components.exes.bench
</code></pre>
<p>You should be prepared for a long wait because it first needs to build
GHC, before building all the Haskell dependencies of <a href="https://hackage.haskell.org/package/bench">Bench</a>. If all
of these dependencies compiled successfully, I would be very surprised!</p>
<blockquote>
<p><strong>Hint:</strong></p>
<p>The above example won't build, but you can try and see, if you like.
It will fail on <a href="http://hackage.haskell.org/package/clock-0.7.2">clock-0.7.2</a>,
which needs a patch to build.</p>
</blockquote>
<p>To fix the build problems, you must add extra configuration to the
package set. Your project will have a <a href="tutorials/../reference/library.html#mkstackpkgset"><code>mkStackPkgSet</code></a> or
<a href="tutorials/../reference/library.html#mkcabalprojectpkgset"><code>mkCabalProjectPkgSet</code></a>. It is there where you must add
<a href="tutorials/../reference/modules.html">module options</a> for setting compiler flags, adding patches, and so on.</p>
<blockquote>
<p><strong>Note:</strong></p>
<p>Note that <code>haskell.nix</code> will automatically use <code>qemu</code> to emulate the target
when necessary to run Template Haskell splices.</p>
</blockquote>
<h3 id="static-executables-with-musl-libc"><a class="header" href="#static-executables-with-musl-libc">Static executables with Musl libc</a></h3>
<p>Another application of cross-compiling is to produce fully static
binaries for Linux. For information about how to do that with the
<a href="https://nixos.org/nixpkgs/manual/#users-guide-to-the-haskell-infrastructure">Nixpkgs Haskell infrastructure</a> (not <a href="https://github.com/input-output-hk/haskell.nix">Haskell.nix</a>), see
<a href="https://github.com/nh2/static-haskell-nix">nh2/static‑haskell‑nix</a>. Vaibhav Sagar's linked
<a href="https://vaibhavsagar.com/blog/2018/01/03/static-haskell-nix/">blog post</a> is also very informative.</p>
<pre><code class="language-nix">{ pkgs ? import &lt;nixpkgs&gt; {} }:
let
  haskellNix = import (builtins.fetchTarball https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz);
  musl64 = haskellNix { pkgs = pkgs.pkgsCross.musl64; };
in
  musl64.haskellPackages.bench.components.exes.bench
</code></pre>
<p>This example will build <a href="https://hackage.haskell.org/package/bench">Bench</a> linked against Musl libc. However
the executable will still be dynamically linked. To get fully static
executables you must add package overrides to:</p>
<ol>
<li>Disable dynamic linking</li>
<li>Provide static versions of system libraries. (For more details, see
<a href="https://vaibhavsagar.com/blog/2018/01/03/static-haskell-nix/">Vaibhav's article</a>).</li>
</ol>
<pre><code class="language-nix">{
  packages.bench.components.exes.bench.configureFlags =
    lib.optionals stdenv.hostPlatform.isMusl [
      &quot;--disable-executable-dynamic&quot;
      &quot;--disable-shared&quot;
      &quot;--ghc-option=-optl=-pthread&quot;
      &quot;--ghc-option=-optl=-static&quot;
      &quot;--ghc-option=-optl=-L${gmp6.override { withStatic = true; }}/lib&quot;
      &quot;--ghc-option=-optl=-L${zlib.static}/lib&quot;
    ];
}
</code></pre>
<blockquote>
<p><strong>Note:</strong> Licensing</p>
<p>Note that if copyleft licensing your program is a problem for you,
then you need to statically link with <code>integer-simple</code> rather than
<code>integer-gmp</code>. However, at present, <a href="https://github.com/input-output-hk/haskell.nix">Haskell.nix</a> does not provide
an option for this.</p>
</blockquote>
<h3 id="how-to-cross-compile-your-project"><a class="header" href="#how-to-cross-compile-your-project">How to cross-compile your project</a></h3>
<p>Set up your project Haskell package set.</p>
<pre><code class="language-nix"># default.nix
{ pkgs ? import &lt;nixpkgs&gt; {}}:
let
  # Import the Haskell.nix library,
  haskell = import (builtins.fetchTarball &quot;https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz&quot;) {
    inherit pkgs;
  };

  # Instantiate a package set using the generated file.
  pkgSet = haskell.mkCabalProjectPkgSet {
    plan-pkgs = import ./pkgs.nix;
    pkg-def-extras = [];
    modules = [
      {
        # You will need to put build fixes here.
      }
    ];
  };
in
  pkgSet.config.hsPkgs
</code></pre>
<p>Apply that package set to the Nixpkgs cross package sets that you are
interested in.</p>
<p>We are going to expand the <code>pkgs.pkgsCross</code> shortcut to be more
explicit.</p>
<pre><code class="language-nix">let
  pkgs = import &lt;nixpkgs&gt; {}
in {
  shortcut = pkgs.pkgsCross.SYSTEM;
  actual = import &lt;nixpkgs&gt; { crossSystem = pkgs.lib.systems.examples.SYSTEM; };
}
</code></pre>
<p>In the above example, for any <code>SYSTEM</code>, <code>shortcut</code> and <code>actual</code> are
the same package set.</p>
<pre><code class="language-nix"># release.nix
let
  myProject = import ./default.nix;

  pkgsNative = import &lt;nixpkgs&gt; {};
  pkgsRaspberryPi = import &lt;nixpkgs&gt; {
    crossSystem = pkgsNative.lib.systems.examples.raspberryPi;
  };

  native = myProject { pkgs = pkgsNative; };
  crossRaspberryPi = myProject { pkgs = pkgsRaspberryPi; };

in {
  my-project-native = native.my-project.components.exes.my-project;
  my-project-raspberry-pi = crossRaspberryPi.my-project.components.exes.my-project;
}
</code></pre>
<p>Try to build it, and apply fixes to the <code>modules</code> list, until there
are no errors left.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="coverage"><a class="header" href="#coverage">Coverage</a></h1>
<p>haskell.nix can generate coverage information for your package or
project using Cabal's inbuilt hpc support.</p>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<p>To get a sensible coverage report, you need to enable coverage on each
of the packages of your project:</p>
<pre><code class="language-nix">pkgs.haskell-nix.project {
  src = pkgs.haskell-nix.haskellLib.cleanGit {
    name = &quot;haskell-nix-project&quot;;
    src = ./.;
  };
  compiler-nix-name = &quot;ghc884&quot;;

  modules = [{
    packages.$pkg.components.library.doCoverage = true;
  }];
}
</code></pre>
<p>If you would like to make coverage optional, add an argument to your nix expression:</p>
<pre><code class="language-nix">{ withCoverage ? false }:

pkgs.haskell-nix.project {
  src = pkgs.haskell-nix.haskellLib.cleanGit {
    name = &quot;haskell-nix-project&quot;;
    src = ./.;
  };
  compiler-nix-name = &quot;ghc884&quot;;

  modules = pkgs.lib.optional withCoverage [{
    packages.$pkg.components.library.doCoverage = true;
  }];
}
</code></pre>
<h2 id="per-package"><a class="header" href="#per-package">Per-package</a></h2>
<pre><code class="language-shell">nix-build default.nix -A &quot;projectWithCoverage.$pkg.coverageReport&quot;
</code></pre>
<p>This will generate a coverage report for the package you requested.
All tests that are enabled (configured with <code>doCheck == true</code>) are
included in the coverage report.</p>
<p>See the <a href="tutorials/../dev/coverage.html#package-reports">developer coverage docs</a> for more information.</p>
<h2 id="project-wide"><a class="header" href="#project-wide">Project-wide</a></h2>
<pre><code class="language-shell">nix-build default.nix -A &quot;projectWithCoverage.projectCoverageReport&quot;
</code></pre>
<p>This will generate a coverage report for all the local packages in
your project.</p>
<p>See the <a href="tutorials/../dev/coverage.html#project-wide-reports">developer coverage docs</a> for more information.</p>
<h2 id="custom"><a class="header" href="#custom">Custom</a></h2>
<p>By default, the behaviour of the <code>coverageReport</code> attribute is to
generate a coverage report that describes how that package affects the
coverage of all local packages (including itself) in the project.</p>
<p>The default behaviour of <code>projectCoverageReport</code> is to sum the
default coverage reports (produced by the above process) of all local
packages in the project.</p>
<p>You can modify this behaviour by using the <code>coverageReport</code> and
<code>projectCoverageReport</code> functions found in the haskell.nix library:</p>
<pre><code class="language-nix"># default.nix
{ pkgs ? import &lt;nixpkgs&gt; {}}:
let
  inherit (pkgs.haskell-nix) haskellLib;

  project = haskellLib.project {
    src = pkgs.haskell-nix.haskellLib.cleanGit {
      name = &quot;haskell-nix-project&quot;;
      src = ./.;
    };
    compiler-nix-name = &quot;ghc884&quot;;

    modules = [{
      packages.$pkgA.components.library.doCoverage = true;
      packages.$pkgB.components.library.doCoverage = true;
    }];
  };

  # Generate a coverage report for $pkgA that only includes the
  # unit-test check and only shows coverage information for $pkgA, not
  # $pkgB.
  custom$pkgACoverageReport = haskellLib.coverageReport rec {
    name = &quot;$pkgA-unit-tests-only&quot;
    inherit (project.$pkgA.components) library;
    checks = [project.$pkgA.components.checks.unit-test];
    # Note that this is the default value of the &quot;mixLibraries&quot;
    # argument and so this line isn't really necessary.
    mixLibraries = [project.$pkgA.components.library];
  };

  custom$pkgBCoverageReport = haskellLib.coverageReport rec {
    name = &quot;$pkgB-unit-tests-only&quot;
    inherit (project.$pkgB.components) library;
    checks = [project.$pkgB.components.checks.unit-test];
    mixLibraries = [project.$pkgB.components.library];
  };
 
  # Generate a project coverage report that only includes the unit
  # tests of the project, and only shows how each unit test effects
  # the coverage of it's package, and not other packages in the
  # project.
  allUnitTestsProjectReport = haskellLib.projectCoverageReport [custom$pkgACoverageReport custom$pkgBCoverageReport];
in {
  inherit project custom$pkgACoverageReport custom$pkgBCoverageReport allUnitTestsProjectCoverageReport;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="build-a-specific-package-from-hackage-or-stackage"><a class="header" href="#build-a-specific-package-from-hackage-or-stackage">Build a specific package from Hackage or Stackage</a></h1>
<h2 id="from-a-stackage-snapshot"><a class="header" href="#from-a-stackage-snapshot">From a <a href="https://stackage.org">Stackage</a> snapshot</a></h2>
<p>To build a package, say <a href="https://hackage.haskell.org/package/lens">lens</a>, from a Stackage snapshot, say
<a href="https://www.stackage.org/lts-13.28">lts-13.28</a>, you could run:</p>
<pre><code class="language-shell">nix build '(with import &lt;nixpkgs&gt; (import (builtins.fetchTarball &quot;https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz&quot;) {}).nixpkgsArgs; haskell-nix.snapshots.&quot;lts-13.28&quot;).lens.components.library'
</code></pre>
<p>This would build the (public) library component of the <a href="https://hackage.haskell.org/package/lens">lens</a> package as
fixed by the <a href="https://www.stackage.org/lts-13.28">lts-13.28</a> stackage snapshot. Nightly snapshots like
<code>nightly-2020-06-21</code> are also available.</p>
<h2 id="a-specific-version-from-hackage"><a class="header" href="#a-specific-version-from-hackage">A specific version from Hackage</a></h2>
<p>To build any package from hackage, say <a href="https://hackage.haskell.org/package/lens">lens</a>, at any version, say 4.17.1,
you could run:</p>
<pre><code class="language-shell">nix build '(with import &lt;nixpkgs&gt; (import (builtins.fetchTarball &quot;https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz&quot;) {}).nixpkgsArgs; (haskell-nix.hackage-package { name = &quot;lens&quot;; version = &quot;4.17.1&quot;; compiler-nix-name = &quot;ghc8102&quot;; })).components.library'
</code></pre>
<p>This would build the (public) library component of the <a href="https://hackage.haskell.org/package/lens-4.17.1">lens-4.17.1</a> package
from hackage.</p>
<h3 id="pinning-hackage-index"><a class="header" href="#pinning-hackage-index">Pinning hackage index</a></h3>
<p>The dependencies would be resolved against the most recent
<a href="https://github.com/input-output-hk/hackage.nix/blob/master/index-state-hashes.nix">hackage-index-state</a> which comes with your <a href="https://github.com/input-output-hk/haskell.nix">haskell.nix</a> checkout via the
<a href="https://github.com/input-output-hk/hackage.nix">hackage.nix</a> pin.  A specific one can be specified as well:</p>
<pre><code class="language-shell">nix build '(with import &lt;nixpkgs&gt; (import (builtins.fetchTarball &quot;https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz&quot;) {}).nixpkgsArgs; (haskell-nix.hackage-package { name = &quot;lens&quot;; version = &quot;4.17.1&quot;; compiler-nix-name = &quot;ghc8102&quot;; index-state = &quot;2019-07-14T00:00:00Z&quot;; })).components.library'
</code></pre>
<p>This would use the hackage index as of <code>2019-07-14T00:00:00Z</code> to produce a
build plan for the <a href="https://hackage.haskell.org/package/lens-4.17.1">lens-4.17.1</a> package.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="content-addressed-derivations"><a class="header" href="#content-addressed-derivations">Content addressed derivations</a></h1>
<h2 id="introduction"><a class="header" href="#introduction">Introduction</a></h2>
<p>Floating content addressed derivations (from now <em>CA derivations</em>) is an experimental feature which substantially change how the hashes in the store paths are calculated.
Indeed, normally derivations are input addressed i.e. the outputs store paths depends only on the derivation inputs, instead with CA derivations they depend on the content of the outputs.</p>
<p>This has two main advantages:</p>
<ul>
<li>The so-called &quot;early cutoff&quot;, namely the ability of Nix to stop a build if the build outputs would be something already built. 
For example suppose you add a comment in an Haskell source, at this point Nix will rebuild the component depending on this source but since the output will be the same (adding a comment is an &quot;output-invariant&quot; change for <code>ghc</code>) every other component that depends on that will not be rebuilt.</li>
<li>Users of the same Nix store does not need to trust each other when using substituters.</li>
</ul>
<p>You can find more information in the <a href="https://nixos.wiki/wiki/Ca-derivations">ca-derivations page on the wiki</a> (and in the other resources linked there).</p>
<h2 id="usage"><a class="header" href="#usage">Usage</a></h2>
<h3 id="enable-ca-derivations-in-your-system"><a class="header" href="#enable-ca-derivations-in-your-system">Enable CA derivations in your system</a></h3>
<p>First of all your Nix installation must support the <code>ca-derivations</code> experimental feature, this can done by adding the following in your <code>nix.conf</code>:</p>
<pre><code>experimental-features = ca-derivations
</code></pre>
<p>Or if you use NixOS:</p>
<pre><code class="language-nix">nix.extraOptions = ''
    experimental-features = ca-derivations
'';
</code></pre>
<h2 id="enable-ca-derivations-in-your-project"><a class="header" href="#enable-ca-derivations-in-your-project">Enable CA derivations in your project</a></h2>
<p>At this point you can pass a new module to <code>project'</code> that tells <code>haskell.nix</code> to build every component in the project as CA derivation.</p>
<pre><code class="language-nix">haskell-nix.project' {
	# ...
	
	modules = [{
		contentAddressed = true;
		# packages.project-name.components.exes.executable.contentAddressed = true;
	}];
};
</code></pre>
<p>Optionally you can also specify which components you don't want to be content addressed.</p>
<h2 id="known-problems"><a class="header" href="#known-problems">Known problems</a></h2>
<h3 id="limitation-of-the-current-ca-derivations-implementation"><a class="header" href="#limitation-of-the-current-ca-derivations-implementation">Limitation of the current CA derivations implementation</a></h3>
<p>As explained in the <a href="https://github.com/tweag/rfcs/blob/cas-rfc/rfcs/0062-content-addressed-paths.md">RFC 62</a></p>
<blockquote>
<p>The current implementation has a naive approach that just forbids fetching a path if the local system has a different realisation for the same drv output. This approach is simple and correct, but it's possible that it might not be good-enough in practice as it can result in a totally useless binary cache in some pathological cases.</p>
</blockquote>
<p>For example, suppose that your machine builds a derivation <code>A</code> producing an output <code>A.out</code> in your store and that after that a CI machine builds the same derivation <code>A</code> but producing a different output <code>A.out'</code> and populating a cache with this output.
At this point, if you need to build a derivation <code>B</code> that depends on <code>A</code>, since you already have the realisation <code>A.out</code> in your local store and you can't get <code>B.out</code> from the cache and you will end up building <code>B</code> even if one of its realisation is in the cache.</p>
<p>This means that, in some cases, enabling CA derivations would lead to more rebuilds than not having it.</p>
<h3 id="hydra"><a class="header" href="#hydra">Hydra</a></h3>
<p>Hydra currently doesn't support CA derivations, efforts are being made in this direction.</p>
<h3 id="ghc-is-not-deterministic"><a class="header" href="#ghc-is-not-deterministic">GHC is not deterministic</a></h3>
<p>Currently <code>ghc</code> is determinstic only disabling the parallel building i.e. passing <code>-j1</code>. <a href="https://gitlab.haskell.org/ghc/ghc/-/issues/12935">Here</a> the upstream issue.</p>
<p>Having a deterministic <code>ghc</code> would be a dream since it will automatically fix all the pathological cases about substituters discussed above and would allow <code>haskell.nix</code> to parallel build even when using CA derivations.</p>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="supported-ghc-versions"><a class="header" href="#supported-ghc-versions">Supported GHC Versions</a></h1>
<p>The following GHC versions are defined in <code>haskell.nix</code> (there is a derivation
for each, though not all are cached or tested by CI):</p>
<ul>
<li>8.4.4</li>
<li>8.6.{1,2,3,4,5}</li>
<li>8.8.{1,2,3,4}</li>
<li>8.10.{1,2,3,4,5}</li>
<li>9.0.1</li>
<li>9.2.1</li>
<li>9.2.2</li>
</ul>
<p>The following table shows the Nixpkgs/GHC versions which are built/cached, and
which of those are further tested.  If you use a combination of Nixpkgs version
and GHC version which is in this table, you should hit our cache, saving
considering time by not building GHC and a few additional tools.</p>
<p>Note that if you try to use <code>haskell.nix</code> as an overlay over Nixpkgs from a
standard Nixpkgs channel you will likely get a cache miss.  To hit our cache you
really should use an instance of Nixpkgs provided by <code>haskell.nix</code> itself.</p>
<div class="table-wrapper"><table><thead><tr><th>Nixpkgs version</th><th>Nixpkgs pinning</th><th>GHC version</th><th><code>compiler-nix-name</code></th><th>Tested in CI?</th></tr></thead><tbody>
<tr><td>22.05</td><td><code>nixpkgs-2205</code></td><td>8.6.5</td><td><code>ghc865</code></td><td>No</td></tr>
<tr><td>22.05</td><td><code>nixpkgs-2205</code></td><td>8.10.7</td><td><code>ghc8107</code></td><td>No</td></tr>
<tr><td>unstable</td><td><code>nixpkgs-unstable</code></td><td>8.6.5</td><td><code>ghc865</code></td><td>No</td></tr>
<tr><td>unstable</td><td><code>nixpkgs-unstable</code></td><td>8.8.4</td><td><code>ghc884</code></td><td>No</td></tr>
<tr><td>unstable</td><td><code>nixpkgs-unstable</code></td><td>8.10.7</td><td><code>ghc8107</code></td><td>Yes</td></tr>
<tr><td>unstable</td><td><code>nixpkgs-unstable</code></td><td>9.0.2</td><td><code>ghc902</code></td><td>No</td></tr>
<tr><td>unstable</td><td><code>nixpkgs-unstable</code></td><td>9.2.4</td><td><code>ghc924</code></td><td>Yes</td></tr>
</tbody></table>
</div>
<p>See <a href="https://github.com/input-output-hk/haskell.nix/blob/master/ci.nix">ci.nix</a>
for the source of truth about what is built and tested (in the off chance this
document is out-of-sync with your checkout).</p>
<p>See the <a href="reference/../tutorials/getting-started.html">getting started guide</a> for
instructions on how to set up Nix to take advantage of our cache when building.
This guide also covers where to use the Nixpkgs pinning and <code>compiler-nix-name</code>
settings from the table above.  For further information, see the <a href="reference/../dev/nixpkgs-pin.html">instructions
for how to pin Nixpkgs</a>.</p>
<p>See
<a href="https://github.com/input-output-hk/haskell.nix/blob/master/overlays/bootstrap.nix">overlays/bootstrap.nix</a>
for a full list of all the valid <code>compiler-nix-name</code>s beyond what's
cached/tested in CI.  You're free to use these, but be ready for longer build
times.</p>
<p>Lastly, see <a href="reference/../dev/adding-new-ghc.html">instructions on adding new GHC versions</a>
in the event that what's in <code>haskell.nix</code> doesn't suit your needs.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="command-line-tools"><a class="header" href="#command-line-tools">Command line tools</a></h1>
<p>To install the command line tools refer to the <a href="https://input-output-hk.github.io/haskell.nix/dev/manually-generating-nix-expressions/">Installing nix-tools</a> section.</p>
<h2 id="stack-to-nix"><a class="header" href="#stack-to-nix">stack-to-nix</a></h2>
<pre><code>stack-to-nix - a stack to nix converter

Usage: stack-to-nix (-o|--output DIR) [--stack-yaml FILE]
                    [--ignore-package-yaml] [--cache FILE]
  Generate a Nix expression for a Haskell package using Stack

Available options:
  -o,--output DIR          Generate output in DIR
  --stack-yaml FILE        Override project stack.yaml (default: &quot;stack.yaml&quot;)
  --ignore-package-yaml    disable hpack run and use only cabal disregarding
                           package.yaml existence
  --cache FILE             Dependency cache
                           file (default: &quot;.stack-to-nix.cache&quot;)
  -h,--help                Show this help text
</code></pre>
<p>Use this for stack projects. If a <code>default.nix</code> does not exist in the
output directory, it will create a basic one with a
<a href="reference/../manually-generating-nix-expressions#Using-Stack"><code>mkStackPkgSet</code></a> function.</p>
<blockquote>
<p><strong>Note:</strong></p>
<p>If you find that there are missing files which should have been
generated, remove <code>.stack-to-nix.cache</code>
(The open issue is <a href="https://github.com/input-output-hk/haskell.nix/issues/57">#57</a>).</p>
</blockquote>
<h2 id="plan-to-nix"><a class="header" href="#plan-to-nix">plan-to-nix</a></h2>
<pre><code>plan-to-nix - a stack to nix converter

Usage: plan-to-nix (-o|--output DIR) [--plan-json FILE] [--cabal-project FILE]
                   [--cache FILE]
  Generate a Nix expression for a Haskell package using Cabal

Available options:
  -o,--output DIR          Generate output in DIR
  --plan-json FILE         Override plan.json
                           location (default: &quot;dist-newstyle/cache/plan.json&quot;)
  --cabal-project FILE     Override path to
                           cabal.project (default: &quot;cabal.project&quot;)
  --cache FILE             Dependency cache file (default: &quot;.nix-tools.cache&quot;)
  -h,--help                Show this help text
</code></pre>
<p>Use this for Cabal new-build projects (even if you don't have a
<code>cabal.project</code>). Before running, you need to create a plan. For more
information, see <a href="reference/../manually-generating-nix-expressions#Using-Cabal">Cabal Projects</a> in the user
guide.</p>
<p>It will create a template <code>default.nix</code> in the output directory,
unless that file already exists.</p>
<p>Inside the output directory, there will be another directory
<code>.plan.nix</code>, which contains Nix expressions for all local packages,
generated by <code>cabal-to-nix</code>. The output file <code>pkgs.nix</code> refers to
these files.</p>
<blockquote>
<p><strong>Note:</strong></p>
<p>If you find that there are missing files which should have been
generated, remove <code>.nix-tools.cache</code>
(The open issue is <a href="https://github.com/input-output-hk/haskell.nix/issues/57">#57</a>).</p>
</blockquote>
<h2 id="cabal-to-nix"><a class="header" href="#cabal-to-nix">cabal-to-nix</a></h2>
<pre><code>Usage: cabal-to-nix FILE.cabal
</code></pre>
<p>This writes (to stdout) a <a href="https://github.com/input-output-hk/haskell.nix">Haskell.nix</a> Nix expression for the given
cabal package.</p>
<p>Normally, you do not need to run <code>cabal-to-nix</code> yourself. It is called
by <code>stack-to-nix</code> and <code>plan-to-nix</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><p><a href="https://github.com/input-output-hk/haskell.nix">Haskell.nix</a> contains a library of functions for creating buildable
package sets from their Nix expression descriptions. The library is
what you get when importing <a href="https://github.com/input-output-hk/haskell.nix">Haskell.nix</a>. It might be helpful to
load the library in the <a href="reference/../tutorials/development.html#using-nix-repl">Nix REPL</a> to
test things.</p>
<ul>
<li><a href="reference/library.html#data-structures">Data structures</a> — the kinds of data that you will encounter working with <a href="https://github.com/input-output-hk/haskell.nix">Haskell.nix</a>.</li>
<li><a href="reference/library.html#top-level-attributes">Top-level attributes</a> — Functions and derivations defined in the Haskell.nix attrset.</li>
<li><a href="reference/library.html#package-set-functions">Package-set functions</a> — Helper functions defined on the <code>hsPkgs</code> package set.</li>
</ul>
<h1 id="data-structures"><a class="header" href="#data-structures">Data structures</a></h1>
<h2 id="package-set"><a class="header" href="#package-set">Package Set</a></h2>
<p>The result of <code>mkPkgSet</code>. This is an application of the NixOS module
system.</p>
<pre><code class="language-nix">{
  options = { ... };
  config = {
    hsPkgs = { ... };
    packages = { ... };
    compiler = {
      version = &quot;X.Y.Z&quot;;
      nix-name = &quot;ghcXYZ&quot;;
      packages = { ... };
    };
  };
}
</code></pre>
<div class="table-wrapper"><table><thead><tr><th>Attribute</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>options</code></td><td>Module options</td><td>The combination of all options set through the <code>modules</code> argument passed to <code>mkPkgsSet</code>.</td></tr>
<tr><td><code>config</code></td><td></td><td>The result of evaluating and applying the <code>options</code> with <a href="https://github.com/input-output-hk/haskell.nix">Haskell.nix</a></td></tr>
<tr><td><code>.hsPkgs</code></td><td>Attrset of <a href="reference/library.html#haskell-package">Haskell Packages</a></td><td>Buildable packages, created from <code>packages</code></td></tr>
<tr><td><code>.packages</code></td><td>Attrset of <a href="reference/library.html#haskell-package-descriptions">Haskell Package descriptions</a></td><td>Configuration for each package in <code>hsPkgs</code></td></tr>
<tr><td><code>.compiler</code></td><td>Attrset</td><td></td></tr>
</tbody></table>
</div>
<h2 id="haskell-package-description"><a class="header" href="#haskell-package-description">Haskell Package description</a></h2>
<p>The <em>Haskell package descriptions</em> are values of the
<code>pkgSet.config.packages</code> attrset. These are not derivations, but just
the configuration for building an individual package. The
configuration options are described under <code>packages.&lt;name&gt;</code> in <a href="reference/./modules.html">Module
options</a>.</p>
<h2 id="component-description"><a class="header" href="#component-description">Component description</a></h2>
<p>The <em>component descriptions</em> are values of the
<code>pkgSet.config.packages.&lt;package&gt;.components</code> attrset. These are not
derivations, but just the configuration for building an individual
component. The configuration options are described under
<code>packages.&lt;name&gt;.components.*</code> in <a href="reference/./modules.html">Module options</a>.</p>
<h2 id="haskell-package"><a class="header" href="#haskell-package">Haskell Package</a></h2>
<p>In <a href="https://github.com/input-output-hk/haskell.nix">Haskell.nix</a>, a <em>Haskell package</em> is a derivation which has a
<code>components</code> attribute. This derivation is actually just for the
package <code>Setup.hs</code> script, and isn't very interesting. To actually use
the package, look within the components structure.</p>
<pre><code class="language-nix">components = {
  library = COMPONENT;
  exes = { NAME = COMPONENT; };
  tests = { NAME = COMPONENT; };
  benchmarks = { NAME = COMPONENT; };
}
</code></pre>
<h2 id="component"><a class="header" href="#component">Component</a></h2>
<p>In <a href="https://github.com/input-output-hk/haskell.nix">Haskell.nix</a>, a <em>component</em> is a derivation corresponding to a
<a href="https://www.haskell.org/cabal/users-guide/developing-packages.html">Cabal component</a>
of a package.</p>
<h2 id="identifier"><a class="header" href="#identifier">Identifier</a></h2>
<p>A package identifier is an attrset pair of <code>name</code> and <code>version</code>.</p>
<h2 id="extras"><a class="header" href="#extras">Extras</a></h2>
<p>Extras allow adding more packages to the package set. These will be
functions taking a single parameter <code>hackage</code>. They should return an
attrset of package descriptions.</p>
<h2 id="modules"><a class="header" href="#modules">Modules</a></h2>
<p>Modules are the primary method of configuring building of the package
set. They are either:</p>
<ol>
<li>an attrset containing <a href="reference/./modules.html">option declarations</a>, or</li>
<li>a function that returns an attrset containing option declarations.</li>
</ol>
<p>If using the function form of a module, the following named parameters
will be passed to it:</p>
<div class="table-wrapper"><table><thead><tr><th>Argument</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>haskellLib</code></td><td>attrset</td><td>The <a href="reference/library.html#haskelllib">haskellLib</a> utility functions.</td></tr>
<tr><td><code>pkgs</code></td><td></td><td>The Nixpkgs collection.</td></tr>
<tr><td><code>pkgconfPkgs</code></td><td></td><td>A mapping of cabal build-depends names to Nixpkgs packages. (TODO: more information about this)</td></tr>
<tr><td><code>buildModules</code></td><td></td><td></td></tr>
<tr><td><code>config</code></td><td></td><td></td></tr>
<tr><td><code>options</code></td><td></td><td></td></tr>
</tbody></table>
</div>
<h1 id="top-level-attributes"><a class="header" href="#top-level-attributes">Top-level attributes</a></h1>
<h2 id="project"><a class="header" href="#project">project'</a></h2>
<p>Function that accepts attribute set with a <code>src</code> attribute and looks for <code>stack.yaml</code> file relative to it.</p>
<p>If file exists, it calls <a href="reference/library.html#stackproject&#x27;">stackProject</a> function. Otherwise it will call <a href="reference/library.html#cabalproject&#x27;">cabalProject</a> function.</p>
<p><strong>Example</strong>:</p>
<pre><code class="language-nix">pkgs.haskell-nix.project' {
  # 'cleanGit' cleans a source directory based on the files known by git
  src = pkgs.haskell-nix.haskellLib.cleanGit {
    name = &quot;haskell-nix-project&quot;;
    src = ./.;
  };
}
</code></pre>
<h2 id="stackproject"><a class="header" href="#stackproject">stackProject'</a></h2>
<p>A function calling <a href="reference/library.html#callstacktonix">callStackToNix</a> with all arguments.</p>
<p>Then feeding its result into <a href="reference/library.html#mkstackpkgset">mkStackPkgSet</a> passing also
<code>pkg-def-extras</code> and <code>modules</code> arguments.</p>
<p><strong>Return value</strong>:</p>
<div class="table-wrapper"><table><thead><tr><th>Attribute</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>hsPkgs</code></td><td>Attrset of <a href="reference/library.html#haskell-package">Haskell Packages</a></td><td>Buildable packages, created from <code>packages</code></td></tr>
<tr><td><code>stack-nix</code></td><td></td><td><code>projectNix</code> attribute of <a href="reference/library.html#callstacktonix"><code>callStackToNix</code></a> return value</td></tr>
<tr><td><code>shellFor</code></td><td>Function</td><td><a href="reference/library.html#shellfor"><code>shellFor</code></a></td></tr>
<tr><td><code>ghcWithHoogle</code></td><td>Function</td><td><a href="reference/library.html#ghcwithhoogle"><code>ghcWithHoogle</code></a></td></tr>
<tr><td><code>ghcWithPackages</code></td><td>Function</td><td><a href="reference/library.html#ghcwithpackages"><code>ghcWithPackages</code></a></td></tr>
</tbody></table>
</div>
<h2 id="cabalproject-1"><a class="header" href="#cabalproject-1">cabalProject'</a></h2>
<p>A function calling <a href="reference/library.html#callcabalprojecttonix">callCabalProjectToNix</a> with all arguments.</p>
<p>Then feeding its result into <a href="reference/library.html#mkcabalprojectpkgset">mkCabalProjectPkgSet</a> passing also
<code>pkg-def-extras</code>, <code>extra-hackages</code> and <code>modules</code> arguments.</p>
<p><strong>Return value</strong>:</p>
<div class="table-wrapper"><table><thead><tr><th>Attribute</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>hsPkgs</code></td><td>Attrset of <a href="reference/library.html#haskell-package">Haskell Packages</a></td><td>Buildable packages, created from <code>packages</code></td></tr>
<tr><td><code>plan-nix</code></td><td></td><td><code>projectNix</code> attribute of <a href="reference/library.html#callcabalprojecttonix"><code>callCabalProjectToNix</code></a> return value</td></tr>
<tr><td><code>index-state</code></td><td></td><td><code>index-state</code> attribute of <a href="reference/library.html#callcabalprojecttonix"><code>callCabalProjectToNix</code></a> return value</td></tr>
<tr><td><code>shellFor</code></td><td>Function</td><td><a href="reference/library.html#shellfor"><code>shellFor</code></a></td></tr>
<tr><td><code>ghcWithHoogle</code></td><td>Function</td><td><a href="reference/library.html#ghcwithhoogle"><code>ghcWithHoogle</code></a></td></tr>
<tr><td><code>ghcWithPackages</code></td><td>Function</td><td><a href="reference/library.html#ghcwithpackages"><code>ghcWithPackages</code></a></td></tr>
<tr><td><code>projectCross</code></td><td>Attrset</td><td>Like <code>pkgs.pkgsCross.&lt;system&gt;</code> from nixpkgs <code>p.projectCross.&lt;system&gt;</code> returns the project results for cross compilation (where system is a member of nixpkgs lib.systems.examples).  So <code>p.projectCross.ghcjs.hsPkgs</code> is the same as <code>hsPkgs</code> but compiled with ghcjs</td></tr>
<tr><td><code>projectVariants</code></td><td>Attrset</td><td>Attribute set of variant for the project, mapped from <code>flake.variants</code> config values</td></tr>
<tr><td><code>appendModule</code></td><td>Function</td><td>Re-eval the project with an extra module (or module list).</td></tr>
<tr><td><code>extend</code> and <code>appendOverlays</code></td><td>Function</td><td>Modify a project, or add attributes, through overlays: <code>p.extend(final: prev: { })</code>. The overlays are carried-over <code>projectCross</code> and <code>appendModule</code> invocations.</td></tr>
</tbody></table>
</div>
<h2 id="project-cabalproject-and-stackproject"><a class="header" href="#project-cabalproject-and-stackproject">project, cabalProject and stackProject</a></h2>
<p>These versions of the function are the same as project', cabalProject'
and stackProject', but <code>hsPkgs</code> attributes are also included in the
return value directly.  That way a package can be referenced as
<code>(project {...}).foo</code> instead of <code>(project' {...}).hsPkgs.foo</code>.</p>
<h2 id="mkstackpkgset"><a class="header" href="#mkstackpkgset">mkStackPkgSet</a></h2>
<p>Creates a <a href="reference/library.html#package-set">package set</a> based on the <code>pkgs.nix</code> output
of <code>stack-to-nix</code>.</p>
<pre><code class="language-nix">mkStackPkgSet =
    { stack-pkgs, pkg-def-extras ? [], modules ? []}: ...
</code></pre>
<div class="table-wrapper"><table><thead><tr><th>Argument</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>stack-pkgs</code></td><td></td><td><code>import ./pkgs.nix</code> — The imported file generated by <code>stack‑to‑nix</code>.</td></tr>
<tr><td><code>pkg‑def‑extras</code></td><td>List of <a href="reference/library.html#extras">Extras</a></td><td>For overriding the package set.</td></tr>
<tr><td><code>modules</code></td><td>List of <a href="reference/library.html#modules">Modules</a></td><td>For overriding the package set.</td></tr>
</tbody></table>
</div>
<p><strong>Return value</strong>: a <a href="reference/library.html#package-set"><code>pkgSet</code></a></p>
<h2 id="mkcabalprojectpkgset"><a class="header" href="#mkcabalprojectpkgset">mkCabalProjectPkgSet</a></h2>
<p>Creates a <a href="reference/library.html#package-set">package set</a> based on the <code>pkgs.nix</code> output
of <code>plan-to-nix</code>.</p>
<pre><code class="language-nix">mkCabalProjectPkgSet =
    { plan-pkgs, pkg-def-extras ? [], modules ? []}: ...
</code></pre>
<div class="table-wrapper"><table><thead><tr><th>Argument</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>plan-pkgs</code></td><td></td><td><code>import ./pkgs.nix</code> — The imported file generated by <code>plan‑to‑nix</code>.</td></tr>
<tr><td><code>pkg‑def‑extras</code></td><td>List of <a href="reference/library.html#extras">Extras</a></td><td>For overriding the package set.</td></tr>
<tr><td><code>modules</code></td><td>List of <a href="reference/library.html#modules">Modules</a></td><td>For overriding the package set.</td></tr>
</tbody></table>
</div>
<p><strong>Return value</strong>: a <a href="reference/library.html#package-set"><code>pkgSet</code></a></p>
<h2 id="mkpkgset"><a class="header" href="#mkpkgset">mkPkgSet</a></h2>
<p>This is the base function used by both <code>mkStackPkgSet</code> and
<code>mkCabalProjectPkgSet</code>.</p>
<p><strong>Return value</strong>: a <a href="reference/library.html#package-set"><code>pkgSet</code></a></p>
<h2 id="snapshots"><a class="header" href="#snapshots">snapshots</a></h2>
<p>This is an attrset of <code>hsPkgs</code> packages from Stackage.</p>
<h2 id="haskellpackages"><a class="header" href="#haskellpackages">haskellPackages</a></h2>
<p>A <code>hsPkgs</code> package set, which is one of the recent LTS Haskell
releases from <a href="reference/library.html#snapshots"><code>snapshots</code></a>.</p>
<p>The chosen LTS is updated occasionally in <a href="https://github.com/input-output-hk/haskell.nix">Haskell.nix</a>, though a
manual process.</p>
<h2 id="nix-tools-1"><a class="header" href="#nix-tools-1">nix-tools</a></h2>
<p>A derivation containing the <code>nix-tools</code> <a href="reference/commands.html">command-line tools</a>.</p>
<h2 id="callstacktonix"><a class="header" href="#callstacktonix">callStackToNix</a></h2>
<p>Runs <code>stack-to-nix</code> and produces the output needed for
<code>importAndFilterProject</code>.</p>
<p><strong>Example</strong>:</p>
<pre><code class="language-nix">  pkgSet = mkStackPkgSet {
    stack-pkgs = (importAndFilterProject (callStackToNix {
      src = ./.;
    })).pkgs;
    pkg-def-extras = [];
    modules = [];
  };
</code></pre>
<h2 id="callcabalprojecttonix"><a class="header" href="#callcabalprojecttonix">callCabalProjectToNix</a></h2>
<p>Runs <code>cabal new-configure</code> and <code>plan-to-nix</code> and produces the output
needed for <code>importAndFilterProject</code>.</p>
<p><strong>Example</strong>:</p>
<pre><code class="language-nix">  pkgSet = mkCabalProjectPkgSet {
    plan-pkgs = (importAndFilterProject (callCabalProjectToNix {
      index-state = &quot;2019-04-30T00:00:00Z&quot;;
      src = ./.;
    })).pkgs;
</code></pre>
<div class="table-wrapper"><table><thead><tr><th>Argument</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>name</code></td><td>String</td><td>Optional name for better error messages.</td></tr>
<tr><td><code>src</code></td><td>Path</td><td>Location of the cabal project files.</td></tr>
<tr><td><code>compiler-nix-name</code></td><td>String</td><td>The name of the ghc compiler to use eg. &quot;ghc884&quot;</td></tr>
<tr><td><code>index-state</code></td><td>Timestamp</td><td>Optional hackage index-state, eg. &quot;2019-10-10T00:00:00Z&quot;.</td></tr>
<tr><td><code>index-sha256</code></td><td>Sha256</td><td>Optional hash of the truncated hackage index-state.</td></tr>
<tr><td><code>plan-sha256</code></td><td>Sha256</td><td>Optional hash of the plan-to-nix output (makes the plan-to-nix step a fixed output derivation).</td></tr>
<tr><td><code>cabalProject</code></td><td>String</td><td>Optional cabal project file contents (defaults to readFile &quot;${src}/cabal.project&quot;).</td></tr>
<tr><td><code>cabalProjectLocal</code></td><td>String</td><td>Optional cabal project file contents (defaults to readFile &quot;${src}/cabal.project.local&quot;).</td></tr>
<tr><td><code>cabalProjectFreeze</code></td><td>String</td><td>Optional cabal project file contents (defaults to readFile &quot;${src}/cabal.project.freeze&quot;).</td></tr>
<tr><td><code>ghc</code></td><td></td><td>Deprecated. Use <code>compiler-nix-name</code> instead. Optional ghc to use</td></tr>
<tr><td><code>nix-tools</code></td><td></td><td>Optional nix-tools to use</td></tr>
<tr><td><code>hpack</code></td><td></td><td>Optional hpack to use</td></tr>
<tr><td><code>cabal-install</code></td><td></td><td>Optional cabal-install to use</td></tr>
<tr><td><code>configureArgs</code></td><td>String</td><td>Optional extra arguments to pass to <code>cabal new-configure</code> (--enable-tests is included by default, include <code>--disable-tests</code> to override that).</td></tr>
</tbody></table>
</div>
<h2 id="importandfilterproject"><a class="header" href="#importandfilterproject">importAndFilterProject</a></h2>
<p>Imports from a derivation created by <code>callStackToNix</code>
or <code>callCabalProjectToNix</code>.</p>
<p>The result is an attrset with the following values:</p>
<div class="table-wrapper"><table><thead><tr><th>Attribute</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>pkgs</code></td><td>attrset</td><td>that can be passed to <code>mkStackPkgSet</code> (as <code>stack-pkgs</code>) or <code>mkCabalProjectPkgSet</code> (as <code>plan-pkgs</code>).</td></tr>
<tr><td><code>nix</code></td><td></td><td>this can be built and cached so that the amount built in the evaluation phase is not too great (helps to avoid timeouts on Hydra).</td></tr>
</tbody></table>
</div>
<h2 id="hackage"><a class="header" href="#hackage">hackage</a></h2>
<h2 id="stackage"><a class="header" href="#stackage">stackage</a></h2>
<h2 id="fetchexternal"><a class="header" href="#fetchexternal">fetchExternal</a></h2>
<h2 id="cleansourcehaskell"><a class="header" href="#cleansourcehaskell">cleanSourceHaskell</a></h2>
<pre><code class="language-nix">cleanSourceHaskell = { src, name ? null }: ...
</code></pre>
<p>Filters a source tree removing common filenames that are not Haskell
build sources.</p>
<p>This can avoid unecessary rebuilds when these files change.</p>
<p>It's recommended to provide <code>name</code> so that the source derivation
remains constant regardless of how it was fetched.</p>
<p>Example:</p>
<pre><code class="language-nix">src = pkgs.haskell-nix.cleanSourceHaskell {
  src = ./.;
  name = &quot;myproject-src&quot;;
};
</code></pre>
<h2 id="haskellsourcefilter"><a class="header" href="#haskellsourcefilter">haskellSourceFilter</a></h2>
<pre><code class="language-nix">haskellSourceFilter = name: type: ...
</code></pre>
<p>This is a source filter function which cleans common build products
and files not needed to do a Haskell build from a source directory.</p>
<p>It should be used with <code>pkgs.lib.cleanSourceWith</code>. Alternatively,
use the convenience function <a href="reference/library.html#cleansourcehaskell"><code>cleanSourceHaskell</code></a>.</p>
<h2 id="haskelllib"><a class="header" href="#haskelllib">haskellLib</a></h2>
<p>Assorted functions for operating on <a href="https://github.com/input-output-hk/haskell.nix">Haskell.nix</a> data. This is
distinct from <code>pkgs.haskell.lib</code> in the current Nixpkgs Haskell
Infrastructure.</p>
<h3 id="collectcomponents-collectcomponents"><a class="header" href="#collectcomponents-collectcomponents">collectComponents, collectComponents'</a></h3>
<p>Extracts a selection of components from a Haskell <a href="reference/library.html#package-set">package set</a>.</p>
<p>This can be used to filter out all test suites or benchmarks of
your project, so that they can be built in Hydra (see check if you
want to run the tests as well as build them).</p>
<p><code>collectComponents'</code> is an alias of <code>collectComponents</code> without
predicate for filtering.</p>
<pre><code class="language-nix">collectComponents =
    group: packageSel: haskellPackages: ...
collectComponents' = group: collectComponents (_: true)
</code></pre>
<div class="table-wrapper"><table><thead><tr><th>Argument</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>group</code></td><td>String</td><td>A <a href="reference/library.html#subComponentTypes">sub-component type</a>.</td></tr>
<tr><td><code>packageSel</code></td><td>A function <code>Package -&gt; Bool</code></td><td>A predicate to filter packages with.</td></tr>
<tr><td><code>haskellPackages</code></td><td><a href="reference/library.html#package-set">Package set</a></td><td>All packages in the build.</td></tr>
</tbody></table>
</div>
<p><strong>Return value</strong>: a recursive attrset mapping package names → component names → components.</p>
<p><strong>Example</strong>:</p>
<pre><code class="language-nix">tests = collectComponents &quot;tests&quot; (package: package.identifier.name == &quot;mypackage&quot;) hsPkgs;
</code></pre>
<p>Will result in moving derivations from <code>hsPkgs.mypackage.components.tests.unit-tests</code>
to <code>tests.mypackage.unit-tests</code>.</p>
<h3 id="collectchecks-collectchecks"><a class="header" href="#collectchecks-collectchecks">collectChecks, collectChecks'</a></h3>
<p>These are just like <code>collectComponents</code> and <code>collectComponents'</code>, except that they collect
the <code>checks</code> attributes of packages (which aren't components, and so can't be collected
by the other functions.</p>
<h4 id="check"><a class="header" href="#check">check</a></h4>
<p>This function turns a derivation that builds a test into one to run it.</p>
<div class="table-wrapper"><table><thead><tr><th>Argument</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>drv</code></td><td>Derivation</td><td>One of <code>$pkg.components.tests.$test</code>.</td></tr>
</tbody></table>
</div>
<p>For convenience <code>$pkg.components.tests</code> are mapped with this function
to <code>$pkg.checks</code>.</p>
<p>This function is intended for use with <code>tests</code> but it should also work
for <code>exes</code> and <code>benchmarks</code> if you just want to run them to make sure
they execute.</p>
<h4 id="subcomponenttypes"><a class="header" href="#subcomponenttypes">subComponentTypes</a></h4>
<p>Sub-component types identify <a href="reference/library.html#component">components</a> and are one of:</p>
<ul>
<li><code>sublibs</code></li>
<li><code>foreignlibs</code></li>
<li><code>exes</code></li>
<li><code>tests</code></li>
<li><code>benchmarks</code></li>
</ul>
<h1 id="project-functions"><a class="header" href="#project-functions">Project functions</a></h1>
<p>These functions are included in the <code>project</code> return values.
In the past they also existed within <code>project.hsPkgs</code>,
but have now been removed from there.</p>
<h2 id="shellfor"><a class="header" href="#shellfor">shellFor</a></h2>
<p>Create a <code>nix-shell</code> <a href="reference/../tutorials/development.html">development
environment</a> for developing one or more
packages with <code>ghci</code> or <code>cabal v2-build</code> (but not Stack).</p>
<pre><code class="language-nix">shellFor =
    { packages, withHoogle ? true, exactDeps ? false, ...}: ...
</code></pre>
<div class="table-wrapper"><table><thead><tr><th>Argument</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>packages</code></td><td>Function</td><td>Package selection function. It takes a list of <a href="reference/library.html#haskell-package">Haskell packages</a> and returns a subset of these packages.</td></tr>
<tr><td><code>components</code></td><td>Function</td><td>Similar to <code>packages</code>, by default all the components of the selected packages are selected.</td></tr>
<tr><td><code>additional</code></td><td>Function</td><td>Similar to <code>packages</code>, but the selected packages are built and included in <code>ghc-pkg list</code> (not just their dependencies).</td></tr>
<tr><td><code>withHoogle</code></td><td>Boolean</td><td>Whether to build a Hoogle documentation index and provide the <code>hoogle</code> command.</td></tr>
<tr><td><code>exactDeps</code></td><td>Boolean</td><td>Prevents the Cabal solver from choosing any package dependency other than what are in the package set.</td></tr>
<tr><td><code>tools</code></td><td>Function</td><td>AttrSet of tools to make available e.g. <code>{ cabal = &quot;3.2.0.0&quot;; }</code> or <code>{ cabal = { version = &quot;3.2.0.0&quot;; }; }</code>. If an AttrSet is provided for a tool, the additional arguments will be passed to the function creating the derivation for that tool. So you can provide an <code>index-state</code> or a <code>materialized</code> argument like that <code>{ cabal = { version = &quot;3.2.0.0&quot;; index-state = &quot;2020-10-30T00:00:00Z&quot;; materialized = ./cabal.materialized; }; }</code> for example. You can specify and materialize the version of hoogle used to construct the hoogle index by including something like <code>{ hoogle = { version = &quot;5.0.17.15&quot;; index-state = &quot;2020-05-31T00:00:00Z&quot;; materialized = ./hoogle.materialized; }</code>. Uses a default version of hoogle if omitted.</td></tr>
<tr><td><code>inputsFrom</code></td><td>List</td><td>List of other shells to include in this one.  The <code>buildInputs</code> and <code>nativeBuildInputs</code> of each will be included using <a href="https://nixos.org/manual/nixpkgs/stable/#sec-pkgs-mkShell">mkShell</a>.</td></tr>
<tr><td><code>crossPlatforms</code></td><td>Function</td><td>Platform selection function for cross compilation targets to support eg. <code>ps: with ps; [ghcjs mingwW64]</code> (see nixpkgs lib.systems.examples for list of platform names).</td></tr>
<tr><td><code>{ ... }</code></td><td>Attrset</td><td>All the other arguments are passed to <a href="https://nixos.org/nixpkgs/manual/#sec-using-stdenv"><code>mkDerivation</code></a>.</td></tr>
</tbody></table>
</div>
<p><strong>Return value</strong>: a derivation</p>
<blockquote>
<p>⚠️ <strong>Warning:</strong></p>
<p><code>exactDeps = true</code> will set the <code>CABAL_CONFIG</code> environment variable
to disable remote package servers. This is a
<a href="reference/../dev/removing-with-package-wrapper.html">known limitation</a>
which we would like to solve. Use <code>exactDeps = false</code> if this is a
problem.</p>
</blockquote>
<h2 id="ghcwithpackages"><a class="header" href="#ghcwithpackages">ghcWithPackages</a></h2>
<p>Creates a <code>nix-shell</code> <a href="reference/../tutorials/development.html">development
environment</a> including the given
packages selected from this package set.</p>
<p><strong>Parameter</strong>: a package selection function.</p>
<p><strong>Return value</strong>: a derivation</p>
<p><strong>Example</strong>:</p>
<pre><code class="language-nix">haskell.haskellPackages.ghcWithPackages (ps: with ps; [ lens conduit ])
</code></pre>
<h2 id="ghcwithhoogle"><a class="header" href="#ghcwithhoogle">ghcWithHoogle</a></h2>
<p>The same as <code>ghcWithPackages</code>, except, a <code>hoogle</code> command with a
Hoogle documentation index of the packages will be included in the
shell.</p>
<div style="break-before: page; page-break-before: always;"></div><p>Haskell.nix modules options for packages and components.</p>
<p>!!! note &quot;Generated&quot;
This documentation is generated from Nix sources in the
<a href="https://github.com/input-output-hk/haskell.nix/tree/master/modules"><code>modules</code></a>
subdirectory using <code>scripts/update-docs.nix</code></p>
<h1 id="configuration-options"><a class="header" href="#configuration-options">Configuration Options</a></h1>
<h2 id="_moduleargs"><a class="header" href="#_moduleargs">_module.args</a></h2>
<p>Additional arguments passed to each module in addition to ones
like <code>lib</code>, <code>config</code>,
and <code>pkgs</code>, <code>modulesPath</code>.</p>
<p>This option is also available to all submodules. Submodules do not
inherit args from their parent module, nor do they provide args to
their parent module or sibling submodules. The sole exception to
this is the argument <code>name</code> which is provided by
parent modules to a submodule and contains the attribute name
the submodule is bound to, or a unique generated name if it is
not bound to an attribute.</p>
<p>Some arguments are already passed by default, of which the
following <em>cannot</em> be changed with this option:</p>
<ul>
<li>
<p>{var}<code>lib</code>: The nixpkgs library.</p>
</li>
<li>
<p>{var}<code>config</code>: The results of all options after merging the values from all modules together.</p>
</li>
<li>
<p>{var}<code>options</code>: The options declared in all modules.</p>
</li>
<li>
<p>{var}<code>specialArgs</code>: The <code>specialArgs</code> argument passed to <code>evalModules</code>.</p>
</li>
<li>
<p>All attributes of {var}<code>specialArgs</code></p>
<p>Whereas option values can generally depend on other option values
thanks to laziness, this does not apply to <code>imports</code>, which
must be computed statically before anything else.</p>
<p>For this reason, callers of the module system can provide <code>specialArgs</code>
which are available during import resolution.</p>
<p>For NixOS, <code>specialArgs</code> includes
{var}<code>modulesPath</code>, which allows you to import
extra modules from the nixpkgs package tree without having to
somehow make the module aware of the location of the
<code>nixpkgs</code> or NixOS directories.</p>
<pre><code>{ modulesPath, ... }: {
  imports = [
    (modulesPath + &quot;/profiles/minimal.nix&quot;)
  ];
}
</code></pre>
</li>
</ul>
<p>For NixOS, the default value for this option includes at least this argument:</p>
<ul>
<li>{var}<code>pkgs</code>: The nixpkgs package set according to
the {option}<code>nixpkgs.pkgs</code> option.</li>
</ul>
<p><strong>Type</strong>: lazy attribute set of raw value</p>
<p><strong>No Default</strong></p>
<p><strong>No Example</strong></p>
<h2 id="bootpkgs"><a class="header" href="#bootpkgs">bootPkgs</a></h2>
<p><strong>Type</strong>: list of string</p>
<p><strong>No Default</strong></p>
<p><strong>No Example</strong></p>
<h2 id="buildable"><a class="header" href="#buildable">buildable</a></h2>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: true</p>
<p><strong>No Example</strong></p>
<h2 id="cabalcompiler"><a class="header" href="#cabalcompiler">cabal.compiler</a></h2>
<p><strong>Type</strong>: unspecified value</p>
<p><strong>No Default</strong></p>
<p><strong>No Example</strong></p>
<h2 id="cabalsystem"><a class="header" href="#cabalsystem">cabal.system</a></h2>
<p><strong>Type</strong>: unspecified value</p>
<p><strong>No Default</strong></p>
<p><strong>No Example</strong></p>
<h2 id="compilernix-name"><a class="header" href="#compilernix-name">compiler.nix-name</a></h2>
<p><strong>Type</strong>: string</p>
<p><strong>No Default</strong></p>
<p><strong>No Example</strong></p>
<h2 id="compilerpackages"><a class="header" href="#compilerpackages">compiler.packages</a></h2>
<p><strong>Type</strong>: attribute set of string</p>
<p><strong>No Default</strong></p>
<p><strong>No Example</strong></p>
<h2 id="compilerversion"><a class="header" href="#compilerversion">compiler.version</a></h2>
<p><strong>Type</strong>: string</p>
<p><strong>No Default</strong></p>
<p><strong>No Example</strong></p>
<h2 id="configureallcomponents"><a class="header" href="#configureallcomponents">configureAllComponents</a></h2>
<p>If set all the components in the package are configured (useful for cabal-doctest).</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: false</p>
<p><strong>No Example</strong></p>
<h2 id="configureflags"><a class="header" href="#configureflags">configureFlags</a></h2>
<p><strong>Type</strong>: list of string</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="contentaddressed"><a class="header" href="#contentaddressed">contentAddressed</a></h2>
<p>Build content addressed derivation, requires Nix to have experimental feature
<code>ca-derivations</code> enabled.</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: false</p>
<p><strong>No Example</strong></p>
<h2 id="docheck"><a class="header" href="#docheck">doCheck</a></h2>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: true</p>
<p><strong>No Example</strong></p>
<h2 id="docoverage"><a class="header" href="#docoverage">doCoverage</a></h2>
<p>Enable production of test coverage reports.</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: false</p>
<p><strong>No Example</strong></p>
<h2 id="docrosscheck"><a class="header" href="#docrosscheck">doCrossCheck</a></h2>
<p>Run doCheck also in cross compilation settings. This can be tricky as the test logic must know how to run the tests on the target.</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: false</p>
<p><strong>No Example</strong></p>
<h2 id="doexactconfig"><a class="header" href="#doexactconfig">doExactConfig</a></h2>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: false</p>
<p><strong>No Example</strong></p>
<h2 id="dohaddock"><a class="header" href="#dohaddock">doHaddock</a></h2>
<p>Enable building of the Haddock documentation from the annotated Haskell source code.</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: true</p>
<p><strong>No Example</strong></p>
<h2 id="dohoogle"><a class="header" href="#dohoogle">doHoogle</a></h2>
<p>Also build a hoogle index.</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: true</p>
<p><strong>No Example</strong></p>
<h2 id="dohyperlinksource"><a class="header" href="#dohyperlinksource">doHyperlinkSource</a></h2>
<p>Link documentation to the source code.</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: true</p>
<p><strong>No Example</strong></p>
<h2 id="doquickjump"><a class="header" href="#doquickjump">doQuickjump</a></h2>
<p>Generate an index for interactive documentation navigation.</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: true</p>
<p><strong>No Example</strong></p>
<h2 id="dontpatchelf"><a class="header" href="#dontpatchelf">dontPatchELF</a></h2>
<p>If set, the patchelf command is not used to remove unnecessary RPATH entries. Only applies to Linux.</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: true</p>
<p><strong>No Example</strong></p>
<h2 id="dontstrip"><a class="header" href="#dontstrip">dontStrip</a></h2>
<p>If set, libraries and executables are not stripped.</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: true</p>
<p><strong>No Example</strong></p>
<h2 id="enabledeadcodeelimination"><a class="header" href="#enabledeadcodeelimination">enableDeadCodeElimination</a></h2>
<p>If set, enables split sections for link-time dead-code stripping. Only applies to Linux</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: true</p>
<p><strong>No Example</strong></p>
<h2 id="enablelibraryprofiling"><a class="header" href="#enablelibraryprofiling">enableLibraryProfiling</a></h2>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: false</p>
<p><strong>No Example</strong></p>
<h2 id="enableprofiling"><a class="header" href="#enableprofiling">enableProfiling</a></h2>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: false</p>
<p><strong>No Example</strong></p>
<h2 id="enableseparatedataoutput"><a class="header" href="#enableseparatedataoutput">enableSeparateDataOutput</a></h2>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: true</p>
<p><strong>No Example</strong></p>
<h2 id="enableshared"><a class="header" href="#enableshared">enableShared</a></h2>
<p>If set, enables building shared libraries.</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: true</p>
<p><strong>No Example</strong></p>
<h2 id="enablestatic"><a class="header" href="#enablestatic">enableStatic</a></h2>
<p>If set, enables building static libraries and executables.</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: true</p>
<p><strong>No Example</strong></p>
<h2 id="errorhandler"><a class="header" href="#errorhandler">errorHandler</a></h2>
<p><strong>Type</strong>: unspecified value</p>
<p><strong>No Default</strong></p>
<p><strong>No Example</strong></p>
<h2 id="evalpackages"><a class="header" href="#evalpackages">evalPackages</a></h2>
<p>The <code>evalPackages</code> that will be used when building <code>hoogle</code> and shell tools.</p>
<p><strong>Type</strong>: unspecified value</p>
<p><strong>No Default</strong></p>
<p><strong>No Example</strong></p>
<h2 id="ghcpackage"><a class="header" href="#ghcpackage">ghc.package</a></h2>
<p><strong>Type</strong>: package</p>
<p><strong>Default</strong>: &quot;pkgs.buildPackages.haskell-nix.compiler.${config.compiler.nix-name}&quot;</p>
<p><strong>No Example</strong></p>
<h2 id="ghcoptions"><a class="header" href="#ghcoptions">ghcOptions</a></h2>
<p><strong>Type</strong>: list of string</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="hackageconfigs"><a class="header" href="#hackageconfigs">hackage.configs</a></h2>
<p><strong>Type</strong>: unspecified value</p>
<p><strong>No Default</strong></p>
<p><strong>No Example</strong></p>
<h2 id="hackagedb"><a class="header" href="#hackagedb">hackage.db</a></h2>
<p><strong>Type</strong>: unspecified value</p>
<p><strong>No Default</strong></p>
<p><strong>No Example</strong></p>
<h2 id="hardeningdisable"><a class="header" href="#hardeningdisable">hardeningDisable</a></h2>
<p><strong>Type</strong>: list of string</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="hspkgs"><a class="header" href="#hspkgs">hsPkgs</a></h2>
<p><strong>Type</strong>: unspecified value</p>
<p><strong>No Default</strong></p>
<p><strong>No Example</strong></p>
<h2 id="inputmap"><a class="header" href="#inputmap">inputMap</a></h2>
<p><strong>Type</strong>: attribute set of unspecified value</p>
<p><strong>Default</strong>: {}</p>
<p><strong>No Example</strong></p>
<h2 id="keepsource"><a class="header" href="#keepsource">keepSource</a></h2>
<p>Keep component source in the store in a <code>source</code> output</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: false</p>
<p><strong>No Example</strong></p>
<h2 id="nonreinstallablepkgs"><a class="header" href="#nonreinstallablepkgs">nonReinstallablePkgs</a></h2>
<p><strong>Type</strong>: list of string</p>
<p><strong>No Default</strong></p>
<p><strong>No Example</strong></p>
<h2 id="packages"><a class="header" href="#packages">packages</a></h2>
<p><strong>Type</strong>: attribute set of (submodule)</p>
<p><strong>No Default</strong></p>
<p><strong>No Example</strong></p>
<h2 id="packagesallcomponent"><a class="header" href="#packagesallcomponent">packages.<name>.allComponent</a></h2>
<p>The merged dependencies of all other components</p>
<p><strong>Type</strong>: submodule</p>
<p><strong>No Default</strong></p>
<p><strong>No Example</strong></p>
<h2 id="packagesallcomponentasmsources"><a class="header" href="#packagesallcomponentasmsources">packages.<name>.allComponent.asmSources</a></h2>
<p><strong>Type</strong>: list of unspecified value</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagesallcomponentbuild-tools"><a class="header" href="#packagesallcomponentbuild-tools">packages.<name>.allComponent.build-tools</a></h2>
<p><strong>Type</strong>: list of unspecified value</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagesallcomponentbuildable"><a class="header" href="#packagesallcomponentbuildable">packages.<name>.allComponent.buildable</a></h2>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: true</p>
<p><strong>No Example</strong></p>
<h2 id="packagesallcomponentcsources"><a class="header" href="#packagesallcomponentcsources">packages.<name>.allComponent.cSources</a></h2>
<p><strong>Type</strong>: list of unspecified value</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagesallcomponentcmmsources"><a class="header" href="#packagesallcomponentcmmsources">packages.<name>.allComponent.cmmSources</a></h2>
<p><strong>Type</strong>: list of unspecified value</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagesallcomponentconfigureallcomponents"><a class="header" href="#packagesallcomponentconfigureallcomponents">packages.<name>.allComponent.configureAllComponents</a></h2>
<p>If set all the components in the package are configured (useful for cabal-doctest).</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: false</p>
<p><strong>No Example</strong></p>
<h2 id="packagesallcomponentconfigureflags"><a class="header" href="#packagesallcomponentconfigureflags">packages.<name>.allComponent.configureFlags</a></h2>
<p><strong>Type</strong>: list of string</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagesallcomponentcontentaddressed"><a class="header" href="#packagesallcomponentcontentaddressed">packages.<name>.allComponent.contentAddressed</a></h2>
<p>Build content addressed derivation, requires Nix to have experimental feature
<code>ca-derivations</code> enabled.</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: false</p>
<p><strong>No Example</strong></p>
<h2 id="packagesallcomponentcxxsources"><a class="header" href="#packagesallcomponentcxxsources">packages.<name>.allComponent.cxxSources</a></h2>
<p><strong>Type</strong>: list of unspecified value</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagesallcomponentdepends"><a class="header" href="#packagesallcomponentdepends">packages.<name>.allComponent.depends</a></h2>
<p><strong>Type</strong>: list of unspecified value</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagesallcomponentdocheck"><a class="header" href="#packagesallcomponentdocheck">packages.<name>.allComponent.doCheck</a></h2>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: true</p>
<p><strong>No Example</strong></p>
<h2 id="packagesallcomponentdocoverage"><a class="header" href="#packagesallcomponentdocoverage">packages.<name>.allComponent.doCoverage</a></h2>
<p>Enable production of test coverage reports.</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: false</p>
<p><strong>No Example</strong></p>
<h2 id="packagesallcomponentdocrosscheck"><a class="header" href="#packagesallcomponentdocrosscheck">packages.<name>.allComponent.doCrossCheck</a></h2>
<p>Run doCheck also in cross compilation settings. This can be tricky as the test logic must know how to run the tests on the target.</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: false</p>
<p><strong>No Example</strong></p>
<h2 id="packagesallcomponentdoexactconfig"><a class="header" href="#packagesallcomponentdoexactconfig">packages.<name>.allComponent.doExactConfig</a></h2>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: false</p>
<p><strong>No Example</strong></p>
<h2 id="packagesallcomponentdohaddock"><a class="header" href="#packagesallcomponentdohaddock">packages.<name>.allComponent.doHaddock</a></h2>
<p>Enable building of the Haddock documentation from the annotated Haskell source code.</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: true</p>
<p><strong>No Example</strong></p>
<h2 id="packagesallcomponentdohoogle"><a class="header" href="#packagesallcomponentdohoogle">packages.<name>.allComponent.doHoogle</a></h2>
<p>Also build a hoogle index.</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: true</p>
<p><strong>No Example</strong></p>
<h2 id="packagesallcomponentdohyperlinksource"><a class="header" href="#packagesallcomponentdohyperlinksource">packages.<name>.allComponent.doHyperlinkSource</a></h2>
<p>Link documentation to the source code.</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: true</p>
<p><strong>No Example</strong></p>
<h2 id="packagesallcomponentdoquickjump"><a class="header" href="#packagesallcomponentdoquickjump">packages.<name>.allComponent.doQuickjump</a></h2>
<p>Generate an index for interactive documentation navigation.</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: true</p>
<p><strong>No Example</strong></p>
<h2 id="packagesallcomponentdontpatchelf"><a class="header" href="#packagesallcomponentdontpatchelf">packages.<name>.allComponent.dontPatchELF</a></h2>
<p>If set, the patchelf command is not used to remove unnecessary RPATH entries. Only applies to Linux.</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: true</p>
<p><strong>No Example</strong></p>
<h2 id="packagesallcomponentdontstrip"><a class="header" href="#packagesallcomponentdontstrip">packages.<name>.allComponent.dontStrip</a></h2>
<p>If set, libraries and executables are not stripped.</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: true</p>
<p><strong>No Example</strong></p>
<h2 id="packagesallcomponentenabledeadcodeelimination"><a class="header" href="#packagesallcomponentenabledeadcodeelimination">packages.<name>.allComponent.enableDeadCodeElimination</a></h2>
<p>If set, enables split sections for link-time dead-code stripping. Only applies to Linux</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: true</p>
<p><strong>No Example</strong></p>
<h2 id="packagesallcomponentenablelibraryprofiling"><a class="header" href="#packagesallcomponentenablelibraryprofiling">packages.<name>.allComponent.enableLibraryProfiling</a></h2>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: false</p>
<p><strong>No Example</strong></p>
<h2 id="packagesallcomponentenableprofiling"><a class="header" href="#packagesallcomponentenableprofiling">packages.<name>.allComponent.enableProfiling</a></h2>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: false</p>
<p><strong>No Example</strong></p>
<h2 id="packagesallcomponentenableseparatedataoutput"><a class="header" href="#packagesallcomponentenableseparatedataoutput">packages.<name>.allComponent.enableSeparateDataOutput</a></h2>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: true</p>
<p><strong>No Example</strong></p>
<h2 id="packagesallcomponentenableshared"><a class="header" href="#packagesallcomponentenableshared">packages.<name>.allComponent.enableShared</a></h2>
<p>If set, enables building shared libraries.</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: true</p>
<p><strong>No Example</strong></p>
<h2 id="packagesallcomponentenablestatic"><a class="header" href="#packagesallcomponentenablestatic">packages.<name>.allComponent.enableStatic</a></h2>
<p>If set, enables building static libraries and executables.</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: true</p>
<p><strong>No Example</strong></p>
<h2 id="packagesallcomponentextrasrcfiles"><a class="header" href="#packagesallcomponentextrasrcfiles">packages.<name>.allComponent.extraSrcFiles</a></h2>
<p><strong>Type</strong>: list of unspecified value</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagesallcomponentframeworks"><a class="header" href="#packagesallcomponentframeworks">packages.<name>.allComponent.frameworks</a></h2>
<p><strong>Type</strong>: list of package</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagesallcomponentghcoptions"><a class="header" href="#packagesallcomponentghcoptions">packages.<name>.allComponent.ghcOptions</a></h2>
<p><strong>Type</strong>: list of string</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagesallcomponenthardeningdisable"><a class="header" href="#packagesallcomponenthardeningdisable">packages.<name>.allComponent.hardeningDisable</a></h2>
<p><strong>Type</strong>: list of string</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagesallcomponenthssourcedirs"><a class="header" href="#packagesallcomponenthssourcedirs">packages.<name>.allComponent.hsSourceDirs</a></h2>
<p><strong>Type</strong>: list of unspecified value</p>
<p><strong>Default</strong>: [&quot;.&quot;]</p>
<p><strong>No Example</strong></p>
<h2 id="packagesallcomponentincludedirs"><a class="header" href="#packagesallcomponentincludedirs">packages.<name>.allComponent.includeDirs</a></h2>
<p><strong>Type</strong>: list of unspecified value</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagesallcomponentincludes"><a class="header" href="#packagesallcomponentincludes">packages.<name>.allComponent.includes</a></h2>
<p><strong>Type</strong>: list of unspecified value</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagesallcomponentjssources"><a class="header" href="#packagesallcomponentjssources">packages.<name>.allComponent.jsSources</a></h2>
<p><strong>Type</strong>: list of unspecified value</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagesallcomponentkeepsource"><a class="header" href="#packagesallcomponentkeepsource">packages.<name>.allComponent.keepSource</a></h2>
<p>Keep component source in the store in a <code>source</code> output</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: false</p>
<p><strong>No Example</strong></p>
<h2 id="packagesallcomponentlibs"><a class="header" href="#packagesallcomponentlibs">packages.<name>.allComponent.libs</a></h2>
<p><strong>Type</strong>: list of (null or package or list of package)</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagesallcomponentmainpath"><a class="header" href="#packagesallcomponentmainpath">packages.<name>.allComponent.mainPath</a></h2>
<p><strong>Type</strong>: list of unspecified value</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagesallcomponentmodules"><a class="header" href="#packagesallcomponentmodules">packages.<name>.allComponent.modules</a></h2>
<p><strong>Type</strong>: list of unspecified value</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagesallcomponentpkgconfig"><a class="header" href="#packagesallcomponentpkgconfig">packages.<name>.allComponent.pkgconfig</a></h2>
<p><strong>Type</strong>: list of list of package</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagesallcomponentplanned"><a class="header" href="#packagesallcomponentplanned">packages.<name>.allComponent.planned</a></h2>
<p>Set to true by <code>plan-to-nix</code> for any component that was included in the <code>plan.json</code> file.</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: false</p>
<p><strong>No Example</strong></p>
<h2 id="packagesallcomponentplatforms"><a class="header" href="#packagesallcomponentplatforms">packages.<name>.allComponent.platforms</a></h2>
<p><strong>Type</strong>: null or (list of unspecified value)</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="packagesallcomponentplugins"><a class="header" href="#packagesallcomponentplugins">packages.<name>.allComponent.plugins</a></h2>
<p><strong>Type</strong>: list of (submodule)</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagesallcomponentpluginsargs"><a class="header" href="#packagesallcomponentpluginsargs">packages.<name>.allComponent.plugins.*.args</a></h2>
<p><strong>Type</strong>: list of string</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagesallcomponentpluginslibrary"><a class="header" href="#packagesallcomponentpluginslibrary">packages.<name>.allComponent.plugins.*.library</a></h2>
<p><strong>Type</strong>: unspecified value</p>
<p><strong>No Default</strong></p>
<p><strong>No Example</strong></p>
<h2 id="packagesallcomponentpluginsmodulename"><a class="header" href="#packagesallcomponentpluginsmodulename">packages.<name>.allComponent.plugins.*.moduleName</a></h2>
<p><strong>Type</strong>: string</p>
<p><strong>No Default</strong></p>
<p><strong>No Example</strong></p>
<h2 id="packagesallcomponentpostbuild"><a class="header" href="#packagesallcomponentpostbuild">packages.<name>.allComponent.postBuild</a></h2>
<p><strong>Type</strong>: null or string</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="packagesallcomponentpostcheck"><a class="header" href="#packagesallcomponentpostcheck">packages.<name>.allComponent.postCheck</a></h2>
<p><strong>Type</strong>: null or string</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="packagesallcomponentpostconfigure"><a class="header" href="#packagesallcomponentpostconfigure">packages.<name>.allComponent.postConfigure</a></h2>
<p><strong>Type</strong>: null or string</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="packagesallcomponentposthaddock"><a class="header" href="#packagesallcomponentposthaddock">packages.<name>.allComponent.postHaddock</a></h2>
<p><strong>Type</strong>: null or string</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="packagesallcomponentpostinstall"><a class="header" href="#packagesallcomponentpostinstall">packages.<name>.allComponent.postInstall</a></h2>
<p><strong>Type</strong>: null or string</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="packagesallcomponentpostunpack"><a class="header" href="#packagesallcomponentpostunpack">packages.<name>.allComponent.postUnpack</a></h2>
<p><strong>Type</strong>: null or string</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="packagesallcomponentprebuild"><a class="header" href="#packagesallcomponentprebuild">packages.<name>.allComponent.preBuild</a></h2>
<p><strong>Type</strong>: null or string</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="packagesallcomponentprecheck"><a class="header" href="#packagesallcomponentprecheck">packages.<name>.allComponent.preCheck</a></h2>
<p><strong>Type</strong>: null or string</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="packagesallcomponentpreconfigure"><a class="header" href="#packagesallcomponentpreconfigure">packages.<name>.allComponent.preConfigure</a></h2>
<p><strong>Type</strong>: null or string</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="packagesallcomponentprehaddock"><a class="header" href="#packagesallcomponentprehaddock">packages.<name>.allComponent.preHaddock</a></h2>
<p><strong>Type</strong>: null or string</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="packagesallcomponentpreinstall"><a class="header" href="#packagesallcomponentpreinstall">packages.<name>.allComponent.preInstall</a></h2>
<p><strong>Type</strong>: null or string</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="packagesallcomponentpreunpack"><a class="header" href="#packagesallcomponentpreunpack">packages.<name>.allComponent.preUnpack</a></h2>
<p><strong>Type</strong>: null or strings concatenated with &quot;\n&quot;</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="packagesallcomponentprofilingdetail"><a class="header" href="#packagesallcomponentprofilingdetail">packages.<name>.allComponent.profilingDetail</a></h2>
<p><strong>Type</strong>: null or string</p>
<p><strong>Default</strong>: &quot;default&quot;</p>
<p><strong>No Example</strong></p>
<h2 id="packagesallcomponentsetupbuildflags"><a class="header" href="#packagesallcomponentsetupbuildflags">packages.<name>.allComponent.setupBuildFlags</a></h2>
<p><strong>Type</strong>: list of string</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagesallcomponentsetuphaddockflags"><a class="header" href="#packagesallcomponentsetuphaddockflags">packages.<name>.allComponent.setupHaddockFlags</a></h2>
<p><strong>Type</strong>: list of string</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagesallcomponentsetupinstallflags"><a class="header" href="#packagesallcomponentsetupinstallflags">packages.<name>.allComponent.setupInstallFlags</a></h2>
<p><strong>Type</strong>: list of string</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagesallcomponentshellhook"><a class="header" href="#packagesallcomponentshellhook">packages.<name>.allComponent.shellHook</a></h2>
<p>Hook to run when entering a shell</p>
<p><strong>Type</strong>: unspecified value</p>
<p><strong>Default</strong>: &quot;&quot;</p>
<p><strong>No Example</strong></p>
<h2 id="packagesallcomponenttestflags"><a class="header" href="#packagesallcomponenttestflags">packages.<name>.allComponent.testFlags</a></h2>
<p><strong>Type</strong>: list of string</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagesallcomponenttestwrapper"><a class="header" href="#packagesallcomponenttestwrapper">packages.<name>.allComponent.testWrapper</a></h2>
<p>A command to run for executing tests in checkPhase, which takes the original test command as its arguments.</p>
<p><strong>Type</strong>: list of string</p>
<p><strong>Default</strong>: []</p>
<p><strong>Example</strong>:</p>
<p>&quot;echo&quot;</p>
<h2 id="packagesallcomponentwritehiefiles"><a class="header" href="#packagesallcomponentwritehiefiles">packages.<name>.allComponent.writeHieFiles</a></h2>
<p>Write component <code>.hie</code> files in the store in a <code>hie</code> output</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: false</p>
<p><strong>No Example</strong></p>
<h2 id="packagesbuildable"><a class="header" href="#packagesbuildable">packages.<name>.buildable</a></h2>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: true</p>
<p><strong>No Example</strong></p>
<h2 id="packagescabal-generator"><a class="header" href="#packagescabal-generator">packages.<name>.cabal-generator</a></h2>
<p><strong>Type</strong>: null or string</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsbenchmarks"><a class="header" href="#packagescomponentsbenchmarks">packages.<name>.components.benchmarks</a></h2>
<p><strong>Type</strong>: attribute set of (submodule)</p>
<p><strong>Default</strong>: {}</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsbenchmarksasmsources"><a class="header" href="#packagescomponentsbenchmarksasmsources">packages.<name>.components.benchmarks.<name>.asmSources</a></h2>
<p><strong>Type</strong>: list of unspecified value</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsbenchmarksbuild-tools"><a class="header" href="#packagescomponentsbenchmarksbuild-tools">packages.<name>.components.benchmarks.<name>.build-tools</a></h2>
<p><strong>Type</strong>: list of unspecified value</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsbenchmarksbuildable"><a class="header" href="#packagescomponentsbenchmarksbuildable">packages.<name>.components.benchmarks.<name>.buildable</a></h2>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: true</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsbenchmarkscsources"><a class="header" href="#packagescomponentsbenchmarkscsources">packages.<name>.components.benchmarks.<name>.cSources</a></h2>
<p><strong>Type</strong>: list of unspecified value</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsbenchmarkscmmsources"><a class="header" href="#packagescomponentsbenchmarkscmmsources">packages.<name>.components.benchmarks.<name>.cmmSources</a></h2>
<p><strong>Type</strong>: list of unspecified value</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsbenchmarksconfigureallcomponents"><a class="header" href="#packagescomponentsbenchmarksconfigureallcomponents">packages.<name>.components.benchmarks.<name>.configureAllComponents</a></h2>
<p>If set all the components in the package are configured (useful for cabal-doctest).</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: false</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsbenchmarksconfigureflags"><a class="header" href="#packagescomponentsbenchmarksconfigureflags">packages.<name>.components.benchmarks.<name>.configureFlags</a></h2>
<p><strong>Type</strong>: list of string</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsbenchmarkscontentaddressed"><a class="header" href="#packagescomponentsbenchmarkscontentaddressed">packages.<name>.components.benchmarks.<name>.contentAddressed</a></h2>
<p>Build content addressed derivation, requires Nix to have experimental feature
<code>ca-derivations</code> enabled.</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: false</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsbenchmarkscxxsources"><a class="header" href="#packagescomponentsbenchmarkscxxsources">packages.<name>.components.benchmarks.<name>.cxxSources</a></h2>
<p><strong>Type</strong>: list of unspecified value</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsbenchmarksdepends"><a class="header" href="#packagescomponentsbenchmarksdepends">packages.<name>.components.benchmarks.<name>.depends</a></h2>
<p><strong>Type</strong>: list of unspecified value</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsbenchmarksdocheck"><a class="header" href="#packagescomponentsbenchmarksdocheck">packages.<name>.components.benchmarks.<name>.doCheck</a></h2>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: true</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsbenchmarksdocoverage"><a class="header" href="#packagescomponentsbenchmarksdocoverage">packages.<name>.components.benchmarks.<name>.doCoverage</a></h2>
<p>Enable production of test coverage reports.</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: false</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsbenchmarksdocrosscheck"><a class="header" href="#packagescomponentsbenchmarksdocrosscheck">packages.<name>.components.benchmarks.<name>.doCrossCheck</a></h2>
<p>Run doCheck also in cross compilation settings. This can be tricky as the test logic must know how to run the tests on the target.</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: false</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsbenchmarksdoexactconfig"><a class="header" href="#packagescomponentsbenchmarksdoexactconfig">packages.<name>.components.benchmarks.<name>.doExactConfig</a></h2>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: false</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsbenchmarksdohaddock"><a class="header" href="#packagescomponentsbenchmarksdohaddock">packages.<name>.components.benchmarks.<name>.doHaddock</a></h2>
<p>Enable building of the Haddock documentation from the annotated Haskell source code.</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: true</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsbenchmarksdohoogle"><a class="header" href="#packagescomponentsbenchmarksdohoogle">packages.<name>.components.benchmarks.<name>.doHoogle</a></h2>
<p>Also build a hoogle index.</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: true</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsbenchmarksdohyperlinksource"><a class="header" href="#packagescomponentsbenchmarksdohyperlinksource">packages.<name>.components.benchmarks.<name>.doHyperlinkSource</a></h2>
<p>Link documentation to the source code.</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: true</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsbenchmarksdoquickjump"><a class="header" href="#packagescomponentsbenchmarksdoquickjump">packages.<name>.components.benchmarks.<name>.doQuickjump</a></h2>
<p>Generate an index for interactive documentation navigation.</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: true</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsbenchmarksdontpatchelf"><a class="header" href="#packagescomponentsbenchmarksdontpatchelf">packages.<name>.components.benchmarks.<name>.dontPatchELF</a></h2>
<p>If set, the patchelf command is not used to remove unnecessary RPATH entries. Only applies to Linux.</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: true</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsbenchmarksdontstrip"><a class="header" href="#packagescomponentsbenchmarksdontstrip">packages.<name>.components.benchmarks.<name>.dontStrip</a></h2>
<p>If set, libraries and executables are not stripped.</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: true</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsbenchmarksenabledeadcodeelimination"><a class="header" href="#packagescomponentsbenchmarksenabledeadcodeelimination">packages.<name>.components.benchmarks.<name>.enableDeadCodeElimination</a></h2>
<p>If set, enables split sections for link-time dead-code stripping. Only applies to Linux</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: true</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsbenchmarksenablelibraryprofiling"><a class="header" href="#packagescomponentsbenchmarksenablelibraryprofiling">packages.<name>.components.benchmarks.<name>.enableLibraryProfiling</a></h2>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: false</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsbenchmarksenableprofiling"><a class="header" href="#packagescomponentsbenchmarksenableprofiling">packages.<name>.components.benchmarks.<name>.enableProfiling</a></h2>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: false</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsbenchmarksenableseparatedataoutput"><a class="header" href="#packagescomponentsbenchmarksenableseparatedataoutput">packages.<name>.components.benchmarks.<name>.enableSeparateDataOutput</a></h2>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: true</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsbenchmarksenableshared"><a class="header" href="#packagescomponentsbenchmarksenableshared">packages.<name>.components.benchmarks.<name>.enableShared</a></h2>
<p>If set, enables building shared libraries.</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: true</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsbenchmarksenablestatic"><a class="header" href="#packagescomponentsbenchmarksenablestatic">packages.<name>.components.benchmarks.<name>.enableStatic</a></h2>
<p>If set, enables building static libraries and executables.</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: true</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsbenchmarksextrasrcfiles"><a class="header" href="#packagescomponentsbenchmarksextrasrcfiles">packages.<name>.components.benchmarks.<name>.extraSrcFiles</a></h2>
<p><strong>Type</strong>: list of unspecified value</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsbenchmarksframeworks"><a class="header" href="#packagescomponentsbenchmarksframeworks">packages.<name>.components.benchmarks.<name>.frameworks</a></h2>
<p><strong>Type</strong>: list of package</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsbenchmarksghcoptions"><a class="header" href="#packagescomponentsbenchmarksghcoptions">packages.<name>.components.benchmarks.<name>.ghcOptions</a></h2>
<p><strong>Type</strong>: list of string</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsbenchmarkshardeningdisable"><a class="header" href="#packagescomponentsbenchmarkshardeningdisable">packages.<name>.components.benchmarks.<name>.hardeningDisable</a></h2>
<p><strong>Type</strong>: list of string</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsbenchmarkshssourcedirs"><a class="header" href="#packagescomponentsbenchmarkshssourcedirs">packages.<name>.components.benchmarks.<name>.hsSourceDirs</a></h2>
<p><strong>Type</strong>: list of unspecified value</p>
<p><strong>Default</strong>: [&quot;.&quot;]</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsbenchmarksincludedirs"><a class="header" href="#packagescomponentsbenchmarksincludedirs">packages.<name>.components.benchmarks.<name>.includeDirs</a></h2>
<p><strong>Type</strong>: list of unspecified value</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsbenchmarksincludes"><a class="header" href="#packagescomponentsbenchmarksincludes">packages.<name>.components.benchmarks.<name>.includes</a></h2>
<p><strong>Type</strong>: list of unspecified value</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsbenchmarksjssources"><a class="header" href="#packagescomponentsbenchmarksjssources">packages.<name>.components.benchmarks.<name>.jsSources</a></h2>
<p><strong>Type</strong>: list of unspecified value</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsbenchmarkskeepsource"><a class="header" href="#packagescomponentsbenchmarkskeepsource">packages.<name>.components.benchmarks.<name>.keepSource</a></h2>
<p>Keep component source in the store in a <code>source</code> output</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: false</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsbenchmarkslibs"><a class="header" href="#packagescomponentsbenchmarkslibs">packages.<name>.components.benchmarks.<name>.libs</a></h2>
<p><strong>Type</strong>: list of (null or package or list of package)</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsbenchmarksmainpath"><a class="header" href="#packagescomponentsbenchmarksmainpath">packages.<name>.components.benchmarks.<name>.mainPath</a></h2>
<p><strong>Type</strong>: list of unspecified value</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsbenchmarksmodules"><a class="header" href="#packagescomponentsbenchmarksmodules">packages.<name>.components.benchmarks.<name>.modules</a></h2>
<p><strong>Type</strong>: list of unspecified value</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsbenchmarkspkgconfig"><a class="header" href="#packagescomponentsbenchmarkspkgconfig">packages.<name>.components.benchmarks.<name>.pkgconfig</a></h2>
<p><strong>Type</strong>: list of list of package</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsbenchmarksplanned"><a class="header" href="#packagescomponentsbenchmarksplanned">packages.<name>.components.benchmarks.<name>.planned</a></h2>
<p>Set to true by <code>plan-to-nix</code> for any component that was included in the <code>plan.json</code> file.</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: false</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsbenchmarksplatforms"><a class="header" href="#packagescomponentsbenchmarksplatforms">packages.<name>.components.benchmarks.<name>.platforms</a></h2>
<p><strong>Type</strong>: null or (list of unspecified value)</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsbenchmarksplugins"><a class="header" href="#packagescomponentsbenchmarksplugins">packages.<name>.components.benchmarks.<name>.plugins</a></h2>
<p><strong>Type</strong>: list of (submodule)</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsbenchmarkspluginsargs"><a class="header" href="#packagescomponentsbenchmarkspluginsargs">packages.<name>.components.benchmarks.<name>.plugins.*.args</a></h2>
<p><strong>Type</strong>: list of string</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsbenchmarkspluginslibrary"><a class="header" href="#packagescomponentsbenchmarkspluginslibrary">packages.<name>.components.benchmarks.<name>.plugins.*.library</a></h2>
<p><strong>Type</strong>: unspecified value</p>
<p><strong>No Default</strong></p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsbenchmarkspluginsmodulename"><a class="header" href="#packagescomponentsbenchmarkspluginsmodulename">packages.<name>.components.benchmarks.<name>.plugins.*.moduleName</a></h2>
<p><strong>Type</strong>: string</p>
<p><strong>No Default</strong></p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsbenchmarkspostbuild"><a class="header" href="#packagescomponentsbenchmarkspostbuild">packages.<name>.components.benchmarks.<name>.postBuild</a></h2>
<p><strong>Type</strong>: null or string</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsbenchmarkspostcheck"><a class="header" href="#packagescomponentsbenchmarkspostcheck">packages.<name>.components.benchmarks.<name>.postCheck</a></h2>
<p><strong>Type</strong>: null or string</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsbenchmarkspostconfigure"><a class="header" href="#packagescomponentsbenchmarkspostconfigure">packages.<name>.components.benchmarks.<name>.postConfigure</a></h2>
<p><strong>Type</strong>: null or string</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsbenchmarksposthaddock"><a class="header" href="#packagescomponentsbenchmarksposthaddock">packages.<name>.components.benchmarks.<name>.postHaddock</a></h2>
<p><strong>Type</strong>: null or string</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsbenchmarkspostinstall"><a class="header" href="#packagescomponentsbenchmarkspostinstall">packages.<name>.components.benchmarks.<name>.postInstall</a></h2>
<p><strong>Type</strong>: null or string</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsbenchmarkspostunpack"><a class="header" href="#packagescomponentsbenchmarkspostunpack">packages.<name>.components.benchmarks.<name>.postUnpack</a></h2>
<p><strong>Type</strong>: null or string</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsbenchmarksprebuild"><a class="header" href="#packagescomponentsbenchmarksprebuild">packages.<name>.components.benchmarks.<name>.preBuild</a></h2>
<p><strong>Type</strong>: null or string</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsbenchmarksprecheck"><a class="header" href="#packagescomponentsbenchmarksprecheck">packages.<name>.components.benchmarks.<name>.preCheck</a></h2>
<p><strong>Type</strong>: null or string</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsbenchmarkspreconfigure"><a class="header" href="#packagescomponentsbenchmarkspreconfigure">packages.<name>.components.benchmarks.<name>.preConfigure</a></h2>
<p><strong>Type</strong>: null or string</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsbenchmarksprehaddock"><a class="header" href="#packagescomponentsbenchmarksprehaddock">packages.<name>.components.benchmarks.<name>.preHaddock</a></h2>
<p><strong>Type</strong>: null or string</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsbenchmarkspreinstall"><a class="header" href="#packagescomponentsbenchmarkspreinstall">packages.<name>.components.benchmarks.<name>.preInstall</a></h2>
<p><strong>Type</strong>: null or string</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsbenchmarkspreunpack"><a class="header" href="#packagescomponentsbenchmarkspreunpack">packages.<name>.components.benchmarks.<name>.preUnpack</a></h2>
<p><strong>Type</strong>: null or strings concatenated with &quot;\n&quot;</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsbenchmarksprofilingdetail"><a class="header" href="#packagescomponentsbenchmarksprofilingdetail">packages.<name>.components.benchmarks.<name>.profilingDetail</a></h2>
<p><strong>Type</strong>: null or string</p>
<p><strong>Default</strong>: &quot;default&quot;</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsbenchmarkssetupbuildflags"><a class="header" href="#packagescomponentsbenchmarkssetupbuildflags">packages.<name>.components.benchmarks.<name>.setupBuildFlags</a></h2>
<p><strong>Type</strong>: list of string</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsbenchmarkssetuphaddockflags"><a class="header" href="#packagescomponentsbenchmarkssetuphaddockflags">packages.<name>.components.benchmarks.<name>.setupHaddockFlags</a></h2>
<p><strong>Type</strong>: list of string</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsbenchmarkssetupinstallflags"><a class="header" href="#packagescomponentsbenchmarkssetupinstallflags">packages.<name>.components.benchmarks.<name>.setupInstallFlags</a></h2>
<p><strong>Type</strong>: list of string</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsbenchmarksshellhook"><a class="header" href="#packagescomponentsbenchmarksshellhook">packages.<name>.components.benchmarks.<name>.shellHook</a></h2>
<p>Hook to run when entering a shell</p>
<p><strong>Type</strong>: unspecified value</p>
<p><strong>Default</strong>: &quot;&quot;</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsbenchmarkstestflags"><a class="header" href="#packagescomponentsbenchmarkstestflags">packages.<name>.components.benchmarks.<name>.testFlags</a></h2>
<p><strong>Type</strong>: list of string</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsbenchmarkstestwrapper"><a class="header" href="#packagescomponentsbenchmarkstestwrapper">packages.<name>.components.benchmarks.<name>.testWrapper</a></h2>
<p>A command to run for executing tests in checkPhase, which takes the original test command as its arguments.</p>
<p><strong>Type</strong>: list of string</p>
<p><strong>Default</strong>: []</p>
<p><strong>Example</strong>:</p>
<p>&quot;echo&quot;</p>
<h2 id="packagescomponentsbenchmarkswritehiefiles"><a class="header" href="#packagescomponentsbenchmarkswritehiefiles">packages.<name>.components.benchmarks.<name>.writeHieFiles</a></h2>
<p>Write component <code>.hie</code> files in the store in a <code>hie</code> output</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: false</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsexes"><a class="header" href="#packagescomponentsexes">packages.<name>.components.exes</a></h2>
<p><strong>Type</strong>: attribute set of (submodule)</p>
<p><strong>Default</strong>: {}</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsexesasmsources"><a class="header" href="#packagescomponentsexesasmsources">packages.<name>.components.exes.<name>.asmSources</a></h2>
<p><strong>Type</strong>: list of unspecified value</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsexesbuild-tools"><a class="header" href="#packagescomponentsexesbuild-tools">packages.<name>.components.exes.<name>.build-tools</a></h2>
<p><strong>Type</strong>: list of unspecified value</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsexesbuildable"><a class="header" href="#packagescomponentsexesbuildable">packages.<name>.components.exes.<name>.buildable</a></h2>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: true</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsexescsources"><a class="header" href="#packagescomponentsexescsources">packages.<name>.components.exes.<name>.cSources</a></h2>
<p><strong>Type</strong>: list of unspecified value</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsexescmmsources"><a class="header" href="#packagescomponentsexescmmsources">packages.<name>.components.exes.<name>.cmmSources</a></h2>
<p><strong>Type</strong>: list of unspecified value</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsexesconfigureallcomponents"><a class="header" href="#packagescomponentsexesconfigureallcomponents">packages.<name>.components.exes.<name>.configureAllComponents</a></h2>
<p>If set all the components in the package are configured (useful for cabal-doctest).</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: false</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsexesconfigureflags"><a class="header" href="#packagescomponentsexesconfigureflags">packages.<name>.components.exes.<name>.configureFlags</a></h2>
<p><strong>Type</strong>: list of string</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsexescontentaddressed"><a class="header" href="#packagescomponentsexescontentaddressed">packages.<name>.components.exes.<name>.contentAddressed</a></h2>
<p>Build content addressed derivation, requires Nix to have experimental feature
<code>ca-derivations</code> enabled.</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: false</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsexescxxsources"><a class="header" href="#packagescomponentsexescxxsources">packages.<name>.components.exes.<name>.cxxSources</a></h2>
<p><strong>Type</strong>: list of unspecified value</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsexesdepends"><a class="header" href="#packagescomponentsexesdepends">packages.<name>.components.exes.<name>.depends</a></h2>
<p><strong>Type</strong>: list of unspecified value</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsexesdocheck"><a class="header" href="#packagescomponentsexesdocheck">packages.<name>.components.exes.<name>.doCheck</a></h2>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: true</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsexesdocoverage"><a class="header" href="#packagescomponentsexesdocoverage">packages.<name>.components.exes.<name>.doCoverage</a></h2>
<p>Enable production of test coverage reports.</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: false</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsexesdocrosscheck"><a class="header" href="#packagescomponentsexesdocrosscheck">packages.<name>.components.exes.<name>.doCrossCheck</a></h2>
<p>Run doCheck also in cross compilation settings. This can be tricky as the test logic must know how to run the tests on the target.</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: false</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsexesdoexactconfig"><a class="header" href="#packagescomponentsexesdoexactconfig">packages.<name>.components.exes.<name>.doExactConfig</a></h2>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: false</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsexesdohaddock"><a class="header" href="#packagescomponentsexesdohaddock">packages.<name>.components.exes.<name>.doHaddock</a></h2>
<p>Enable building of the Haddock documentation from the annotated Haskell source code.</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: true</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsexesdohoogle"><a class="header" href="#packagescomponentsexesdohoogle">packages.<name>.components.exes.<name>.doHoogle</a></h2>
<p>Also build a hoogle index.</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: true</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsexesdohyperlinksource"><a class="header" href="#packagescomponentsexesdohyperlinksource">packages.<name>.components.exes.<name>.doHyperlinkSource</a></h2>
<p>Link documentation to the source code.</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: true</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsexesdoquickjump"><a class="header" href="#packagescomponentsexesdoquickjump">packages.<name>.components.exes.<name>.doQuickjump</a></h2>
<p>Generate an index for interactive documentation navigation.</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: true</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsexesdontpatchelf"><a class="header" href="#packagescomponentsexesdontpatchelf">packages.<name>.components.exes.<name>.dontPatchELF</a></h2>
<p>If set, the patchelf command is not used to remove unnecessary RPATH entries. Only applies to Linux.</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: true</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsexesdontstrip"><a class="header" href="#packagescomponentsexesdontstrip">packages.<name>.components.exes.<name>.dontStrip</a></h2>
<p>If set, libraries and executables are not stripped.</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: true</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsexesenabledeadcodeelimination"><a class="header" href="#packagescomponentsexesenabledeadcodeelimination">packages.<name>.components.exes.<name>.enableDeadCodeElimination</a></h2>
<p>If set, enables split sections for link-time dead-code stripping. Only applies to Linux</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: true</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsexesenablelibraryprofiling"><a class="header" href="#packagescomponentsexesenablelibraryprofiling">packages.<name>.components.exes.<name>.enableLibraryProfiling</a></h2>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: false</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsexesenableprofiling"><a class="header" href="#packagescomponentsexesenableprofiling">packages.<name>.components.exes.<name>.enableProfiling</a></h2>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: false</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsexesenableseparatedataoutput"><a class="header" href="#packagescomponentsexesenableseparatedataoutput">packages.<name>.components.exes.<name>.enableSeparateDataOutput</a></h2>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: true</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsexesenableshared"><a class="header" href="#packagescomponentsexesenableshared">packages.<name>.components.exes.<name>.enableShared</a></h2>
<p>If set, enables building shared libraries.</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: true</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsexesenablestatic"><a class="header" href="#packagescomponentsexesenablestatic">packages.<name>.components.exes.<name>.enableStatic</a></h2>
<p>If set, enables building static libraries and executables.</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: true</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsexesextrasrcfiles"><a class="header" href="#packagescomponentsexesextrasrcfiles">packages.<name>.components.exes.<name>.extraSrcFiles</a></h2>
<p><strong>Type</strong>: list of unspecified value</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsexesframeworks"><a class="header" href="#packagescomponentsexesframeworks">packages.<name>.components.exes.<name>.frameworks</a></h2>
<p><strong>Type</strong>: list of package</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsexesghcoptions"><a class="header" href="#packagescomponentsexesghcoptions">packages.<name>.components.exes.<name>.ghcOptions</a></h2>
<p><strong>Type</strong>: list of string</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsexeshardeningdisable"><a class="header" href="#packagescomponentsexeshardeningdisable">packages.<name>.components.exes.<name>.hardeningDisable</a></h2>
<p><strong>Type</strong>: list of string</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsexeshssourcedirs"><a class="header" href="#packagescomponentsexeshssourcedirs">packages.<name>.components.exes.<name>.hsSourceDirs</a></h2>
<p><strong>Type</strong>: list of unspecified value</p>
<p><strong>Default</strong>: [&quot;.&quot;]</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsexesincludedirs"><a class="header" href="#packagescomponentsexesincludedirs">packages.<name>.components.exes.<name>.includeDirs</a></h2>
<p><strong>Type</strong>: list of unspecified value</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsexesincludes"><a class="header" href="#packagescomponentsexesincludes">packages.<name>.components.exes.<name>.includes</a></h2>
<p><strong>Type</strong>: list of unspecified value</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsexesjssources"><a class="header" href="#packagescomponentsexesjssources">packages.<name>.components.exes.<name>.jsSources</a></h2>
<p><strong>Type</strong>: list of unspecified value</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsexeskeepsource"><a class="header" href="#packagescomponentsexeskeepsource">packages.<name>.components.exes.<name>.keepSource</a></h2>
<p>Keep component source in the store in a <code>source</code> output</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: false</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsexeslibs"><a class="header" href="#packagescomponentsexeslibs">packages.<name>.components.exes.<name>.libs</a></h2>
<p><strong>Type</strong>: list of (null or package or list of package)</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsexesmainpath"><a class="header" href="#packagescomponentsexesmainpath">packages.<name>.components.exes.<name>.mainPath</a></h2>
<p><strong>Type</strong>: list of unspecified value</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsexesmodules"><a class="header" href="#packagescomponentsexesmodules">packages.<name>.components.exes.<name>.modules</a></h2>
<p><strong>Type</strong>: list of unspecified value</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsexespkgconfig"><a class="header" href="#packagescomponentsexespkgconfig">packages.<name>.components.exes.<name>.pkgconfig</a></h2>
<p><strong>Type</strong>: list of list of package</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsexesplanned"><a class="header" href="#packagescomponentsexesplanned">packages.<name>.components.exes.<name>.planned</a></h2>
<p>Set to true by <code>plan-to-nix</code> for any component that was included in the <code>plan.json</code> file.</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: false</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsexesplatforms"><a class="header" href="#packagescomponentsexesplatforms">packages.<name>.components.exes.<name>.platforms</a></h2>
<p><strong>Type</strong>: null or (list of unspecified value)</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsexesplugins"><a class="header" href="#packagescomponentsexesplugins">packages.<name>.components.exes.<name>.plugins</a></h2>
<p><strong>Type</strong>: list of (submodule)</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsexespluginsargs"><a class="header" href="#packagescomponentsexespluginsargs">packages.<name>.components.exes.<name>.plugins.*.args</a></h2>
<p><strong>Type</strong>: list of string</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsexespluginslibrary"><a class="header" href="#packagescomponentsexespluginslibrary">packages.<name>.components.exes.<name>.plugins.*.library</a></h2>
<p><strong>Type</strong>: unspecified value</p>
<p><strong>No Default</strong></p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsexespluginsmodulename"><a class="header" href="#packagescomponentsexespluginsmodulename">packages.<name>.components.exes.<name>.plugins.*.moduleName</a></h2>
<p><strong>Type</strong>: string</p>
<p><strong>No Default</strong></p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsexespostbuild"><a class="header" href="#packagescomponentsexespostbuild">packages.<name>.components.exes.<name>.postBuild</a></h2>
<p><strong>Type</strong>: null or string</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsexespostcheck"><a class="header" href="#packagescomponentsexespostcheck">packages.<name>.components.exes.<name>.postCheck</a></h2>
<p><strong>Type</strong>: null or string</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsexespostconfigure"><a class="header" href="#packagescomponentsexespostconfigure">packages.<name>.components.exes.<name>.postConfigure</a></h2>
<p><strong>Type</strong>: null or string</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsexesposthaddock"><a class="header" href="#packagescomponentsexesposthaddock">packages.<name>.components.exes.<name>.postHaddock</a></h2>
<p><strong>Type</strong>: null or string</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsexespostinstall"><a class="header" href="#packagescomponentsexespostinstall">packages.<name>.components.exes.<name>.postInstall</a></h2>
<p><strong>Type</strong>: null or string</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsexespostunpack"><a class="header" href="#packagescomponentsexespostunpack">packages.<name>.components.exes.<name>.postUnpack</a></h2>
<p><strong>Type</strong>: null or string</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsexesprebuild"><a class="header" href="#packagescomponentsexesprebuild">packages.<name>.components.exes.<name>.preBuild</a></h2>
<p><strong>Type</strong>: null or string</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsexesprecheck"><a class="header" href="#packagescomponentsexesprecheck">packages.<name>.components.exes.<name>.preCheck</a></h2>
<p><strong>Type</strong>: null or string</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsexespreconfigure"><a class="header" href="#packagescomponentsexespreconfigure">packages.<name>.components.exes.<name>.preConfigure</a></h2>
<p><strong>Type</strong>: null or string</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsexesprehaddock"><a class="header" href="#packagescomponentsexesprehaddock">packages.<name>.components.exes.<name>.preHaddock</a></h2>
<p><strong>Type</strong>: null or string</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsexespreinstall"><a class="header" href="#packagescomponentsexespreinstall">packages.<name>.components.exes.<name>.preInstall</a></h2>
<p><strong>Type</strong>: null or string</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsexespreunpack"><a class="header" href="#packagescomponentsexespreunpack">packages.<name>.components.exes.<name>.preUnpack</a></h2>
<p><strong>Type</strong>: null or strings concatenated with &quot;\n&quot;</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsexesprofilingdetail"><a class="header" href="#packagescomponentsexesprofilingdetail">packages.<name>.components.exes.<name>.profilingDetail</a></h2>
<p><strong>Type</strong>: null or string</p>
<p><strong>Default</strong>: &quot;default&quot;</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsexessetupbuildflags"><a class="header" href="#packagescomponentsexessetupbuildflags">packages.<name>.components.exes.<name>.setupBuildFlags</a></h2>
<p><strong>Type</strong>: list of string</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsexessetuphaddockflags"><a class="header" href="#packagescomponentsexessetuphaddockflags">packages.<name>.components.exes.<name>.setupHaddockFlags</a></h2>
<p><strong>Type</strong>: list of string</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsexessetupinstallflags"><a class="header" href="#packagescomponentsexessetupinstallflags">packages.<name>.components.exes.<name>.setupInstallFlags</a></h2>
<p><strong>Type</strong>: list of string</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsexesshellhook"><a class="header" href="#packagescomponentsexesshellhook">packages.<name>.components.exes.<name>.shellHook</a></h2>
<p>Hook to run when entering a shell</p>
<p><strong>Type</strong>: unspecified value</p>
<p><strong>Default</strong>: &quot;&quot;</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsexestestflags"><a class="header" href="#packagescomponentsexestestflags">packages.<name>.components.exes.<name>.testFlags</a></h2>
<p><strong>Type</strong>: list of string</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsexestestwrapper"><a class="header" href="#packagescomponentsexestestwrapper">packages.<name>.components.exes.<name>.testWrapper</a></h2>
<p>A command to run for executing tests in checkPhase, which takes the original test command as its arguments.</p>
<p><strong>Type</strong>: list of string</p>
<p><strong>Default</strong>: []</p>
<p><strong>Example</strong>:</p>
<p>&quot;echo&quot;</p>
<h2 id="packagescomponentsexeswritehiefiles"><a class="header" href="#packagescomponentsexeswritehiefiles">packages.<name>.components.exes.<name>.writeHieFiles</a></h2>
<p>Write component <code>.hie</code> files in the store in a <code>hie</code> output</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: false</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsforeignlibs"><a class="header" href="#packagescomponentsforeignlibs">packages.<name>.components.foreignlibs</a></h2>
<p><strong>Type</strong>: attribute set of (submodule)</p>
<p><strong>Default</strong>: {}</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsforeignlibsasmsources"><a class="header" href="#packagescomponentsforeignlibsasmsources">packages.<name>.components.foreignlibs.<name>.asmSources</a></h2>
<p><strong>Type</strong>: list of unspecified value</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsforeignlibsbuild-tools"><a class="header" href="#packagescomponentsforeignlibsbuild-tools">packages.<name>.components.foreignlibs.<name>.build-tools</a></h2>
<p><strong>Type</strong>: list of unspecified value</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsforeignlibsbuildable"><a class="header" href="#packagescomponentsforeignlibsbuildable">packages.<name>.components.foreignlibs.<name>.buildable</a></h2>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: true</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsforeignlibscsources"><a class="header" href="#packagescomponentsforeignlibscsources">packages.<name>.components.foreignlibs.<name>.cSources</a></h2>
<p><strong>Type</strong>: list of unspecified value</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsforeignlibscmmsources"><a class="header" href="#packagescomponentsforeignlibscmmsources">packages.<name>.components.foreignlibs.<name>.cmmSources</a></h2>
<p><strong>Type</strong>: list of unspecified value</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsforeignlibsconfigureallcomponents"><a class="header" href="#packagescomponentsforeignlibsconfigureallcomponents">packages.<name>.components.foreignlibs.<name>.configureAllComponents</a></h2>
<p>If set all the components in the package are configured (useful for cabal-doctest).</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: false</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsforeignlibsconfigureflags"><a class="header" href="#packagescomponentsforeignlibsconfigureflags">packages.<name>.components.foreignlibs.<name>.configureFlags</a></h2>
<p><strong>Type</strong>: list of string</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsforeignlibscontentaddressed"><a class="header" href="#packagescomponentsforeignlibscontentaddressed">packages.<name>.components.foreignlibs.<name>.contentAddressed</a></h2>
<p>Build content addressed derivation, requires Nix to have experimental feature
<code>ca-derivations</code> enabled.</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: false</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsforeignlibscxxsources"><a class="header" href="#packagescomponentsforeignlibscxxsources">packages.<name>.components.foreignlibs.<name>.cxxSources</a></h2>
<p><strong>Type</strong>: list of unspecified value</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsforeignlibsdepends"><a class="header" href="#packagescomponentsforeignlibsdepends">packages.<name>.components.foreignlibs.<name>.depends</a></h2>
<p><strong>Type</strong>: list of unspecified value</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsforeignlibsdocheck"><a class="header" href="#packagescomponentsforeignlibsdocheck">packages.<name>.components.foreignlibs.<name>.doCheck</a></h2>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: true</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsforeignlibsdocoverage"><a class="header" href="#packagescomponentsforeignlibsdocoverage">packages.<name>.components.foreignlibs.<name>.doCoverage</a></h2>
<p>Enable production of test coverage reports.</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: false</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsforeignlibsdocrosscheck"><a class="header" href="#packagescomponentsforeignlibsdocrosscheck">packages.<name>.components.foreignlibs.<name>.doCrossCheck</a></h2>
<p>Run doCheck also in cross compilation settings. This can be tricky as the test logic must know how to run the tests on the target.</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: false</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsforeignlibsdoexactconfig"><a class="header" href="#packagescomponentsforeignlibsdoexactconfig">packages.<name>.components.foreignlibs.<name>.doExactConfig</a></h2>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: false</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsforeignlibsdohaddock"><a class="header" href="#packagescomponentsforeignlibsdohaddock">packages.<name>.components.foreignlibs.<name>.doHaddock</a></h2>
<p>Enable building of the Haddock documentation from the annotated Haskell source code.</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: true</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsforeignlibsdohoogle"><a class="header" href="#packagescomponentsforeignlibsdohoogle">packages.<name>.components.foreignlibs.<name>.doHoogle</a></h2>
<p>Also build a hoogle index.</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: true</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsforeignlibsdohyperlinksource"><a class="header" href="#packagescomponentsforeignlibsdohyperlinksource">packages.<name>.components.foreignlibs.<name>.doHyperlinkSource</a></h2>
<p>Link documentation to the source code.</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: true</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsforeignlibsdoquickjump"><a class="header" href="#packagescomponentsforeignlibsdoquickjump">packages.<name>.components.foreignlibs.<name>.doQuickjump</a></h2>
<p>Generate an index for interactive documentation navigation.</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: true</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsforeignlibsdontpatchelf"><a class="header" href="#packagescomponentsforeignlibsdontpatchelf">packages.<name>.components.foreignlibs.<name>.dontPatchELF</a></h2>
<p>If set, the patchelf command is not used to remove unnecessary RPATH entries. Only applies to Linux.</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: true</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsforeignlibsdontstrip"><a class="header" href="#packagescomponentsforeignlibsdontstrip">packages.<name>.components.foreignlibs.<name>.dontStrip</a></h2>
<p>If set, libraries and executables are not stripped.</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: true</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsforeignlibsenabledeadcodeelimination"><a class="header" href="#packagescomponentsforeignlibsenabledeadcodeelimination">packages.<name>.components.foreignlibs.<name>.enableDeadCodeElimination</a></h2>
<p>If set, enables split sections for link-time dead-code stripping. Only applies to Linux</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: true</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsforeignlibsenablelibraryprofiling"><a class="header" href="#packagescomponentsforeignlibsenablelibraryprofiling">packages.<name>.components.foreignlibs.<name>.enableLibraryProfiling</a></h2>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: false</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsforeignlibsenableprofiling"><a class="header" href="#packagescomponentsforeignlibsenableprofiling">packages.<name>.components.foreignlibs.<name>.enableProfiling</a></h2>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: false</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsforeignlibsenableseparatedataoutput"><a class="header" href="#packagescomponentsforeignlibsenableseparatedataoutput">packages.<name>.components.foreignlibs.<name>.enableSeparateDataOutput</a></h2>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: true</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsforeignlibsenableshared"><a class="header" href="#packagescomponentsforeignlibsenableshared">packages.<name>.components.foreignlibs.<name>.enableShared</a></h2>
<p>If set, enables building shared libraries.</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: true</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsforeignlibsenablestatic"><a class="header" href="#packagescomponentsforeignlibsenablestatic">packages.<name>.components.foreignlibs.<name>.enableStatic</a></h2>
<p>If set, enables building static libraries and executables.</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: true</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsforeignlibsextrasrcfiles"><a class="header" href="#packagescomponentsforeignlibsextrasrcfiles">packages.<name>.components.foreignlibs.<name>.extraSrcFiles</a></h2>
<p><strong>Type</strong>: list of unspecified value</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsforeignlibsframeworks"><a class="header" href="#packagescomponentsforeignlibsframeworks">packages.<name>.components.foreignlibs.<name>.frameworks</a></h2>
<p><strong>Type</strong>: list of package</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsforeignlibsghcoptions"><a class="header" href="#packagescomponentsforeignlibsghcoptions">packages.<name>.components.foreignlibs.<name>.ghcOptions</a></h2>
<p><strong>Type</strong>: list of string</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsforeignlibshardeningdisable"><a class="header" href="#packagescomponentsforeignlibshardeningdisable">packages.<name>.components.foreignlibs.<name>.hardeningDisable</a></h2>
<p><strong>Type</strong>: list of string</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsforeignlibshssourcedirs"><a class="header" href="#packagescomponentsforeignlibshssourcedirs">packages.<name>.components.foreignlibs.<name>.hsSourceDirs</a></h2>
<p><strong>Type</strong>: list of unspecified value</p>
<p><strong>Default</strong>: [&quot;.&quot;]</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsforeignlibsincludedirs"><a class="header" href="#packagescomponentsforeignlibsincludedirs">packages.<name>.components.foreignlibs.<name>.includeDirs</a></h2>
<p><strong>Type</strong>: list of unspecified value</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsforeignlibsincludes"><a class="header" href="#packagescomponentsforeignlibsincludes">packages.<name>.components.foreignlibs.<name>.includes</a></h2>
<p><strong>Type</strong>: list of unspecified value</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsforeignlibsjssources"><a class="header" href="#packagescomponentsforeignlibsjssources">packages.<name>.components.foreignlibs.<name>.jsSources</a></h2>
<p><strong>Type</strong>: list of unspecified value</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsforeignlibskeepsource"><a class="header" href="#packagescomponentsforeignlibskeepsource">packages.<name>.components.foreignlibs.<name>.keepSource</a></h2>
<p>Keep component source in the store in a <code>source</code> output</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: false</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsforeignlibslibs"><a class="header" href="#packagescomponentsforeignlibslibs">packages.<name>.components.foreignlibs.<name>.libs</a></h2>
<p><strong>Type</strong>: list of (null or package or list of package)</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsforeignlibsmainpath"><a class="header" href="#packagescomponentsforeignlibsmainpath">packages.<name>.components.foreignlibs.<name>.mainPath</a></h2>
<p><strong>Type</strong>: list of unspecified value</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsforeignlibsmodules"><a class="header" href="#packagescomponentsforeignlibsmodules">packages.<name>.components.foreignlibs.<name>.modules</a></h2>
<p><strong>Type</strong>: list of unspecified value</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsforeignlibspkgconfig"><a class="header" href="#packagescomponentsforeignlibspkgconfig">packages.<name>.components.foreignlibs.<name>.pkgconfig</a></h2>
<p><strong>Type</strong>: list of list of package</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsforeignlibsplanned"><a class="header" href="#packagescomponentsforeignlibsplanned">packages.<name>.components.foreignlibs.<name>.planned</a></h2>
<p>Set to true by <code>plan-to-nix</code> for any component that was included in the <code>plan.json</code> file.</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: false</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsforeignlibsplatforms"><a class="header" href="#packagescomponentsforeignlibsplatforms">packages.<name>.components.foreignlibs.<name>.platforms</a></h2>
<p><strong>Type</strong>: null or (list of unspecified value)</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsforeignlibsplugins"><a class="header" href="#packagescomponentsforeignlibsplugins">packages.<name>.components.foreignlibs.<name>.plugins</a></h2>
<p><strong>Type</strong>: list of (submodule)</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsforeignlibspluginsargs"><a class="header" href="#packagescomponentsforeignlibspluginsargs">packages.<name>.components.foreignlibs.<name>.plugins.*.args</a></h2>
<p><strong>Type</strong>: list of string</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsforeignlibspluginslibrary"><a class="header" href="#packagescomponentsforeignlibspluginslibrary">packages.<name>.components.foreignlibs.<name>.plugins.*.library</a></h2>
<p><strong>Type</strong>: unspecified value</p>
<p><strong>No Default</strong></p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsforeignlibspluginsmodulename"><a class="header" href="#packagescomponentsforeignlibspluginsmodulename">packages.<name>.components.foreignlibs.<name>.plugins.*.moduleName</a></h2>
<p><strong>Type</strong>: string</p>
<p><strong>No Default</strong></p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsforeignlibspostbuild"><a class="header" href="#packagescomponentsforeignlibspostbuild">packages.<name>.components.foreignlibs.<name>.postBuild</a></h2>
<p><strong>Type</strong>: null or string</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsforeignlibspostcheck"><a class="header" href="#packagescomponentsforeignlibspostcheck">packages.<name>.components.foreignlibs.<name>.postCheck</a></h2>
<p><strong>Type</strong>: null or string</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsforeignlibspostconfigure"><a class="header" href="#packagescomponentsforeignlibspostconfigure">packages.<name>.components.foreignlibs.<name>.postConfigure</a></h2>
<p><strong>Type</strong>: null or string</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsforeignlibsposthaddock"><a class="header" href="#packagescomponentsforeignlibsposthaddock">packages.<name>.components.foreignlibs.<name>.postHaddock</a></h2>
<p><strong>Type</strong>: null or string</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsforeignlibspostinstall"><a class="header" href="#packagescomponentsforeignlibspostinstall">packages.<name>.components.foreignlibs.<name>.postInstall</a></h2>
<p><strong>Type</strong>: null or string</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsforeignlibspostunpack"><a class="header" href="#packagescomponentsforeignlibspostunpack">packages.<name>.components.foreignlibs.<name>.postUnpack</a></h2>
<p><strong>Type</strong>: null or string</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsforeignlibsprebuild"><a class="header" href="#packagescomponentsforeignlibsprebuild">packages.<name>.components.foreignlibs.<name>.preBuild</a></h2>
<p><strong>Type</strong>: null or string</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsforeignlibsprecheck"><a class="header" href="#packagescomponentsforeignlibsprecheck">packages.<name>.components.foreignlibs.<name>.preCheck</a></h2>
<p><strong>Type</strong>: null or string</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsforeignlibspreconfigure"><a class="header" href="#packagescomponentsforeignlibspreconfigure">packages.<name>.components.foreignlibs.<name>.preConfigure</a></h2>
<p><strong>Type</strong>: null or string</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsforeignlibsprehaddock"><a class="header" href="#packagescomponentsforeignlibsprehaddock">packages.<name>.components.foreignlibs.<name>.preHaddock</a></h2>
<p><strong>Type</strong>: null or string</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsforeignlibspreinstall"><a class="header" href="#packagescomponentsforeignlibspreinstall">packages.<name>.components.foreignlibs.<name>.preInstall</a></h2>
<p><strong>Type</strong>: null or string</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsforeignlibspreunpack"><a class="header" href="#packagescomponentsforeignlibspreunpack">packages.<name>.components.foreignlibs.<name>.preUnpack</a></h2>
<p><strong>Type</strong>: null or strings concatenated with &quot;\n&quot;</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsforeignlibsprofilingdetail"><a class="header" href="#packagescomponentsforeignlibsprofilingdetail">packages.<name>.components.foreignlibs.<name>.profilingDetail</a></h2>
<p><strong>Type</strong>: null or string</p>
<p><strong>Default</strong>: &quot;default&quot;</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsforeignlibssetupbuildflags"><a class="header" href="#packagescomponentsforeignlibssetupbuildflags">packages.<name>.components.foreignlibs.<name>.setupBuildFlags</a></h2>
<p><strong>Type</strong>: list of string</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsforeignlibssetuphaddockflags"><a class="header" href="#packagescomponentsforeignlibssetuphaddockflags">packages.<name>.components.foreignlibs.<name>.setupHaddockFlags</a></h2>
<p><strong>Type</strong>: list of string</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsforeignlibssetupinstallflags"><a class="header" href="#packagescomponentsforeignlibssetupinstallflags">packages.<name>.components.foreignlibs.<name>.setupInstallFlags</a></h2>
<p><strong>Type</strong>: list of string</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsforeignlibsshellhook"><a class="header" href="#packagescomponentsforeignlibsshellhook">packages.<name>.components.foreignlibs.<name>.shellHook</a></h2>
<p>Hook to run when entering a shell</p>
<p><strong>Type</strong>: unspecified value</p>
<p><strong>Default</strong>: &quot;&quot;</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsforeignlibstestflags"><a class="header" href="#packagescomponentsforeignlibstestflags">packages.<name>.components.foreignlibs.<name>.testFlags</a></h2>
<p><strong>Type</strong>: list of string</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsforeignlibstestwrapper"><a class="header" href="#packagescomponentsforeignlibstestwrapper">packages.<name>.components.foreignlibs.<name>.testWrapper</a></h2>
<p>A command to run for executing tests in checkPhase, which takes the original test command as its arguments.</p>
<p><strong>Type</strong>: list of string</p>
<p><strong>Default</strong>: []</p>
<p><strong>Example</strong>:</p>
<p>&quot;echo&quot;</p>
<h2 id="packagescomponentsforeignlibswritehiefiles"><a class="header" href="#packagescomponentsforeignlibswritehiefiles">packages.<name>.components.foreignlibs.<name>.writeHieFiles</a></h2>
<p>Write component <code>.hie</code> files in the store in a <code>hie</code> output</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: false</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentslibrary"><a class="header" href="#packagescomponentslibrary">packages.<name>.components.library</a></h2>
<p><strong>Type</strong>: null or (submodule)</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentslibraryasmsources"><a class="header" href="#packagescomponentslibraryasmsources">packages.<name>.components.library.asmSources</a></h2>
<p><strong>Type</strong>: list of unspecified value</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentslibrarybuild-tools"><a class="header" href="#packagescomponentslibrarybuild-tools">packages.<name>.components.library.build-tools</a></h2>
<p><strong>Type</strong>: list of unspecified value</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentslibrarybuildable"><a class="header" href="#packagescomponentslibrarybuildable">packages.<name>.components.library.buildable</a></h2>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: true</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentslibrarycsources"><a class="header" href="#packagescomponentslibrarycsources">packages.<name>.components.library.cSources</a></h2>
<p><strong>Type</strong>: list of unspecified value</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentslibrarycmmsources"><a class="header" href="#packagescomponentslibrarycmmsources">packages.<name>.components.library.cmmSources</a></h2>
<p><strong>Type</strong>: list of unspecified value</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentslibraryconfigureallcomponents"><a class="header" href="#packagescomponentslibraryconfigureallcomponents">packages.<name>.components.library.configureAllComponents</a></h2>
<p>If set all the components in the package are configured (useful for cabal-doctest).</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: false</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentslibraryconfigureflags"><a class="header" href="#packagescomponentslibraryconfigureflags">packages.<name>.components.library.configureFlags</a></h2>
<p><strong>Type</strong>: list of string</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentslibrarycontentaddressed"><a class="header" href="#packagescomponentslibrarycontentaddressed">packages.<name>.components.library.contentAddressed</a></h2>
<p>Build content addressed derivation, requires Nix to have experimental feature
<code>ca-derivations</code> enabled.</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: false</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentslibrarycxxsources"><a class="header" href="#packagescomponentslibrarycxxsources">packages.<name>.components.library.cxxSources</a></h2>
<p><strong>Type</strong>: list of unspecified value</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentslibrarydepends"><a class="header" href="#packagescomponentslibrarydepends">packages.<name>.components.library.depends</a></h2>
<p><strong>Type</strong>: list of unspecified value</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentslibrarydocheck"><a class="header" href="#packagescomponentslibrarydocheck">packages.<name>.components.library.doCheck</a></h2>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: true</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentslibrarydocoverage"><a class="header" href="#packagescomponentslibrarydocoverage">packages.<name>.components.library.doCoverage</a></h2>
<p>Enable production of test coverage reports.</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: false</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentslibrarydocrosscheck"><a class="header" href="#packagescomponentslibrarydocrosscheck">packages.<name>.components.library.doCrossCheck</a></h2>
<p>Run doCheck also in cross compilation settings. This can be tricky as the test logic must know how to run the tests on the target.</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: false</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentslibrarydoexactconfig"><a class="header" href="#packagescomponentslibrarydoexactconfig">packages.<name>.components.library.doExactConfig</a></h2>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: false</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentslibrarydohaddock"><a class="header" href="#packagescomponentslibrarydohaddock">packages.<name>.components.library.doHaddock</a></h2>
<p>Enable building of the Haddock documentation from the annotated Haskell source code.</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: true</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentslibrarydohoogle"><a class="header" href="#packagescomponentslibrarydohoogle">packages.<name>.components.library.doHoogle</a></h2>
<p>Also build a hoogle index.</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: true</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentslibrarydohyperlinksource"><a class="header" href="#packagescomponentslibrarydohyperlinksource">packages.<name>.components.library.doHyperlinkSource</a></h2>
<p>Link documentation to the source code.</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: true</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentslibrarydoquickjump"><a class="header" href="#packagescomponentslibrarydoquickjump">packages.<name>.components.library.doQuickjump</a></h2>
<p>Generate an index for interactive documentation navigation.</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: true</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentslibrarydontpatchelf"><a class="header" href="#packagescomponentslibrarydontpatchelf">packages.<name>.components.library.dontPatchELF</a></h2>
<p>If set, the patchelf command is not used to remove unnecessary RPATH entries. Only applies to Linux.</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: true</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentslibrarydontstrip"><a class="header" href="#packagescomponentslibrarydontstrip">packages.<name>.components.library.dontStrip</a></h2>
<p>If set, libraries and executables are not stripped.</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: true</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentslibraryenabledeadcodeelimination"><a class="header" href="#packagescomponentslibraryenabledeadcodeelimination">packages.<name>.components.library.enableDeadCodeElimination</a></h2>
<p>If set, enables split sections for link-time dead-code stripping. Only applies to Linux</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: true</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentslibraryenablelibraryprofiling"><a class="header" href="#packagescomponentslibraryenablelibraryprofiling">packages.<name>.components.library.enableLibraryProfiling</a></h2>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: false</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentslibraryenableprofiling"><a class="header" href="#packagescomponentslibraryenableprofiling">packages.<name>.components.library.enableProfiling</a></h2>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: false</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentslibraryenableseparatedataoutput"><a class="header" href="#packagescomponentslibraryenableseparatedataoutput">packages.<name>.components.library.enableSeparateDataOutput</a></h2>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: true</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentslibraryenableshared"><a class="header" href="#packagescomponentslibraryenableshared">packages.<name>.components.library.enableShared</a></h2>
<p>If set, enables building shared libraries.</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: true</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentslibraryenablestatic"><a class="header" href="#packagescomponentslibraryenablestatic">packages.<name>.components.library.enableStatic</a></h2>
<p>If set, enables building static libraries and executables.</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: true</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentslibraryextrasrcfiles"><a class="header" href="#packagescomponentslibraryextrasrcfiles">packages.<name>.components.library.extraSrcFiles</a></h2>
<p><strong>Type</strong>: list of unspecified value</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentslibraryframeworks"><a class="header" href="#packagescomponentslibraryframeworks">packages.<name>.components.library.frameworks</a></h2>
<p><strong>Type</strong>: list of package</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentslibraryghcoptions"><a class="header" href="#packagescomponentslibraryghcoptions">packages.<name>.components.library.ghcOptions</a></h2>
<p><strong>Type</strong>: list of string</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentslibraryhardeningdisable"><a class="header" href="#packagescomponentslibraryhardeningdisable">packages.<name>.components.library.hardeningDisable</a></h2>
<p><strong>Type</strong>: list of string</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentslibraryhssourcedirs"><a class="header" href="#packagescomponentslibraryhssourcedirs">packages.<name>.components.library.hsSourceDirs</a></h2>
<p><strong>Type</strong>: list of unspecified value</p>
<p><strong>Default</strong>: [&quot;.&quot;]</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentslibraryincludedirs"><a class="header" href="#packagescomponentslibraryincludedirs">packages.<name>.components.library.includeDirs</a></h2>
<p><strong>Type</strong>: list of unspecified value</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentslibraryincludes"><a class="header" href="#packagescomponentslibraryincludes">packages.<name>.components.library.includes</a></h2>
<p><strong>Type</strong>: list of unspecified value</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentslibraryjssources"><a class="header" href="#packagescomponentslibraryjssources">packages.<name>.components.library.jsSources</a></h2>
<p><strong>Type</strong>: list of unspecified value</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentslibrarykeepsource"><a class="header" href="#packagescomponentslibrarykeepsource">packages.<name>.components.library.keepSource</a></h2>
<p>Keep component source in the store in a <code>source</code> output</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: false</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentslibrarylibs"><a class="header" href="#packagescomponentslibrarylibs">packages.<name>.components.library.libs</a></h2>
<p><strong>Type</strong>: list of (null or package or list of package)</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentslibrarymainpath"><a class="header" href="#packagescomponentslibrarymainpath">packages.<name>.components.library.mainPath</a></h2>
<p><strong>Type</strong>: list of unspecified value</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentslibrarymodules"><a class="header" href="#packagescomponentslibrarymodules">packages.<name>.components.library.modules</a></h2>
<p><strong>Type</strong>: list of unspecified value</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentslibrarypkgconfig"><a class="header" href="#packagescomponentslibrarypkgconfig">packages.<name>.components.library.pkgconfig</a></h2>
<p><strong>Type</strong>: list of list of package</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentslibraryplanned"><a class="header" href="#packagescomponentslibraryplanned">packages.<name>.components.library.planned</a></h2>
<p>Set to true by <code>plan-to-nix</code> for any component that was included in the <code>plan.json</code> file.</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: false</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentslibraryplatforms"><a class="header" href="#packagescomponentslibraryplatforms">packages.<name>.components.library.platforms</a></h2>
<p><strong>Type</strong>: null or (list of unspecified value)</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentslibraryplugins"><a class="header" href="#packagescomponentslibraryplugins">packages.<name>.components.library.plugins</a></h2>
<p><strong>Type</strong>: list of (submodule)</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentslibrarypluginsargs"><a class="header" href="#packagescomponentslibrarypluginsargs">packages.<name>.components.library.plugins.*.args</a></h2>
<p><strong>Type</strong>: list of string</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentslibrarypluginslibrary"><a class="header" href="#packagescomponentslibrarypluginslibrary">packages.<name>.components.library.plugins.*.library</a></h2>
<p><strong>Type</strong>: unspecified value</p>
<p><strong>No Default</strong></p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentslibrarypluginsmodulename"><a class="header" href="#packagescomponentslibrarypluginsmodulename">packages.<name>.components.library.plugins.*.moduleName</a></h2>
<p><strong>Type</strong>: string</p>
<p><strong>No Default</strong></p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentslibrarypostbuild"><a class="header" href="#packagescomponentslibrarypostbuild">packages.<name>.components.library.postBuild</a></h2>
<p><strong>Type</strong>: null or string</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentslibrarypostcheck"><a class="header" href="#packagescomponentslibrarypostcheck">packages.<name>.components.library.postCheck</a></h2>
<p><strong>Type</strong>: null or string</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentslibrarypostconfigure"><a class="header" href="#packagescomponentslibrarypostconfigure">packages.<name>.components.library.postConfigure</a></h2>
<p><strong>Type</strong>: null or string</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentslibraryposthaddock"><a class="header" href="#packagescomponentslibraryposthaddock">packages.<name>.components.library.postHaddock</a></h2>
<p><strong>Type</strong>: null or string</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentslibrarypostinstall"><a class="header" href="#packagescomponentslibrarypostinstall">packages.<name>.components.library.postInstall</a></h2>
<p><strong>Type</strong>: null or string</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentslibrarypostunpack"><a class="header" href="#packagescomponentslibrarypostunpack">packages.<name>.components.library.postUnpack</a></h2>
<p><strong>Type</strong>: null or string</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentslibraryprebuild"><a class="header" href="#packagescomponentslibraryprebuild">packages.<name>.components.library.preBuild</a></h2>
<p><strong>Type</strong>: null or string</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentslibraryprecheck"><a class="header" href="#packagescomponentslibraryprecheck">packages.<name>.components.library.preCheck</a></h2>
<p><strong>Type</strong>: null or string</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentslibrarypreconfigure"><a class="header" href="#packagescomponentslibrarypreconfigure">packages.<name>.components.library.preConfigure</a></h2>
<p><strong>Type</strong>: null or string</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentslibraryprehaddock"><a class="header" href="#packagescomponentslibraryprehaddock">packages.<name>.components.library.preHaddock</a></h2>
<p><strong>Type</strong>: null or string</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentslibrarypreinstall"><a class="header" href="#packagescomponentslibrarypreinstall">packages.<name>.components.library.preInstall</a></h2>
<p><strong>Type</strong>: null or string</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentslibrarypreunpack"><a class="header" href="#packagescomponentslibrarypreunpack">packages.<name>.components.library.preUnpack</a></h2>
<p><strong>Type</strong>: null or strings concatenated with &quot;\n&quot;</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentslibraryprofilingdetail"><a class="header" href="#packagescomponentslibraryprofilingdetail">packages.<name>.components.library.profilingDetail</a></h2>
<p><strong>Type</strong>: null or string</p>
<p><strong>Default</strong>: &quot;default&quot;</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentslibrarysetupbuildflags"><a class="header" href="#packagescomponentslibrarysetupbuildflags">packages.<name>.components.library.setupBuildFlags</a></h2>
<p><strong>Type</strong>: list of string</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentslibrarysetuphaddockflags"><a class="header" href="#packagescomponentslibrarysetuphaddockflags">packages.<name>.components.library.setupHaddockFlags</a></h2>
<p><strong>Type</strong>: list of string</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentslibrarysetupinstallflags"><a class="header" href="#packagescomponentslibrarysetupinstallflags">packages.<name>.components.library.setupInstallFlags</a></h2>
<p><strong>Type</strong>: list of string</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentslibraryshellhook"><a class="header" href="#packagescomponentslibraryshellhook">packages.<name>.components.library.shellHook</a></h2>
<p>Hook to run when entering a shell</p>
<p><strong>Type</strong>: unspecified value</p>
<p><strong>Default</strong>: &quot;&quot;</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentslibrarytestflags"><a class="header" href="#packagescomponentslibrarytestflags">packages.<name>.components.library.testFlags</a></h2>
<p><strong>Type</strong>: list of string</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentslibrarytestwrapper"><a class="header" href="#packagescomponentslibrarytestwrapper">packages.<name>.components.library.testWrapper</a></h2>
<p>A command to run for executing tests in checkPhase, which takes the original test command as its arguments.</p>
<p><strong>Type</strong>: list of string</p>
<p><strong>Default</strong>: []</p>
<p><strong>Example</strong>:</p>
<p>&quot;echo&quot;</p>
<h2 id="packagescomponentslibrarywritehiefiles"><a class="header" href="#packagescomponentslibrarywritehiefiles">packages.<name>.components.library.writeHieFiles</a></h2>
<p>Write component <code>.hie</code> files in the store in a <code>hie</code> output</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: false</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssetup"><a class="header" href="#packagescomponentssetup">packages.<name>.components.setup</a></h2>
<p><strong>Type</strong>: null or (submodule)</p>
<p><strong>Default</strong>: {&quot;asmSources&quot;:[],&quot;cSources&quot;:[],&quot;cmmSources&quot;:[],&quot;cxxSources&quot;:[],&quot;depends&quot;:[],&quot;doExactConfig&quot;:false,&quot;extraSrcFiles&quot;:[&quot;Setup.hs&quot;,&quot;Setup.lhs&quot;],&quot;frameworks&quot;:[],&quot;hsSourceDirs&quot;:[&quot;setup-src&quot;],&quot;includeDirs&quot;:[],&quot;jsSources&quot;:[],&quot;libs&quot;:[],&quot;platforms&quot;:null}</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssetupasmsources"><a class="header" href="#packagescomponentssetupasmsources">packages.<name>.components.setup.asmSources</a></h2>
<p><strong>Type</strong>: list of unspecified value</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssetupbuild-tools"><a class="header" href="#packagescomponentssetupbuild-tools">packages.<name>.components.setup.build-tools</a></h2>
<p><strong>Type</strong>: list of unspecified value</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssetupbuildable"><a class="header" href="#packagescomponentssetupbuildable">packages.<name>.components.setup.buildable</a></h2>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: true</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssetupcsources"><a class="header" href="#packagescomponentssetupcsources">packages.<name>.components.setup.cSources</a></h2>
<p><strong>Type</strong>: list of unspecified value</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssetupcmmsources"><a class="header" href="#packagescomponentssetupcmmsources">packages.<name>.components.setup.cmmSources</a></h2>
<p><strong>Type</strong>: list of unspecified value</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssetupconfigureallcomponents"><a class="header" href="#packagescomponentssetupconfigureallcomponents">packages.<name>.components.setup.configureAllComponents</a></h2>
<p>If set all the components in the package are configured (useful for cabal-doctest).</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: false</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssetupconfigureflags"><a class="header" href="#packagescomponentssetupconfigureflags">packages.<name>.components.setup.configureFlags</a></h2>
<p><strong>Type</strong>: list of string</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssetupcontentaddressed"><a class="header" href="#packagescomponentssetupcontentaddressed">packages.<name>.components.setup.contentAddressed</a></h2>
<p>Build content addressed derivation, requires Nix to have experimental feature
<code>ca-derivations</code> enabled.</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: false</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssetupcxxsources"><a class="header" href="#packagescomponentssetupcxxsources">packages.<name>.components.setup.cxxSources</a></h2>
<p><strong>Type</strong>: list of unspecified value</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssetupdepends"><a class="header" href="#packagescomponentssetupdepends">packages.<name>.components.setup.depends</a></h2>
<p><strong>Type</strong>: list of unspecified value</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssetupdocheck"><a class="header" href="#packagescomponentssetupdocheck">packages.<name>.components.setup.doCheck</a></h2>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: true</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssetupdocoverage"><a class="header" href="#packagescomponentssetupdocoverage">packages.<name>.components.setup.doCoverage</a></h2>
<p>Enable production of test coverage reports.</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: false</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssetupdocrosscheck"><a class="header" href="#packagescomponentssetupdocrosscheck">packages.<name>.components.setup.doCrossCheck</a></h2>
<p>Run doCheck also in cross compilation settings. This can be tricky as the test logic must know how to run the tests on the target.</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: false</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssetupdoexactconfig"><a class="header" href="#packagescomponentssetupdoexactconfig">packages.<name>.components.setup.doExactConfig</a></h2>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: false</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssetupdohaddock"><a class="header" href="#packagescomponentssetupdohaddock">packages.<name>.components.setup.doHaddock</a></h2>
<p>Enable building of the Haddock documentation from the annotated Haskell source code.</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: true</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssetupdohoogle"><a class="header" href="#packagescomponentssetupdohoogle">packages.<name>.components.setup.doHoogle</a></h2>
<p>Also build a hoogle index.</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: true</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssetupdohyperlinksource"><a class="header" href="#packagescomponentssetupdohyperlinksource">packages.<name>.components.setup.doHyperlinkSource</a></h2>
<p>Link documentation to the source code.</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: true</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssetupdoquickjump"><a class="header" href="#packagescomponentssetupdoquickjump">packages.<name>.components.setup.doQuickjump</a></h2>
<p>Generate an index for interactive documentation navigation.</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: true</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssetupdontpatchelf"><a class="header" href="#packagescomponentssetupdontpatchelf">packages.<name>.components.setup.dontPatchELF</a></h2>
<p>If set, the patchelf command is not used to remove unnecessary RPATH entries. Only applies to Linux.</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: true</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssetupdontstrip"><a class="header" href="#packagescomponentssetupdontstrip">packages.<name>.components.setup.dontStrip</a></h2>
<p>If set, libraries and executables are not stripped.</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: true</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssetupenabledeadcodeelimination"><a class="header" href="#packagescomponentssetupenabledeadcodeelimination">packages.<name>.components.setup.enableDeadCodeElimination</a></h2>
<p>If set, enables split sections for link-time dead-code stripping. Only applies to Linux</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: true</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssetupenablelibraryprofiling"><a class="header" href="#packagescomponentssetupenablelibraryprofiling">packages.<name>.components.setup.enableLibraryProfiling</a></h2>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: false</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssetupenableprofiling"><a class="header" href="#packagescomponentssetupenableprofiling">packages.<name>.components.setup.enableProfiling</a></h2>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: false</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssetupenableseparatedataoutput"><a class="header" href="#packagescomponentssetupenableseparatedataoutput">packages.<name>.components.setup.enableSeparateDataOutput</a></h2>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: true</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssetupenableshared"><a class="header" href="#packagescomponentssetupenableshared">packages.<name>.components.setup.enableShared</a></h2>
<p>If set, enables building shared libraries.</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: true</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssetupenablestatic"><a class="header" href="#packagescomponentssetupenablestatic">packages.<name>.components.setup.enableStatic</a></h2>
<p>If set, enables building static libraries and executables.</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: true</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssetupextrasrcfiles"><a class="header" href="#packagescomponentssetupextrasrcfiles">packages.<name>.components.setup.extraSrcFiles</a></h2>
<p><strong>Type</strong>: list of unspecified value</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssetupframeworks"><a class="header" href="#packagescomponentssetupframeworks">packages.<name>.components.setup.frameworks</a></h2>
<p><strong>Type</strong>: list of package</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssetupghcoptions"><a class="header" href="#packagescomponentssetupghcoptions">packages.<name>.components.setup.ghcOptions</a></h2>
<p><strong>Type</strong>: list of string</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssetuphardeningdisable"><a class="header" href="#packagescomponentssetuphardeningdisable">packages.<name>.components.setup.hardeningDisable</a></h2>
<p><strong>Type</strong>: list of string</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssetuphssourcedirs"><a class="header" href="#packagescomponentssetuphssourcedirs">packages.<name>.components.setup.hsSourceDirs</a></h2>
<p><strong>Type</strong>: list of unspecified value</p>
<p><strong>Default</strong>: [&quot;.&quot;]</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssetupincludedirs"><a class="header" href="#packagescomponentssetupincludedirs">packages.<name>.components.setup.includeDirs</a></h2>
<p><strong>Type</strong>: list of unspecified value</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssetupincludes"><a class="header" href="#packagescomponentssetupincludes">packages.<name>.components.setup.includes</a></h2>
<p><strong>Type</strong>: list of unspecified value</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssetupjssources"><a class="header" href="#packagescomponentssetupjssources">packages.<name>.components.setup.jsSources</a></h2>
<p><strong>Type</strong>: list of unspecified value</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssetupkeepsource"><a class="header" href="#packagescomponentssetupkeepsource">packages.<name>.components.setup.keepSource</a></h2>
<p>Keep component source in the store in a <code>source</code> output</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: false</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssetuplibs"><a class="header" href="#packagescomponentssetuplibs">packages.<name>.components.setup.libs</a></h2>
<p><strong>Type</strong>: list of (null or package or list of package)</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssetupmainpath"><a class="header" href="#packagescomponentssetupmainpath">packages.<name>.components.setup.mainPath</a></h2>
<p><strong>Type</strong>: list of unspecified value</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssetupmodules"><a class="header" href="#packagescomponentssetupmodules">packages.<name>.components.setup.modules</a></h2>
<p><strong>Type</strong>: list of unspecified value</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssetuppkgconfig"><a class="header" href="#packagescomponentssetuppkgconfig">packages.<name>.components.setup.pkgconfig</a></h2>
<p><strong>Type</strong>: list of list of package</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssetupplanned"><a class="header" href="#packagescomponentssetupplanned">packages.<name>.components.setup.planned</a></h2>
<p>Set to true by <code>plan-to-nix</code> for any component that was included in the <code>plan.json</code> file.</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: false</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssetupplatforms"><a class="header" href="#packagescomponentssetupplatforms">packages.<name>.components.setup.platforms</a></h2>
<p><strong>Type</strong>: null or (list of unspecified value)</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssetupplugins"><a class="header" href="#packagescomponentssetupplugins">packages.<name>.components.setup.plugins</a></h2>
<p><strong>Type</strong>: list of (submodule)</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssetuppluginsargs"><a class="header" href="#packagescomponentssetuppluginsargs">packages.<name>.components.setup.plugins.*.args</a></h2>
<p><strong>Type</strong>: list of string</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssetuppluginslibrary"><a class="header" href="#packagescomponentssetuppluginslibrary">packages.<name>.components.setup.plugins.*.library</a></h2>
<p><strong>Type</strong>: unspecified value</p>
<p><strong>No Default</strong></p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssetuppluginsmodulename"><a class="header" href="#packagescomponentssetuppluginsmodulename">packages.<name>.components.setup.plugins.*.moduleName</a></h2>
<p><strong>Type</strong>: string</p>
<p><strong>No Default</strong></p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssetuppostbuild"><a class="header" href="#packagescomponentssetuppostbuild">packages.<name>.components.setup.postBuild</a></h2>
<p><strong>Type</strong>: null or string</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssetuppostcheck"><a class="header" href="#packagescomponentssetuppostcheck">packages.<name>.components.setup.postCheck</a></h2>
<p><strong>Type</strong>: null or string</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssetuppostconfigure"><a class="header" href="#packagescomponentssetuppostconfigure">packages.<name>.components.setup.postConfigure</a></h2>
<p><strong>Type</strong>: null or string</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssetupposthaddock"><a class="header" href="#packagescomponentssetupposthaddock">packages.<name>.components.setup.postHaddock</a></h2>
<p><strong>Type</strong>: null or string</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssetuppostinstall"><a class="header" href="#packagescomponentssetuppostinstall">packages.<name>.components.setup.postInstall</a></h2>
<p><strong>Type</strong>: null or string</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssetuppostunpack"><a class="header" href="#packagescomponentssetuppostunpack">packages.<name>.components.setup.postUnpack</a></h2>
<p><strong>Type</strong>: null or string</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssetupprebuild"><a class="header" href="#packagescomponentssetupprebuild">packages.<name>.components.setup.preBuild</a></h2>
<p><strong>Type</strong>: null or string</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssetupprecheck"><a class="header" href="#packagescomponentssetupprecheck">packages.<name>.components.setup.preCheck</a></h2>
<p><strong>Type</strong>: null or string</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssetuppreconfigure"><a class="header" href="#packagescomponentssetuppreconfigure">packages.<name>.components.setup.preConfigure</a></h2>
<p><strong>Type</strong>: null or string</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssetupprehaddock"><a class="header" href="#packagescomponentssetupprehaddock">packages.<name>.components.setup.preHaddock</a></h2>
<p><strong>Type</strong>: null or string</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssetuppreinstall"><a class="header" href="#packagescomponentssetuppreinstall">packages.<name>.components.setup.preInstall</a></h2>
<p><strong>Type</strong>: null or string</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssetuppreunpack"><a class="header" href="#packagescomponentssetuppreunpack">packages.<name>.components.setup.preUnpack</a></h2>
<p><strong>Type</strong>: null or strings concatenated with &quot;\n&quot;</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssetupprofilingdetail"><a class="header" href="#packagescomponentssetupprofilingdetail">packages.<name>.components.setup.profilingDetail</a></h2>
<p><strong>Type</strong>: null or string</p>
<p><strong>Default</strong>: &quot;default&quot;</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssetupsetupbuildflags"><a class="header" href="#packagescomponentssetupsetupbuildflags">packages.<name>.components.setup.setupBuildFlags</a></h2>
<p><strong>Type</strong>: list of string</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssetupsetuphaddockflags"><a class="header" href="#packagescomponentssetupsetuphaddockflags">packages.<name>.components.setup.setupHaddockFlags</a></h2>
<p><strong>Type</strong>: list of string</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssetupsetupinstallflags"><a class="header" href="#packagescomponentssetupsetupinstallflags">packages.<name>.components.setup.setupInstallFlags</a></h2>
<p><strong>Type</strong>: list of string</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssetupshellhook"><a class="header" href="#packagescomponentssetupshellhook">packages.<name>.components.setup.shellHook</a></h2>
<p>Hook to run when entering a shell</p>
<p><strong>Type</strong>: unspecified value</p>
<p><strong>Default</strong>: &quot;&quot;</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssetuptestflags"><a class="header" href="#packagescomponentssetuptestflags">packages.<name>.components.setup.testFlags</a></h2>
<p><strong>Type</strong>: list of string</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssetuptestwrapper"><a class="header" href="#packagescomponentssetuptestwrapper">packages.<name>.components.setup.testWrapper</a></h2>
<p>A command to run for executing tests in checkPhase, which takes the original test command as its arguments.</p>
<p><strong>Type</strong>: list of string</p>
<p><strong>Default</strong>: []</p>
<p><strong>Example</strong>:</p>
<p>&quot;echo&quot;</p>
<h2 id="packagescomponentssetupwritehiefiles"><a class="header" href="#packagescomponentssetupwritehiefiles">packages.<name>.components.setup.writeHieFiles</a></h2>
<p>Write component <code>.hie</code> files in the store in a <code>hie</code> output</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: false</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssublibs"><a class="header" href="#packagescomponentssublibs">packages.<name>.components.sublibs</a></h2>
<p><strong>Type</strong>: attribute set of (submodule)</p>
<p><strong>Default</strong>: {}</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssublibsasmsources"><a class="header" href="#packagescomponentssublibsasmsources">packages.<name>.components.sublibs.<name>.asmSources</a></h2>
<p><strong>Type</strong>: list of unspecified value</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssublibsbuild-tools"><a class="header" href="#packagescomponentssublibsbuild-tools">packages.<name>.components.sublibs.<name>.build-tools</a></h2>
<p><strong>Type</strong>: list of unspecified value</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssublibsbuildable"><a class="header" href="#packagescomponentssublibsbuildable">packages.<name>.components.sublibs.<name>.buildable</a></h2>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: true</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssublibscsources"><a class="header" href="#packagescomponentssublibscsources">packages.<name>.components.sublibs.<name>.cSources</a></h2>
<p><strong>Type</strong>: list of unspecified value</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssublibscmmsources"><a class="header" href="#packagescomponentssublibscmmsources">packages.<name>.components.sublibs.<name>.cmmSources</a></h2>
<p><strong>Type</strong>: list of unspecified value</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssublibsconfigureallcomponents"><a class="header" href="#packagescomponentssublibsconfigureallcomponents">packages.<name>.components.sublibs.<name>.configureAllComponents</a></h2>
<p>If set all the components in the package are configured (useful for cabal-doctest).</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: false</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssublibsconfigureflags"><a class="header" href="#packagescomponentssublibsconfigureflags">packages.<name>.components.sublibs.<name>.configureFlags</a></h2>
<p><strong>Type</strong>: list of string</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssublibscontentaddressed"><a class="header" href="#packagescomponentssublibscontentaddressed">packages.<name>.components.sublibs.<name>.contentAddressed</a></h2>
<p>Build content addressed derivation, requires Nix to have experimental feature
<code>ca-derivations</code> enabled.</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: false</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssublibscxxsources"><a class="header" href="#packagescomponentssublibscxxsources">packages.<name>.components.sublibs.<name>.cxxSources</a></h2>
<p><strong>Type</strong>: list of unspecified value</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssublibsdepends"><a class="header" href="#packagescomponentssublibsdepends">packages.<name>.components.sublibs.<name>.depends</a></h2>
<p><strong>Type</strong>: list of unspecified value</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssublibsdocheck"><a class="header" href="#packagescomponentssublibsdocheck">packages.<name>.components.sublibs.<name>.doCheck</a></h2>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: true</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssublibsdocoverage"><a class="header" href="#packagescomponentssublibsdocoverage">packages.<name>.components.sublibs.<name>.doCoverage</a></h2>
<p>Enable production of test coverage reports.</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: false</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssublibsdocrosscheck"><a class="header" href="#packagescomponentssublibsdocrosscheck">packages.<name>.components.sublibs.<name>.doCrossCheck</a></h2>
<p>Run doCheck also in cross compilation settings. This can be tricky as the test logic must know how to run the tests on the target.</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: false</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssublibsdoexactconfig"><a class="header" href="#packagescomponentssublibsdoexactconfig">packages.<name>.components.sublibs.<name>.doExactConfig</a></h2>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: false</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssublibsdohaddock"><a class="header" href="#packagescomponentssublibsdohaddock">packages.<name>.components.sublibs.<name>.doHaddock</a></h2>
<p>Enable building of the Haddock documentation from the annotated Haskell source code.</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: true</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssublibsdohoogle"><a class="header" href="#packagescomponentssublibsdohoogle">packages.<name>.components.sublibs.<name>.doHoogle</a></h2>
<p>Also build a hoogle index.</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: true</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssublibsdohyperlinksource"><a class="header" href="#packagescomponentssublibsdohyperlinksource">packages.<name>.components.sublibs.<name>.doHyperlinkSource</a></h2>
<p>Link documentation to the source code.</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: true</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssublibsdoquickjump"><a class="header" href="#packagescomponentssublibsdoquickjump">packages.<name>.components.sublibs.<name>.doQuickjump</a></h2>
<p>Generate an index for interactive documentation navigation.</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: true</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssublibsdontpatchelf"><a class="header" href="#packagescomponentssublibsdontpatchelf">packages.<name>.components.sublibs.<name>.dontPatchELF</a></h2>
<p>If set, the patchelf command is not used to remove unnecessary RPATH entries. Only applies to Linux.</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: true</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssublibsdontstrip"><a class="header" href="#packagescomponentssublibsdontstrip">packages.<name>.components.sublibs.<name>.dontStrip</a></h2>
<p>If set, libraries and executables are not stripped.</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: true</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssublibsenabledeadcodeelimination"><a class="header" href="#packagescomponentssublibsenabledeadcodeelimination">packages.<name>.components.sublibs.<name>.enableDeadCodeElimination</a></h2>
<p>If set, enables split sections for link-time dead-code stripping. Only applies to Linux</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: true</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssublibsenablelibraryprofiling"><a class="header" href="#packagescomponentssublibsenablelibraryprofiling">packages.<name>.components.sublibs.<name>.enableLibraryProfiling</a></h2>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: false</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssublibsenableprofiling"><a class="header" href="#packagescomponentssublibsenableprofiling">packages.<name>.components.sublibs.<name>.enableProfiling</a></h2>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: false</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssublibsenableseparatedataoutput"><a class="header" href="#packagescomponentssublibsenableseparatedataoutput">packages.<name>.components.sublibs.<name>.enableSeparateDataOutput</a></h2>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: true</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssublibsenableshared"><a class="header" href="#packagescomponentssublibsenableshared">packages.<name>.components.sublibs.<name>.enableShared</a></h2>
<p>If set, enables building shared libraries.</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: true</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssublibsenablestatic"><a class="header" href="#packagescomponentssublibsenablestatic">packages.<name>.components.sublibs.<name>.enableStatic</a></h2>
<p>If set, enables building static libraries and executables.</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: true</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssublibsextrasrcfiles"><a class="header" href="#packagescomponentssublibsextrasrcfiles">packages.<name>.components.sublibs.<name>.extraSrcFiles</a></h2>
<p><strong>Type</strong>: list of unspecified value</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssublibsframeworks"><a class="header" href="#packagescomponentssublibsframeworks">packages.<name>.components.sublibs.<name>.frameworks</a></h2>
<p><strong>Type</strong>: list of package</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssublibsghcoptions"><a class="header" href="#packagescomponentssublibsghcoptions">packages.<name>.components.sublibs.<name>.ghcOptions</a></h2>
<p><strong>Type</strong>: list of string</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssublibshardeningdisable"><a class="header" href="#packagescomponentssublibshardeningdisable">packages.<name>.components.sublibs.<name>.hardeningDisable</a></h2>
<p><strong>Type</strong>: list of string</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssublibshssourcedirs"><a class="header" href="#packagescomponentssublibshssourcedirs">packages.<name>.components.sublibs.<name>.hsSourceDirs</a></h2>
<p><strong>Type</strong>: list of unspecified value</p>
<p><strong>Default</strong>: [&quot;.&quot;]</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssublibsincludedirs"><a class="header" href="#packagescomponentssublibsincludedirs">packages.<name>.components.sublibs.<name>.includeDirs</a></h2>
<p><strong>Type</strong>: list of unspecified value</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssublibsincludes"><a class="header" href="#packagescomponentssublibsincludes">packages.<name>.components.sublibs.<name>.includes</a></h2>
<p><strong>Type</strong>: list of unspecified value</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssublibsjssources"><a class="header" href="#packagescomponentssublibsjssources">packages.<name>.components.sublibs.<name>.jsSources</a></h2>
<p><strong>Type</strong>: list of unspecified value</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssublibskeepsource"><a class="header" href="#packagescomponentssublibskeepsource">packages.<name>.components.sublibs.<name>.keepSource</a></h2>
<p>Keep component source in the store in a <code>source</code> output</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: false</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssublibslibs"><a class="header" href="#packagescomponentssublibslibs">packages.<name>.components.sublibs.<name>.libs</a></h2>
<p><strong>Type</strong>: list of (null or package or list of package)</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssublibsmainpath"><a class="header" href="#packagescomponentssublibsmainpath">packages.<name>.components.sublibs.<name>.mainPath</a></h2>
<p><strong>Type</strong>: list of unspecified value</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssublibsmodules"><a class="header" href="#packagescomponentssublibsmodules">packages.<name>.components.sublibs.<name>.modules</a></h2>
<p><strong>Type</strong>: list of unspecified value</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssublibspkgconfig"><a class="header" href="#packagescomponentssublibspkgconfig">packages.<name>.components.sublibs.<name>.pkgconfig</a></h2>
<p><strong>Type</strong>: list of list of package</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssublibsplanned"><a class="header" href="#packagescomponentssublibsplanned">packages.<name>.components.sublibs.<name>.planned</a></h2>
<p>Set to true by <code>plan-to-nix</code> for any component that was included in the <code>plan.json</code> file.</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: false</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssublibsplatforms"><a class="header" href="#packagescomponentssublibsplatforms">packages.<name>.components.sublibs.<name>.platforms</a></h2>
<p><strong>Type</strong>: null or (list of unspecified value)</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssublibsplugins"><a class="header" href="#packagescomponentssublibsplugins">packages.<name>.components.sublibs.<name>.plugins</a></h2>
<p><strong>Type</strong>: list of (submodule)</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssublibspluginsargs"><a class="header" href="#packagescomponentssublibspluginsargs">packages.<name>.components.sublibs.<name>.plugins.*.args</a></h2>
<p><strong>Type</strong>: list of string</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssublibspluginslibrary"><a class="header" href="#packagescomponentssublibspluginslibrary">packages.<name>.components.sublibs.<name>.plugins.*.library</a></h2>
<p><strong>Type</strong>: unspecified value</p>
<p><strong>No Default</strong></p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssublibspluginsmodulename"><a class="header" href="#packagescomponentssublibspluginsmodulename">packages.<name>.components.sublibs.<name>.plugins.*.moduleName</a></h2>
<p><strong>Type</strong>: string</p>
<p><strong>No Default</strong></p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssublibspostbuild"><a class="header" href="#packagescomponentssublibspostbuild">packages.<name>.components.sublibs.<name>.postBuild</a></h2>
<p><strong>Type</strong>: null or string</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssublibspostcheck"><a class="header" href="#packagescomponentssublibspostcheck">packages.<name>.components.sublibs.<name>.postCheck</a></h2>
<p><strong>Type</strong>: null or string</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssublibspostconfigure"><a class="header" href="#packagescomponentssublibspostconfigure">packages.<name>.components.sublibs.<name>.postConfigure</a></h2>
<p><strong>Type</strong>: null or string</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssublibsposthaddock"><a class="header" href="#packagescomponentssublibsposthaddock">packages.<name>.components.sublibs.<name>.postHaddock</a></h2>
<p><strong>Type</strong>: null or string</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssublibspostinstall"><a class="header" href="#packagescomponentssublibspostinstall">packages.<name>.components.sublibs.<name>.postInstall</a></h2>
<p><strong>Type</strong>: null or string</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssublibspostunpack"><a class="header" href="#packagescomponentssublibspostunpack">packages.<name>.components.sublibs.<name>.postUnpack</a></h2>
<p><strong>Type</strong>: null or string</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssublibsprebuild"><a class="header" href="#packagescomponentssublibsprebuild">packages.<name>.components.sublibs.<name>.preBuild</a></h2>
<p><strong>Type</strong>: null or string</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssublibsprecheck"><a class="header" href="#packagescomponentssublibsprecheck">packages.<name>.components.sublibs.<name>.preCheck</a></h2>
<p><strong>Type</strong>: null or string</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssublibspreconfigure"><a class="header" href="#packagescomponentssublibspreconfigure">packages.<name>.components.sublibs.<name>.preConfigure</a></h2>
<p><strong>Type</strong>: null or string</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssublibsprehaddock"><a class="header" href="#packagescomponentssublibsprehaddock">packages.<name>.components.sublibs.<name>.preHaddock</a></h2>
<p><strong>Type</strong>: null or string</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssublibspreinstall"><a class="header" href="#packagescomponentssublibspreinstall">packages.<name>.components.sublibs.<name>.preInstall</a></h2>
<p><strong>Type</strong>: null or string</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssublibspreunpack"><a class="header" href="#packagescomponentssublibspreunpack">packages.<name>.components.sublibs.<name>.preUnpack</a></h2>
<p><strong>Type</strong>: null or strings concatenated with &quot;\n&quot;</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssublibsprofilingdetail"><a class="header" href="#packagescomponentssublibsprofilingdetail">packages.<name>.components.sublibs.<name>.profilingDetail</a></h2>
<p><strong>Type</strong>: null or string</p>
<p><strong>Default</strong>: &quot;default&quot;</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssublibssetupbuildflags"><a class="header" href="#packagescomponentssublibssetupbuildflags">packages.<name>.components.sublibs.<name>.setupBuildFlags</a></h2>
<p><strong>Type</strong>: list of string</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssublibssetuphaddockflags"><a class="header" href="#packagescomponentssublibssetuphaddockflags">packages.<name>.components.sublibs.<name>.setupHaddockFlags</a></h2>
<p><strong>Type</strong>: list of string</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssublibssetupinstallflags"><a class="header" href="#packagescomponentssublibssetupinstallflags">packages.<name>.components.sublibs.<name>.setupInstallFlags</a></h2>
<p><strong>Type</strong>: list of string</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssublibsshellhook"><a class="header" href="#packagescomponentssublibsshellhook">packages.<name>.components.sublibs.<name>.shellHook</a></h2>
<p>Hook to run when entering a shell</p>
<p><strong>Type</strong>: unspecified value</p>
<p><strong>Default</strong>: &quot;&quot;</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssublibstestflags"><a class="header" href="#packagescomponentssublibstestflags">packages.<name>.components.sublibs.<name>.testFlags</a></h2>
<p><strong>Type</strong>: list of string</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentssublibstestwrapper"><a class="header" href="#packagescomponentssublibstestwrapper">packages.<name>.components.sublibs.<name>.testWrapper</a></h2>
<p>A command to run for executing tests in checkPhase, which takes the original test command as its arguments.</p>
<p><strong>Type</strong>: list of string</p>
<p><strong>Default</strong>: []</p>
<p><strong>Example</strong>:</p>
<p>&quot;echo&quot;</p>
<h2 id="packagescomponentssublibswritehiefiles"><a class="header" href="#packagescomponentssublibswritehiefiles">packages.<name>.components.sublibs.<name>.writeHieFiles</a></h2>
<p>Write component <code>.hie</code> files in the store in a <code>hie</code> output</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: false</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentstests"><a class="header" href="#packagescomponentstests">packages.<name>.components.tests</a></h2>
<p><strong>Type</strong>: attribute set of (submodule)</p>
<p><strong>Default</strong>: {}</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentstestsasmsources"><a class="header" href="#packagescomponentstestsasmsources">packages.<name>.components.tests.<name>.asmSources</a></h2>
<p><strong>Type</strong>: list of unspecified value</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentstestsbuild-tools"><a class="header" href="#packagescomponentstestsbuild-tools">packages.<name>.components.tests.<name>.build-tools</a></h2>
<p><strong>Type</strong>: list of unspecified value</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentstestsbuildable"><a class="header" href="#packagescomponentstestsbuildable">packages.<name>.components.tests.<name>.buildable</a></h2>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: true</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentstestscsources"><a class="header" href="#packagescomponentstestscsources">packages.<name>.components.tests.<name>.cSources</a></h2>
<p><strong>Type</strong>: list of unspecified value</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentstestscmmsources"><a class="header" href="#packagescomponentstestscmmsources">packages.<name>.components.tests.<name>.cmmSources</a></h2>
<p><strong>Type</strong>: list of unspecified value</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentstestsconfigureallcomponents"><a class="header" href="#packagescomponentstestsconfigureallcomponents">packages.<name>.components.tests.<name>.configureAllComponents</a></h2>
<p>If set all the components in the package are configured (useful for cabal-doctest).</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: false</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentstestsconfigureflags"><a class="header" href="#packagescomponentstestsconfigureflags">packages.<name>.components.tests.<name>.configureFlags</a></h2>
<p><strong>Type</strong>: list of string</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentstestscontentaddressed"><a class="header" href="#packagescomponentstestscontentaddressed">packages.<name>.components.tests.<name>.contentAddressed</a></h2>
<p>Build content addressed derivation, requires Nix to have experimental feature
<code>ca-derivations</code> enabled.</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: false</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentstestscxxsources"><a class="header" href="#packagescomponentstestscxxsources">packages.<name>.components.tests.<name>.cxxSources</a></h2>
<p><strong>Type</strong>: list of unspecified value</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentstestsdepends"><a class="header" href="#packagescomponentstestsdepends">packages.<name>.components.tests.<name>.depends</a></h2>
<p><strong>Type</strong>: list of unspecified value</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentstestsdocheck"><a class="header" href="#packagescomponentstestsdocheck">packages.<name>.components.tests.<name>.doCheck</a></h2>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: true</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentstestsdocoverage"><a class="header" href="#packagescomponentstestsdocoverage">packages.<name>.components.tests.<name>.doCoverage</a></h2>
<p>Enable production of test coverage reports.</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: false</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentstestsdocrosscheck"><a class="header" href="#packagescomponentstestsdocrosscheck">packages.<name>.components.tests.<name>.doCrossCheck</a></h2>
<p>Run doCheck also in cross compilation settings. This can be tricky as the test logic must know how to run the tests on the target.</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: false</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentstestsdoexactconfig"><a class="header" href="#packagescomponentstestsdoexactconfig">packages.<name>.components.tests.<name>.doExactConfig</a></h2>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: false</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentstestsdohaddock"><a class="header" href="#packagescomponentstestsdohaddock">packages.<name>.components.tests.<name>.doHaddock</a></h2>
<p>Enable building of the Haddock documentation from the annotated Haskell source code.</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: true</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentstestsdohoogle"><a class="header" href="#packagescomponentstestsdohoogle">packages.<name>.components.tests.<name>.doHoogle</a></h2>
<p>Also build a hoogle index.</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: true</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentstestsdohyperlinksource"><a class="header" href="#packagescomponentstestsdohyperlinksource">packages.<name>.components.tests.<name>.doHyperlinkSource</a></h2>
<p>Link documentation to the source code.</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: true</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentstestsdoquickjump"><a class="header" href="#packagescomponentstestsdoquickjump">packages.<name>.components.tests.<name>.doQuickjump</a></h2>
<p>Generate an index for interactive documentation navigation.</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: true</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentstestsdontpatchelf"><a class="header" href="#packagescomponentstestsdontpatchelf">packages.<name>.components.tests.<name>.dontPatchELF</a></h2>
<p>If set, the patchelf command is not used to remove unnecessary RPATH entries. Only applies to Linux.</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: true</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentstestsdontstrip"><a class="header" href="#packagescomponentstestsdontstrip">packages.<name>.components.tests.<name>.dontStrip</a></h2>
<p>If set, libraries and executables are not stripped.</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: true</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentstestsenabledeadcodeelimination"><a class="header" href="#packagescomponentstestsenabledeadcodeelimination">packages.<name>.components.tests.<name>.enableDeadCodeElimination</a></h2>
<p>If set, enables split sections for link-time dead-code stripping. Only applies to Linux</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: true</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentstestsenablelibraryprofiling"><a class="header" href="#packagescomponentstestsenablelibraryprofiling">packages.<name>.components.tests.<name>.enableLibraryProfiling</a></h2>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: false</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentstestsenableprofiling"><a class="header" href="#packagescomponentstestsenableprofiling">packages.<name>.components.tests.<name>.enableProfiling</a></h2>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: false</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentstestsenableseparatedataoutput"><a class="header" href="#packagescomponentstestsenableseparatedataoutput">packages.<name>.components.tests.<name>.enableSeparateDataOutput</a></h2>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: true</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentstestsenableshared"><a class="header" href="#packagescomponentstestsenableshared">packages.<name>.components.tests.<name>.enableShared</a></h2>
<p>If set, enables building shared libraries.</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: true</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentstestsenablestatic"><a class="header" href="#packagescomponentstestsenablestatic">packages.<name>.components.tests.<name>.enableStatic</a></h2>
<p>If set, enables building static libraries and executables.</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: true</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentstestsextrasrcfiles"><a class="header" href="#packagescomponentstestsextrasrcfiles">packages.<name>.components.tests.<name>.extraSrcFiles</a></h2>
<p><strong>Type</strong>: list of unspecified value</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentstestsframeworks"><a class="header" href="#packagescomponentstestsframeworks">packages.<name>.components.tests.<name>.frameworks</a></h2>
<p><strong>Type</strong>: list of package</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentstestsghcoptions"><a class="header" href="#packagescomponentstestsghcoptions">packages.<name>.components.tests.<name>.ghcOptions</a></h2>
<p><strong>Type</strong>: list of string</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentstestshardeningdisable"><a class="header" href="#packagescomponentstestshardeningdisable">packages.<name>.components.tests.<name>.hardeningDisable</a></h2>
<p><strong>Type</strong>: list of string</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentstestshssourcedirs"><a class="header" href="#packagescomponentstestshssourcedirs">packages.<name>.components.tests.<name>.hsSourceDirs</a></h2>
<p><strong>Type</strong>: list of unspecified value</p>
<p><strong>Default</strong>: [&quot;.&quot;]</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentstestsincludedirs"><a class="header" href="#packagescomponentstestsincludedirs">packages.<name>.components.tests.<name>.includeDirs</a></h2>
<p><strong>Type</strong>: list of unspecified value</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentstestsincludes"><a class="header" href="#packagescomponentstestsincludes">packages.<name>.components.tests.<name>.includes</a></h2>
<p><strong>Type</strong>: list of unspecified value</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentstestsjssources"><a class="header" href="#packagescomponentstestsjssources">packages.<name>.components.tests.<name>.jsSources</a></h2>
<p><strong>Type</strong>: list of unspecified value</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentstestskeepsource"><a class="header" href="#packagescomponentstestskeepsource">packages.<name>.components.tests.<name>.keepSource</a></h2>
<p>Keep component source in the store in a <code>source</code> output</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: false</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentstestslibs"><a class="header" href="#packagescomponentstestslibs">packages.<name>.components.tests.<name>.libs</a></h2>
<p><strong>Type</strong>: list of (null or package or list of package)</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentstestsmainpath"><a class="header" href="#packagescomponentstestsmainpath">packages.<name>.components.tests.<name>.mainPath</a></h2>
<p><strong>Type</strong>: list of unspecified value</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentstestsmodules"><a class="header" href="#packagescomponentstestsmodules">packages.<name>.components.tests.<name>.modules</a></h2>
<p><strong>Type</strong>: list of unspecified value</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentstestspkgconfig"><a class="header" href="#packagescomponentstestspkgconfig">packages.<name>.components.tests.<name>.pkgconfig</a></h2>
<p><strong>Type</strong>: list of list of package</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentstestsplanned"><a class="header" href="#packagescomponentstestsplanned">packages.<name>.components.tests.<name>.planned</a></h2>
<p>Set to true by <code>plan-to-nix</code> for any component that was included in the <code>plan.json</code> file.</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: false</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentstestsplatforms"><a class="header" href="#packagescomponentstestsplatforms">packages.<name>.components.tests.<name>.platforms</a></h2>
<p><strong>Type</strong>: null or (list of unspecified value)</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentstestsplugins"><a class="header" href="#packagescomponentstestsplugins">packages.<name>.components.tests.<name>.plugins</a></h2>
<p><strong>Type</strong>: list of (submodule)</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentstestspluginsargs"><a class="header" href="#packagescomponentstestspluginsargs">packages.<name>.components.tests.<name>.plugins.*.args</a></h2>
<p><strong>Type</strong>: list of string</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentstestspluginslibrary"><a class="header" href="#packagescomponentstestspluginslibrary">packages.<name>.components.tests.<name>.plugins.*.library</a></h2>
<p><strong>Type</strong>: unspecified value</p>
<p><strong>No Default</strong></p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentstestspluginsmodulename"><a class="header" href="#packagescomponentstestspluginsmodulename">packages.<name>.components.tests.<name>.plugins.*.moduleName</a></h2>
<p><strong>Type</strong>: string</p>
<p><strong>No Default</strong></p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentstestspostbuild"><a class="header" href="#packagescomponentstestspostbuild">packages.<name>.components.tests.<name>.postBuild</a></h2>
<p><strong>Type</strong>: null or string</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentstestspostcheck"><a class="header" href="#packagescomponentstestspostcheck">packages.<name>.components.tests.<name>.postCheck</a></h2>
<p><strong>Type</strong>: null or string</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentstestspostconfigure"><a class="header" href="#packagescomponentstestspostconfigure">packages.<name>.components.tests.<name>.postConfigure</a></h2>
<p><strong>Type</strong>: null or string</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentstestsposthaddock"><a class="header" href="#packagescomponentstestsposthaddock">packages.<name>.components.tests.<name>.postHaddock</a></h2>
<p><strong>Type</strong>: null or string</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentstestspostinstall"><a class="header" href="#packagescomponentstestspostinstall">packages.<name>.components.tests.<name>.postInstall</a></h2>
<p><strong>Type</strong>: null or string</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentstestspostunpack"><a class="header" href="#packagescomponentstestspostunpack">packages.<name>.components.tests.<name>.postUnpack</a></h2>
<p><strong>Type</strong>: null or string</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentstestsprebuild"><a class="header" href="#packagescomponentstestsprebuild">packages.<name>.components.tests.<name>.preBuild</a></h2>
<p><strong>Type</strong>: null or string</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentstestsprecheck"><a class="header" href="#packagescomponentstestsprecheck">packages.<name>.components.tests.<name>.preCheck</a></h2>
<p><strong>Type</strong>: null or string</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentstestspreconfigure"><a class="header" href="#packagescomponentstestspreconfigure">packages.<name>.components.tests.<name>.preConfigure</a></h2>
<p><strong>Type</strong>: null or string</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentstestsprehaddock"><a class="header" href="#packagescomponentstestsprehaddock">packages.<name>.components.tests.<name>.preHaddock</a></h2>
<p><strong>Type</strong>: null or string</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentstestspreinstall"><a class="header" href="#packagescomponentstestspreinstall">packages.<name>.components.tests.<name>.preInstall</a></h2>
<p><strong>Type</strong>: null or string</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentstestspreunpack"><a class="header" href="#packagescomponentstestspreunpack">packages.<name>.components.tests.<name>.preUnpack</a></h2>
<p><strong>Type</strong>: null or strings concatenated with &quot;\n&quot;</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentstestsprofilingdetail"><a class="header" href="#packagescomponentstestsprofilingdetail">packages.<name>.components.tests.<name>.profilingDetail</a></h2>
<p><strong>Type</strong>: null or string</p>
<p><strong>Default</strong>: &quot;default&quot;</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentstestssetupbuildflags"><a class="header" href="#packagescomponentstestssetupbuildflags">packages.<name>.components.tests.<name>.setupBuildFlags</a></h2>
<p><strong>Type</strong>: list of string</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentstestssetuphaddockflags"><a class="header" href="#packagescomponentstestssetuphaddockflags">packages.<name>.components.tests.<name>.setupHaddockFlags</a></h2>
<p><strong>Type</strong>: list of string</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentstestssetupinstallflags"><a class="header" href="#packagescomponentstestssetupinstallflags">packages.<name>.components.tests.<name>.setupInstallFlags</a></h2>
<p><strong>Type</strong>: list of string</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentstestsshellhook"><a class="header" href="#packagescomponentstestsshellhook">packages.<name>.components.tests.<name>.shellHook</a></h2>
<p>Hook to run when entering a shell</p>
<p><strong>Type</strong>: unspecified value</p>
<p><strong>Default</strong>: &quot;&quot;</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsteststestflags"><a class="header" href="#packagescomponentsteststestflags">packages.<name>.components.tests.<name>.testFlags</a></h2>
<p><strong>Type</strong>: list of string</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescomponentsteststestwrapper"><a class="header" href="#packagescomponentsteststestwrapper">packages.<name>.components.tests.<name>.testWrapper</a></h2>
<p>A command to run for executing tests in checkPhase, which takes the original test command as its arguments.</p>
<p><strong>Type</strong>: list of string</p>
<p><strong>Default</strong>: []</p>
<p><strong>Example</strong>:</p>
<p>&quot;echo&quot;</p>
<h2 id="packagescomponentstestswritehiefiles"><a class="header" href="#packagescomponentstestswritehiefiles">packages.<name>.components.tests.<name>.writeHieFiles</a></h2>
<p>Write component <code>.hie</code> files in the store in a <code>hie</code> output</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: false</p>
<p><strong>No Example</strong></p>
<h2 id="packagesconfigureallcomponents"><a class="header" href="#packagesconfigureallcomponents">packages.<name>.configureAllComponents</a></h2>
<p>If set all the components in the package are configured (useful for cabal-doctest).</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: false</p>
<p><strong>No Example</strong></p>
<h2 id="packagesconfigureflags"><a class="header" href="#packagesconfigureflags">packages.<name>.configureFlags</a></h2>
<p><strong>Type</strong>: list of string</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagescontentaddressed"><a class="header" href="#packagescontentaddressed">packages.<name>.contentAddressed</a></h2>
<p>Build content addressed derivation, requires Nix to have experimental feature
<code>ca-derivations</code> enabled.</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: false</p>
<p><strong>No Example</strong></p>
<h2 id="packagesdocheck"><a class="header" href="#packagesdocheck">packages.<name>.doCheck</a></h2>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: true</p>
<p><strong>No Example</strong></p>
<h2 id="packagesdocoverage"><a class="header" href="#packagesdocoverage">packages.<name>.doCoverage</a></h2>
<p>Enable production of test coverage reports.</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: false</p>
<p><strong>No Example</strong></p>
<h2 id="packagesdocrosscheck"><a class="header" href="#packagesdocrosscheck">packages.<name>.doCrossCheck</a></h2>
<p>Run doCheck also in cross compilation settings. This can be tricky as the test logic must know how to run the tests on the target.</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: false</p>
<p><strong>No Example</strong></p>
<h2 id="packagesdoexactconfig"><a class="header" href="#packagesdoexactconfig">packages.<name>.doExactConfig</a></h2>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: false</p>
<p><strong>No Example</strong></p>
<h2 id="packagesdohaddock"><a class="header" href="#packagesdohaddock">packages.<name>.doHaddock</a></h2>
<p>Enable building of the Haddock documentation from the annotated Haskell source code.</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: true</p>
<p><strong>No Example</strong></p>
<h2 id="packagesdohoogle"><a class="header" href="#packagesdohoogle">packages.<name>.doHoogle</a></h2>
<p>Also build a hoogle index.</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: true</p>
<p><strong>No Example</strong></p>
<h2 id="packagesdohyperlinksource"><a class="header" href="#packagesdohyperlinksource">packages.<name>.doHyperlinkSource</a></h2>
<p>Link documentation to the source code.</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: true</p>
<p><strong>No Example</strong></p>
<h2 id="packagesdoquickjump"><a class="header" href="#packagesdoquickjump">packages.<name>.doQuickjump</a></h2>
<p>Generate an index for interactive documentation navigation.</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: true</p>
<p><strong>No Example</strong></p>
<h2 id="packagesdontpatchelf"><a class="header" href="#packagesdontpatchelf">packages.<name>.dontPatchELF</a></h2>
<p>If set, the patchelf command is not used to remove unnecessary RPATH entries. Only applies to Linux.</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: true</p>
<p><strong>No Example</strong></p>
<h2 id="packagesdontstrip"><a class="header" href="#packagesdontstrip">packages.<name>.dontStrip</a></h2>
<p>If set, libraries and executables are not stripped.</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: true</p>
<p><strong>No Example</strong></p>
<h2 id="packagesenabledeadcodeelimination"><a class="header" href="#packagesenabledeadcodeelimination">packages.<name>.enableDeadCodeElimination</a></h2>
<p>If set, enables split sections for link-time dead-code stripping. Only applies to Linux</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: true</p>
<p><strong>No Example</strong></p>
<h2 id="packagesenablelibraryprofiling"><a class="header" href="#packagesenablelibraryprofiling">packages.<name>.enableLibraryProfiling</a></h2>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: false</p>
<p><strong>No Example</strong></p>
<h2 id="packagesenableprofiling"><a class="header" href="#packagesenableprofiling">packages.<name>.enableProfiling</a></h2>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: false</p>
<p><strong>No Example</strong></p>
<h2 id="packagesenableseparatedataoutput"><a class="header" href="#packagesenableseparatedataoutput">packages.<name>.enableSeparateDataOutput</a></h2>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: true</p>
<p><strong>No Example</strong></p>
<h2 id="packagesenableshared"><a class="header" href="#packagesenableshared">packages.<name>.enableShared</a></h2>
<p>If set, enables building shared libraries.</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: true</p>
<p><strong>No Example</strong></p>
<h2 id="packagesenablestatic"><a class="header" href="#packagesenablestatic">packages.<name>.enableStatic</a></h2>
<p>If set, enables building static libraries and executables.</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: true</p>
<p><strong>No Example</strong></p>
<h2 id="packagesflags"><a class="header" href="#packagesflags">packages.<name>.flags</a></h2>
<p><strong>Type</strong>: attribute set of boolean</p>
<p><strong>No Default</strong></p>
<p><strong>No Example</strong></p>
<h2 id="packagesghcoptions"><a class="header" href="#packagesghcoptions">packages.<name>.ghcOptions</a></h2>
<p><strong>Type</strong>: list of string</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packageshardeningdisable"><a class="header" href="#packageshardeningdisable">packages.<name>.hardeningDisable</a></h2>
<p><strong>Type</strong>: list of string</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packageskeepsource"><a class="header" href="#packageskeepsource">packages.<name>.keepSource</a></h2>
<p>Keep component source in the store in a <code>source</code> output</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: false</p>
<p><strong>No Example</strong></p>
<h2 id="packagesname"><a class="header" href="#packagesname">packages.<name>.name</a></h2>
<p><strong>Type</strong>: string</p>
<p><strong>Default</strong>: &quot;${config.package.identifier.name}-${config.package.identifier.version}&quot;</p>
<p><strong>No Example</strong></p>
<h2 id="packagespackageauthor"><a class="header" href="#packagespackageauthor">packages.<name>.package.author</a></h2>
<p><strong>Type</strong>: string</p>
<p><strong>No Default</strong></p>
<p><strong>No Example</strong></p>
<h2 id="packagespackagebuildtype"><a class="header" href="#packagespackagebuildtype">packages.<name>.package.buildType</a></h2>
<p><strong>Type</strong>: string</p>
<p><strong>No Default</strong></p>
<p><strong>No Example</strong></p>
<h2 id="packagespackagebuildable"><a class="header" href="#packagespackagebuildable">packages.<name>.package.buildable</a></h2>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: true</p>
<p><strong>No Example</strong></p>
<h2 id="packagespackagecleanhpack"><a class="header" href="#packagespackagecleanhpack">packages.<name>.package.cleanHpack</a></h2>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: false</p>
<p><strong>No Example</strong></p>
<h2 id="packagespackagecopyright"><a class="header" href="#packagespackagecopyright">packages.<name>.package.copyright</a></h2>
<p><strong>Type</strong>: string</p>
<p><strong>No Default</strong></p>
<p><strong>No Example</strong></p>
<h2 id="packagespackagedatadir"><a class="header" href="#packagespackagedatadir">packages.<name>.package.dataDir</a></h2>
<p><strong>Type</strong>: string</p>
<p><strong>Default</strong>: &quot;&quot;</p>
<p><strong>No Example</strong></p>
<h2 id="packagespackagedatafiles"><a class="header" href="#packagespackagedatafiles">packages.<name>.package.dataFiles</a></h2>
<p><strong>Type</strong>: list of unspecified value</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagespackagedescription"><a class="header" href="#packagespackagedescription">packages.<name>.package.description</a></h2>
<p><strong>Type</strong>: string</p>
<p><strong>No Default</strong></p>
<p><strong>No Example</strong></p>
<h2 id="packagespackagedetaillevel"><a class="header" href="#packagespackagedetaillevel">packages.<name>.package.detailLevel</a></h2>
<p><strong>Type</strong>: string</p>
<p><strong>Default</strong>: &quot;MinimalDetails&quot;</p>
<p><strong>No Example</strong></p>
<h2 id="packagespackageextradocfiles"><a class="header" href="#packagespackageextradocfiles">packages.<name>.package.extraDocFiles</a></h2>
<p><strong>Type</strong>: list of unspecified value</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagespackageextrasrcfiles"><a class="header" href="#packagespackageextrasrcfiles">packages.<name>.package.extraSrcFiles</a></h2>
<p><strong>Type</strong>: list of unspecified value</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagespackageextratmpfiles"><a class="header" href="#packagespackageextratmpfiles">packages.<name>.package.extraTmpFiles</a></h2>
<p><strong>Type</strong>: list of unspecified value</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagespackagehomepage"><a class="header" href="#packagespackagehomepage">packages.<name>.package.homepage</a></h2>
<p><strong>Type</strong>: string</p>
<p><strong>No Default</strong></p>
<p><strong>No Example</strong></p>
<h2 id="packagespackageidentifiername"><a class="header" href="#packagespackageidentifiername">packages.<name>.package.identifier.name</a></h2>
<p><strong>Type</strong>: string</p>
<p><strong>No Default</strong></p>
<p><strong>No Example</strong></p>
<h2 id="packagespackageidentifierversion"><a class="header" href="#packagespackageidentifierversion">packages.<name>.package.identifier.version</a></h2>
<p><strong>Type</strong>: string</p>
<p><strong>No Default</strong></p>
<p><strong>No Example</strong></p>
<h2 id="packagespackageislocal"><a class="header" href="#packagespackageislocal">packages.<name>.package.isLocal</a></h2>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: false</p>
<p><strong>No Example</strong></p>
<h2 id="packagespackageisproject"><a class="header" href="#packagespackageisproject">packages.<name>.package.isProject</a></h2>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: false</p>
<p><strong>No Example</strong></p>
<h2 id="packagespackagelicense"><a class="header" href="#packagespackagelicense">packages.<name>.package.license</a></h2>
<p><strong>Type</strong>: string</p>
<p><strong>No Default</strong></p>
<p><strong>No Example</strong></p>
<h2 id="packagespackagelicensefiles"><a class="header" href="#packagespackagelicensefiles">packages.<name>.package.licenseFiles</a></h2>
<p><strong>Type</strong>: list of unspecified value</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagespackagemaintainer"><a class="header" href="#packagespackagemaintainer">packages.<name>.package.maintainer</a></h2>
<p><strong>Type</strong>: string</p>
<p><strong>No Default</strong></p>
<p><strong>No Example</strong></p>
<h2 id="packagespackagesetup-depends"><a class="header" href="#packagespackagesetup-depends">packages.<name>.package.setup-depends</a></h2>
<p><strong>Type</strong>: list of unspecified value</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagespackagespecversion"><a class="header" href="#packagespackagespecversion">packages.<name>.package.specVersion</a></h2>
<p><strong>Type</strong>: string</p>
<p><strong>No Default</strong></p>
<p><strong>No Example</strong></p>
<h2 id="packagespackagesynopsis"><a class="header" href="#packagespackagesynopsis">packages.<name>.package.synopsis</a></h2>
<p><strong>Type</strong>: string</p>
<p><strong>No Default</strong></p>
<p><strong>No Example</strong></p>
<h2 id="packagespackageurl"><a class="header" href="#packagespackageurl">packages.<name>.package.url</a></h2>
<p><strong>Type</strong>: string</p>
<p><strong>No Default</strong></p>
<p><strong>No Example</strong></p>
<h2 id="packagespatches"><a class="header" href="#packagespatches">packages.<name>.patches</a></h2>
<p><strong>Type</strong>: list of (unspecified value or (path))</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagesplanned"><a class="header" href="#packagesplanned">packages.<name>.planned</a></h2>
<p>Set to true by <code>plan-to-nix</code> for any component that was included in the <code>plan.json</code> file.</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: false</p>
<p><strong>No Example</strong></p>
<h2 id="packagespostbuild"><a class="header" href="#packagespostbuild">packages.<name>.postBuild</a></h2>
<p><strong>Type</strong>: null or string</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="packagespostcheck"><a class="header" href="#packagespostcheck">packages.<name>.postCheck</a></h2>
<p><strong>Type</strong>: null or string</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="packagespostconfigure"><a class="header" href="#packagespostconfigure">packages.<name>.postConfigure</a></h2>
<p><strong>Type</strong>: null or string</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="packagesposthaddock"><a class="header" href="#packagesposthaddock">packages.<name>.postHaddock</a></h2>
<p><strong>Type</strong>: null or string</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="packagespostinstall"><a class="header" href="#packagespostinstall">packages.<name>.postInstall</a></h2>
<p><strong>Type</strong>: null or string</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="packagespostunpack"><a class="header" href="#packagespostunpack">packages.<name>.postUnpack</a></h2>
<p><strong>Type</strong>: null or string</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="packagesprebuild"><a class="header" href="#packagesprebuild">packages.<name>.preBuild</a></h2>
<p><strong>Type</strong>: null or string</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="packagesprecheck"><a class="header" href="#packagesprecheck">packages.<name>.preCheck</a></h2>
<p><strong>Type</strong>: null or string</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="packagespreconfigure"><a class="header" href="#packagespreconfigure">packages.<name>.preConfigure</a></h2>
<p><strong>Type</strong>: null or string</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="packagesprehaddock"><a class="header" href="#packagesprehaddock">packages.<name>.preHaddock</a></h2>
<p><strong>Type</strong>: null or string</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="packagespreinstall"><a class="header" href="#packagespreinstall">packages.<name>.preInstall</a></h2>
<p><strong>Type</strong>: null or string</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="packagespreunpack"><a class="header" href="#packagespreunpack">packages.<name>.preUnpack</a></h2>
<p><strong>Type</strong>: null or strings concatenated with &quot;\n&quot;</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="packagesprofilingdetail"><a class="header" href="#packagesprofilingdetail">packages.<name>.profilingDetail</a></h2>
<p><strong>Type</strong>: null or string</p>
<p><strong>Default</strong>: &quot;default&quot;</p>
<p><strong>No Example</strong></p>
<h2 id="packagesrevision"><a class="header" href="#packagesrevision">packages.<name>.revision</a></h2>
<p><strong>Type</strong>: null or signed integer</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="packagesrevisionsha256"><a class="header" href="#packagesrevisionsha256">packages.<name>.revisionSha256</a></h2>
<p><strong>Type</strong>: null or string</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="packagessetupbuildflags"><a class="header" href="#packagessetupbuildflags">packages.<name>.setupBuildFlags</a></h2>
<p><strong>Type</strong>: list of string</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagessetuphaddockflags"><a class="header" href="#packagessetuphaddockflags">packages.<name>.setupHaddockFlags</a></h2>
<p><strong>Type</strong>: list of string</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagessetupinstallflags"><a class="header" href="#packagessetupinstallflags">packages.<name>.setupInstallFlags</a></h2>
<p><strong>Type</strong>: list of string</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagessha256"><a class="header" href="#packagessha256">packages.<name>.sha256</a></h2>
<p><strong>Type</strong>: null or string</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="packagesshellhook"><a class="header" href="#packagesshellhook">packages.<name>.shellHook</a></h2>
<p>Hook to run when entering a shell</p>
<p><strong>Type</strong>: unspecified value</p>
<p><strong>Default</strong>: &quot;&quot;</p>
<p><strong>No Example</strong></p>
<h2 id="packagessrc"><a class="header" href="#packagessrc">packages.<name>.src</a></h2>
<p><strong>Type</strong>: (path) or package</p>
<p><strong>Default</strong>: &quot;pkgs.fetchurl { url = &quot;mirror://hackage/${config.name}.tar.gz&quot;; inherit (config) sha256; };&quot;</p>
<p><strong>No Example</strong></p>
<h2 id="packagestestflags"><a class="header" href="#packagestestflags">packages.<name>.testFlags</a></h2>
<p><strong>Type</strong>: list of string</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="packagestestwrapper"><a class="header" href="#packagestestwrapper">packages.<name>.testWrapper</a></h2>
<p>A command to run for executing tests in checkPhase, which takes the original test command as its arguments.</p>
<p><strong>Type</strong>: list of string</p>
<p><strong>Default</strong>: []</p>
<p><strong>Example</strong>:</p>
<p>&quot;echo&quot;</p>
<h2 id="packageswritehiefiles"><a class="header" href="#packageswritehiefiles">packages.<name>.writeHieFiles</a></h2>
<p>Write component <code>.hie</code> files in the store in a <code>hie</code> output</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: false</p>
<p><strong>No Example</strong></p>
<h2 id="planned"><a class="header" href="#planned">planned</a></h2>
<p>Set to true by <code>plan-to-nix</code> for any component that was included in the <code>plan.json</code> file.</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: false</p>
<p><strong>No Example</strong></p>
<h2 id="postbuild"><a class="header" href="#postbuild">postBuild</a></h2>
<p><strong>Type</strong>: null or string</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="postcheck"><a class="header" href="#postcheck">postCheck</a></h2>
<p><strong>Type</strong>: null or string</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="postconfigure"><a class="header" href="#postconfigure">postConfigure</a></h2>
<p><strong>Type</strong>: null or string</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="posthaddock"><a class="header" href="#posthaddock">postHaddock</a></h2>
<p><strong>Type</strong>: null or string</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="postinstall"><a class="header" href="#postinstall">postInstall</a></h2>
<p><strong>Type</strong>: null or string</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="postunpack"><a class="header" href="#postunpack">postUnpack</a></h2>
<p><strong>Type</strong>: null or string</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="prebuild"><a class="header" href="#prebuild">preBuild</a></h2>
<p><strong>Type</strong>: null or string</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="precheck"><a class="header" href="#precheck">preCheck</a></h2>
<p><strong>Type</strong>: null or string</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="preconfigure"><a class="header" href="#preconfigure">preConfigure</a></h2>
<p><strong>Type</strong>: null or string</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="prehaddock"><a class="header" href="#prehaddock">preHaddock</a></h2>
<p><strong>Type</strong>: null or string</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="preinstall"><a class="header" href="#preinstall">preInstall</a></h2>
<p><strong>Type</strong>: null or string</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="preunpack"><a class="header" href="#preunpack">preUnpack</a></h2>
<p><strong>Type</strong>: null or strings concatenated with &quot;\n&quot;</p>
<p><strong>Default</strong>: null</p>
<p><strong>No Example</strong></p>
<h2 id="profilingdetail"><a class="header" href="#profilingdetail">profilingDetail</a></h2>
<p><strong>Type</strong>: null or string</p>
<p><strong>Default</strong>: &quot;default&quot;</p>
<p><strong>No Example</strong></p>
<h2 id="reinstallablelibghc"><a class="header" href="#reinstallablelibghc">reinstallableLibGhc</a></h2>
<p>Is lib:ghc reinstallable?</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: true</p>
<p><strong>No Example</strong></p>
<h2 id="setup-depends"><a class="header" href="#setup-depends">setup-depends</a></h2>
<p>pkgs to globally provide to Setup.hs builds</p>
<p><strong>Type</strong>: list of unspecified value</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="setupbuildflags"><a class="header" href="#setupbuildflags">setupBuildFlags</a></h2>
<p><strong>Type</strong>: list of string</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="setuphaddockflags"><a class="header" href="#setuphaddockflags">setupHaddockFlags</a></h2>
<p><strong>Type</strong>: list of string</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="setupinstallflags"><a class="header" href="#setupinstallflags">setupInstallFlags</a></h2>
<p><strong>Type</strong>: list of string</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="shellhook"><a class="header" href="#shellhook">shellHook</a></h2>
<p>Hook to run when entering a shell</p>
<p><strong>Type</strong>: unspecified value</p>
<p><strong>Default</strong>: &quot;&quot;</p>
<p><strong>No Example</strong></p>
<h2 id="testflags"><a class="header" href="#testflags">testFlags</a></h2>
<p><strong>Type</strong>: list of string</p>
<p><strong>Default</strong>: []</p>
<p><strong>No Example</strong></p>
<h2 id="testwrapper"><a class="header" href="#testwrapper">testWrapper</a></h2>
<p>A command to run for executing tests in checkPhase, which takes the original test command as its arguments.</p>
<p><strong>Type</strong>: list of string</p>
<p><strong>Default</strong>: []</p>
<p><strong>Example</strong>:</p>
<p>&quot;echo&quot;</p>
<h2 id="writehiefiles"><a class="header" href="#writehiefiles">writeHieFiles</a></h2>
<p>Write component <code>.hie</code> files in the store in a <code>hie</code> output</p>
<p><strong>Type</strong>: boolean</p>
<p><strong>Default</strong>: false</p>
<p><strong>No Example</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="troubleshooting"><a class="header" href="#troubleshooting">Troubleshooting</a></h1>
<h2 id="issues-with-building-and-garbage-collection"><a class="header" href="#issues-with-building-and-garbage-collection">Issues with building and garbage-collection</a></h2>
<h3 id="why-am-i-building-ghc"><a class="header" href="#why-am-i-building-ghc">Why am I building GHC?</a></h3>
<p>It's easier to list the reverse: when will you <em>not</em> build GHC?</p>
<ul>
<li>You have configured the <a href="tutorials/getting-started.html">binary cache</a> correctly.</li>
<li>You are using one of the GHC versions which <a href="reference/supported-ghc-versions.html">we support</a>.</li>
<li>You are using one of the nixpkgs versions used by our CI (you can access the sources for these <a href="tutorials/getting-started.html">through haskell.nix</a>.</li>
</ul>
<p>If you think you are doing all of these and you still find you're building GHC, drop us a line.</p>
<h3 id="why-am-i-building-lots-of-haskell-packages"><a class="header" href="#why-am-i-building-lots-of-haskell-packages">Why am I building lots of Haskell packages?</a></h3>
<p>We don't generally cache much of Hackage (there's a lot of it!), except for the parts which are used by our tests.
So this is expected, unfortunately.</p>
<h3 id="how-do-i-prevent-the-evaluation-time-dependencies-of-my-project-from-being-garbage-collected"><a class="header" href="#how-do-i-prevent-the-evaluation-time-dependencies-of-my-project-from-being-garbage-collected">How do I prevent the evaluation-time dependencies of my project from being garbage-collected?</a></h3>
<p>The <code>haskell-nix.roots &quot;ghc884&quot;</code> should include all the evaluation-time dependencies
and the main build time dependencies of a project using ghc 8.8.4.
So you can add that to the relevant GC root.
In practice, if you're using a CI system like Hydra/Hercules, this means adding it to a job in <code>release.nix</code>/<code>ci.nix</code>.</p>
<h2 id="general-troubleshooting-when-using-cabalprojectstackprojectproject"><a class="header" href="#general-troubleshooting-when-using-cabalprojectstackprojectproject">General troubleshooting when using <code>cabalProject</code>/<code>stackProject</code>/<code>project</code></a></h2>
<h3 id="does-the-cabalstack-build-work"><a class="header" href="#does-the-cabalstack-build-work">Does the cabal/stack build work?</a></h3>
<p>In <code>haskell.nix</code>, we strive to take the build configuration from the cabal/stack configuration files.
So if you have a problem with your cabal/stack configuration, it is likely that you will have a problem with the <code>haskell.nix</code> build too.</p>
<p>So the first thing to do is make sure that the build works with <code>cabal</code> or <code>stack</code> as normal.
If it <em>does</em> work, then the <code>haskell.nix</code> one should as well.
If, on the other hand, there is a failure, the <code>cabal</code> or <code>stack</code> build is usually easier to debug (or at least it is no longer a <code>haskell.nix</code> problem).</p>
<h3 id="is-the-haskellnix-configuration-completely-in-line-with-the-cabalstack-configuration"><a class="header" href="#is-the-haskellnix-configuration-completely-in-line-with-the-cabalstack-configuration">Is the <code>haskell.nix</code> configuration completely in line with the cabal/stack configuration?</a></h3>
<p>The <code>haskell.nix</code> configuration can come apart from the cabal/stack configuration in a number of ways:</p>
<h4 id="compiler-version"><a class="header" href="#compiler-version">Compiler version</a></h4>
<p>(Cabal users only. For stack users this comes from the snapshot, so stack and <code>haskell.nix</code> will agree.)</p>
<p>The compiler version used by <code>haskell.nix</code> is selected by the <code>compiler-nix-name</code> argument; or if you do not specify it, by some default version (we recommend specifying it!).
Cabal does not provide an easy way to pin a <em>version</em> of the compiler (<code>with-compiler</code> lets you pick a particular executable, which is nearly but not quite what we want).
Hence, the two can come apart.</p>
<p>Make sure you are using the same compiler for the cabal build as for the <code>haskell.nix</code> build.</p>
<h4 id="hackage-index-state"><a class="header" href="#hackage-index-state">Hackage index state</a></h4>
<p>(Cabal users only. For stack users, package versions come from the snapshot, so stack and <code>haskell.nix</code> will agree.)</p>
<p>Cabal has the concept of the Hackage &quot;index state&quot;.
This is a timestamp, and it tells Cabal to behave &quot;as if&quot; it was seeing Hackage at that point in time.
Pinning it is generally good for reproducibility regardless of whether you use <code>haskell.nix</code> (you can do so in <code>cabal.project</code>).</p>
<p>If you do not set an <code>index-state</code> in <code>cabal.project</code>, then Cabal will use the latest one based on when you last called <code>cabal update</code>, and <code>haskell.nix</code> will use the latest one it knows about from <code>hackage.nix</code>.
These may not be the same!
So if you use <code>haskell.nix</code> we strongly recommend pinning the <code>index-state</code>.</p>
<h4 id="nix-only-configuration-options"><a class="header" href="#nix-only-configuration-options">Nix-only configuration options</a></h4>
<p>You can set configuration options in your Nix code that are not present in the cabal/stack configuration.
For example, you might enable profiling.</p>
<p>Where possible, try to do the configuration in your cabal/stack configuration, e.g. setting <code>profiling: true</code> in <code>cabal.project</code>.
This will ensure that the two builds agree.</p>
<p>If you want or need to set some of them in Nix, try bringing the two into sync temporarily for troubleshooting.</p>
<h2 id="other-specific-issues"><a class="header" href="#other-specific-issues">Other specific issues</a></h2>
<h3 id="why-does-the-build-complain-about-some-files-being-missing"><a class="header" href="#why-does-the-build-complain-about-some-files-being-missing">Why does the build complain about some files being missing?</a></h3>
<p>Sometimes your build works fine outside <code>haskell.nix</code>, but inside the <code>haskell.nix</code> build, cabal complains that some file is missing.
What is going on?</p>
<p>The answer is that <code>haskell.nix</code> <em>thoroughly</em> cleans the source <em>by following what is mentioned as required in the cabal file</em>.
So we only include Haskell sources if they appear in a <code>hs-source-dirs</code> somewhere; and we only include non-Haskell files if they are included in <code>extra-source-files</code> or similar.</p>
<p>This is good practice anyway: if you do not include such files in <code>extra-source-files</code> then they will not be included in <code>cabal sdist</code>, which will cause problems if you ever upload your package to Hackage.
But <code>haskell.nix</code> is very picky about it.</p>
<h3 id="why-does-my-executable-depend-on-ghcgcc"><a class="header" href="#why-does-my-executable-depend-on-ghcgcc">Why does my executable depend on GHC/GCC?</a></h3>
<p>You may want to set the <code>dontStrip</code> option to <code>false</code> (see https://github.com/input-output-hk/haskell.nix/issues/829).
This is not set by default because it can occasionally cause breakage.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="templates--abstraction"><a class="header" href="#templates--abstraction">Templates / Abstraction</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="iohks-nix-tooling"><a class="header" href="#iohks-nix-tooling">IOHK's nix tooling</a></h1>
<h2 id="iohk-nix"><a class="header" href="#iohk-nix"><a href="https://github.com/input-output-hk/iohk-nix"><code>iohk-nix</code></a></a></h2>
<p><code>iohk-nix</code> is IOHK's shared nix library. It provides some templates to
make working with <code>haskell.nix</code> trivial but is non-essential to use
<code>haskell.nix</code> infrastructure.</p>
<h3 id="libnix"><a class="header" href="#libnix"><code>lib.nix</code></a></h3>
<pre><code class="language-nix">let
  # iohk-nix can be overridden for debugging purposes by setting
  # NIX_PATH=iohk_nix=/path/to/iohk-nix
  iohkNix = import (
    let try = builtins.tryEval &lt;iohk_nix&gt;;
    in if try.success
    then builtins.trace &quot;using host &lt;iohk_nix&gt;&quot; try.value
    else
      let
        spec = builtins.fromJSON (builtins.readFile ./iohk-nix.json);
      in builtins.fetchTarball {
        url = &quot;${spec.url}/archive/${spec.rev}.tar.gz&quot;;
        inherit (spec) sha256;
      }) {};

  pkgs = iohkNix.pkgs;
  lib = pkgs.lib;
in lib // { inherit iohkNix pkgs; inherit (iohkNix) nix-tools; }
</code></pre>
<h3 id="iohk-nixjson"><a class="header" href="#iohk-nixjson"><code>iohk-nix.json</code></a></h3>
<pre><code class="language-json">{
    &quot;url&quot;: &quot;https://github.com/input-output-hk/iohk-nix&quot;,
    &quot;rev&quot;: &quot;c92f0119ef5814b0ed1f445c2fdcf8894e326294&quot;,
    &quot;sha256&quot;: &quot;05r90x6x3yp1nb66rkc4n0i8q15c634rrdsr2zvb118s3sdcmmrm&quot;,
    &quot;fetchSubmodules&quot;: false
}
</code></pre>
<h3 id="nixpkgsnix"><a class="header" href="#nixpkgsnix"><code>nix/pkgs.nix</code></a></h3>
<pre><code class="language-nix">{ pkgs ? import &lt;nixpkgs&gt; {}
, iohk-extras ? {}
, iohk-module ? {}
, haskell
, hackage
, stackage
, ...
}:
let
  # our packages
  stack-pkgs = import ./.stack-pkgs.nix;

  # Build the packageset with module support.
  # We can essentially override anything in the modules
  # section.
  #
  #  packages.cbors.patches = [ ./one.patch ];
  #  packages.cbors.flags.optimize-gmp = false;
  #
  compiler = (stack-pkgs.extras hackage).compiler.nix-name;
  pkgSet = haskell.mkNewPkgSet {
    inherit pkgs;
    pkg-def = stackage.${stack-pkgs.resolver};
    # These extras allow extension or restriction of the set of
    # packages we are interested in. By using the stack-pkgs.extras
    # we restrict our package set to the ones provided in stack.yaml.
    pkg-def-extras = [
      stack-pkgs.extras
      iohk-extras.${compiler}
    ];
    # package customizations
    modules = [
      # This module will ensure that we get the necessary
      # patches ontop of GHC packages that for which the
      # ones that GHC ships are not identical to the ones
      # we find on hackage. These patches will make sure
      # they are identical by augmenting the packages on
      # hackage to match those that ship with ghc.
      haskell.ghcHackagePatches.${compiler}

      # the iohk-module will supply us with the necessary
      # cross compilation plumbing to make Template Haskell
      # work when cross compiling.  For now we need to
      # list the packages that require template haskell
      # explicity here.
      iohk-module
    ];
  };
in
  pkgSet.config.hsPkgs // { _config = pkgSet.config; }
</code></pre>
<h3 id="defaultnix"><a class="header" href="#defaultnix"><code>default.nix</code></a></h3>
<pre><code class="language-nix">let
  localLib = import ./lib.nix;
in
# This file needs to export a function that takes
# the arguments it is passed and forwards them to
# the default-nix template from iohk-nix. This is
# important so that the release.nix file can properly
# parameterize this file when targetting different
# hosts.
{ ... }@args:
# We will instantiate the defaul-nix template with the
# nix/pkgs.nix file...
localLib.nix-tools.default-nix ./nix/pkgs.nix args
# ... and add a few custom packages as well.
// { }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dev-notes"><a class="header" href="#dev-notes">Dev Notes</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="developer-architecture-overview"><a class="header" href="#developer-architecture-overview">Developer Architecture Overview</a></h1>
<p>This shall give a sufficiently good overview over the haskell.nix
ideas, such that a new developer can navigate around without too
much trouble.</p>
<h2 id="packages-1"><a class="header" href="#packages-1">Packages</a></h2>
<p><code>haskell.nix</code> is centered around packages (haskell package
descriptions as nix-expressions). These are generated by
<code>cabal-to-nix</code> from the <code>nix-tools</code> package. <code>stack-to-nix</code> and
<code>plan-to-nix</code> will delegate the transformation of cabal packages to
nix expressions to the same code that <code>cabal-to-nix</code> uses.</p>
<p>These packages will look similar to the following:</p>
<pre><code class="language-nix">{ system, compiler, flags, pkgs, hsPkgs, pkgconfPkgs, ... }:
{
  flags = {};
  package = { ... };
  components = {
    &quot;library&quot; = { depends = [ ... ]; };
    exes = { &quot;...&quot; = { depends = [ ... ]; }; ... };
    sublibs = { &quot;...&quot; = { depends = [ ... ]; }; ... };
    tests = { &quot;...&quot; = { depends = [ ... ]; }; ... };
    benchmarks = { &quot;...&quot; = { depends = [ ... ]; }; ... };
  };
};
</code></pre>
<p>The exact specification can be found in <code>modules/package.nix</code>.</p>
<h2 id="plans"><a class="header" href="#plans">Plans</a></h2>
<p>Packages (unless specified directly in the <code>packages</code> attribute of the
module) usually come from a plan. A plan is either a Stackage snapshot
(nightly or LTS) or a build plan as produced by <code>cabal</code>.</p>
<p>Plan files usually look like the following:</p>
<pre><code class="language-nix">hackage:
{
  packages = {
    &quot;$pkg&quot;.revision = hackage.$pkg.$version.revisions.default;
    &quot;$pkg&quot;.flags = { flag1 = true; flag2 = false; ... };
	...
  };
  compiler = {
    version = &quot;8.4.4&quot;;
      nix-name = &quot;ghc844&quot;;
      packages = {
        &quot;binary&quot; = &quot;0.8.5.1&quot;;
	...
      };
   };
}
</code></pre>
<p>This provides enough information about the compiler, what packages the
compiler ships with and the packages we want to use in our plan.</p>
<p>This revision and flag information will be inlined into a list of
packages in <code>config.packages</code> in <code>modules/plan.nix</code>.  Thus
<code>config.packages</code> will only contains packages as described in the
previous section.</p>
<h2 id="package-sets-of-derivations"><a class="header" href="#package-sets-of-derivations">Package Sets (of derivations)</a></h2>
<p>We finally tie this all together in <code>package-set.nix</code> where we use
<code>modules/component-driver.nix</code> to produce the derivations for each
packages component to produce the final <code>config.hsPkgs</code> value.</p>
<p>There is also a <code>modules/compat-driver.nix</code> that should produce the
same packageset to be used with the stock haskell infrastructure in
nixpkgs (<em>This has undergone substantially less testing</em>).</p>
<h3 id="component-builder"><a class="header" href="#component-builder">Component builder</a></h3>
<p>To prevent depending on multiple instances of the same libraries, the
component builder will try to build every package from scratch and
rely as little as possible on packages that are shipped with the GHC
distribution. The exceptions are packages that are known to not be
reinstallable. See <code>config.nonReinstallablePkgs</code>.</p>
<p>The component builder can be found in <code>modules/component-driver.nix</code>
and <code>builder/default.nix</code>. The component-driver will ensure that we do
not try to rebuild non-reinstallable packages, and call the
<code>builder/default.nix</code> on each package in <code>config.packages</code> to produce
<code>config.hsPkgs</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="installing-nix-tools"><a class="header" href="#installing-nix-tools">Installing <code>nix-tools</code></a></h2>
<p>To build the latest <code>nix-tools</code> and store the result at <code>./nt</code>, run:</p>
<pre><code class="language-shell">nix build -f https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz pkgs.haskell-nix.nix-tools.ghc884 --out-link nt
</code></pre>
<p>If you would like to then install <code>nix-tools</code> into your profile, run:</p>
<pre><code class="language-shell">nix-env -i ./nt
</code></pre>
<h2 id="optional-installing-via-haskellnix-source"><a class="header" href="#optional-installing-via-haskellnix-source">Optional: Installing via <a href="https://github.com/input-output-hk/haskell.nix">Haskell.nix</a> source</a></h2>
<p>The <a href="https://github.com/input-output-hk/haskell.nix">Haskell.nix</a> and <code>nix-tools</code> source will be useful if you would
like to contribute improvements, or read the source code to fully
understand something that the documentation doesn't cover.</p>
<pre><code class="language-shell">git clone https://github.com/input-output-hk/nix-tools
git clone https://github.com/input-output-hk/haskell.nix
cd haskell.nix
nix build -f . pkgs.haskell-nix.nix-tools.ghc884 --arg sourcesOverride '{ nix-tools = ../nix-tools; }' --out-link nt
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="how-to-update-nix-tools"><a class="header" href="#how-to-update-nix-tools">How to update <a href="https://github.com/input-output-hk/nix-tools"><code>nix-tools</code></a></a></h2>
<ol>
<li>
<p>Use niv to update the sources.json:</p>
<pre><code class="language-shell">nix flake lock --update-input nix-tools
</code></pre>
</li>
<li>
<p>If <code>nix-tools.cabal</code> or <code>plan-to-nix</code> have changed, check the
materialized files for each of the compiler nix name in
<code>ls -d materialized/ghc*/nix-tools</code> with:</p>
<pre><code class="language-shell">nix-build scripts/check-compiler-materialization --argstr compiler-nix-name ghc884
</code></pre>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="manually-generating-nix-expressions"><a class="header" href="#manually-generating-nix-expressions">Manually generating Nix expressions</a></h1>
<p>We believe that imports from derivations (IFDs) provide tremendous
value in nix and the aversion towards them stems mostly from
poor tooling and ci support for them.  We do not believe
that poor tooling or ci support should cripple nix capability
of abstraction.  Hence haskell.nix makes excessive use of
IFDs.</p>
<p>We do note however that there are users who prefer to
have IFD-free expressions.  For this group of users we
detail how to expand the IFD dependent high level functions
into their IFD free building blocks.</p>
<p>The general structure will be the same, independent of the use of
Stack or Cabal.</p>
<p>Let us assume for now that we have already generated a <code>pkgs.nix</code>
expression (see the links bellow). The following file then produces a package set:</p>
<pre><code class="language-nix"># default.nix
let
  # Import the Haskell.nix library,
  pkgs = import &lt;nixpkgs&gt; (import (builtins.fetchTarball &quot;https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz&quot;) {}).nixpkgsArgs;

  # Import the file you will create in the stack-to-nix or cabal-to-nix step.
  my-pkgs = import ./pkgs.nix;

  # Stack projects use this:
  # pkgSet = pkgs.haskell-nix.mkStackPkgSet {
  #   stack-pkgs = my-pkgs;
  #   pkg-def-extras = [
  #     # these extras will provide additional packages
  #     # ontop of the package set.  E.g. extra-deps
  #     # for stack packages. or local packages for
  #     # cabal.projects
  #   ];
  #   modules = [
  #     # specific package overrides would go here
  #     # example:
  #     #  packages.cbors.package.ghcOptions = &quot;-Werror&quot;;
  #     #  packages.cbors.patches = [ ./one.patch ];
  #     #  packages.cbors.flags.optimize-gmp = false;
  #     # It may be better to set flags in stack.yaml instead
  #     # (`stack-to-nix` will include them as defaults).
  #   ];
  # };

  # Cabal projects use this:
  pkgSet = pkgs.haskell-nix.mkCabalProjectPkgSet {
    plan-pkgs = my-pkgs;
    pkg-def-extras = [];
    modules = [
      # specific package overrides would go here
      # example:
      #  packages.cbors.package.ghcOptions = &quot;-Werror&quot;;
      #  packages.cbors.patches = [ ./one.patch ];
      #  packages.cbors.flags.optimize-gmp = false;
      # It may be better to set flags in `cabal.project` instead
      # (`plan-to-nix` will include them as defaults).
    ];
  };

in pkgSet.config.hsPkgs // { _config = pkgSet.config; }
</code></pre>
<p>With this setup you can then start building the components of
interest:</p>
<pre><code class="language-shell">nix build -f default.nix $pkg.components.library
</code></pre>
<p>to build the library for <code>$pkg</code> or</p>
<pre><code class="language-shell">nix build -f default.nix $pkg.components.exes.$exe
</code></pre>
<p>to build a specific executable. The same holds for test suites and benchmarks.</p>
<h2 id="using-stack"><a class="header" href="#using-stack">Using Stack</a></h2>
<p>With <a href="dev/./installing-nix-tools.html">nix-tools installed</a>, we can simply run the
following command on a stack project:</p>
<pre><code class="language-shell">stack-to-nix --output . --stack-yaml stack.yaml
</code></pre>
<p>This will produce a <code>pkgs.nix</code> file that looks like the following:</p>
<pre><code class="language-nix">{
  resolver = &quot;lts-12.17&quot;;
  extras = hackage:
    {
      packages = {
        &quot;o-clock&quot; = hackage.o-clock.&quot;0.1.1&quot;.revisions.default;
        ...
      } // {
        my-package = ./my-package.nix;
        ...
      };
    };
}
</code></pre>
<p>This file contains the stackage resolver, as well as set of extra
packages.  The extras specifies which <code>extra-deps</code> (here:
<code>o-clock-0.1.1</code>) we wanted to add over the stackage snapshot, and what
local packages we want (here: <code>my-package</code>).</p>
<h2 id="using-cabal"><a class="header" href="#using-cabal">Using Cabal</a></h2>
<h3 id="generating-planjson"><a class="header" href="#generating-planjson">Generating <code>plan.json</code></a></h3>
<p>To get a plan, you need Cabal and GHC. See the <a href="https://nixos.org/nixpkgs/manual/#how-to-install-a-compiler">How to install a
compiler section of the Nixpkgs Manual</a> for information
about how to choose a specific compiler version.</p>
<blockquote>
<p><strong>Note:</strong> Cabal version</p>
<p>The minimum Cabal version is 2.4. This version is available
in the NixOS 19.03 release.</p>
</blockquote>
<p>For this example, we will run a <code>nix-shell</code> with the default GHC
version for Nixpkgs.</p>
<pre><code class="language-shell">nix-shell -p haskellPackages.cabal-install haskellPackages.ghc \
    --run &quot;cabal new-configure&quot;
</code></pre>
<p>If all goes well, you should now have the file
<code>dist-newstyle/cache/plan.json</code>.</p>
<blockquote>
<p><strong>Tip:</strong> Specifying the GHC version</p>
<p>To use a specific compiler version, replace <code>haskellPackages.ghc</code>
with something like <code>haskell-nix.compiler.ghc865</code>. The given compiler
must exist in your Nixpkgs version, of course. See also the
<a href="https://nixos.org/nixpkgs/manual/#how-to-install-a-compiler">Nixpkgs Manual</a>.</p>
</blockquote>
<h3 id="using-plan-to-nix"><a class="header" href="#using-plan-to-nix">Using <code>plan-to-nix</code></a></h3>
<p>With <a href="dev/./installing-nix-tools.html">nix-tools installed</a>, we can then run the
following command on a Cabal project and its build plan. Omit the
<code>--cabal-project</code> option if you don't have a project file.</p>
<pre><code class="language-shell"># convert the plan.json file into a pkgs.nix file
plan-to-nix --output . \
    --plan-json dist-newstyle/cache/plan.json
    --cabal-project cabal.project
</code></pre>
<p>This will produce a <code>pkgs.nix</code> file that looks like the following:</p>
<pre><code class="language-nix">{
  pkgs = hackage:
    {
      packages = {
        &quot;o-clock&quot; = hackage.o-clock.&quot;0.1.1&quot;.revisions.default;
        ...
      };
      compiler = { ... };
    };

  extras = hackage:
    { packages = { my-package = ./.plan.nix/my-package.nix; }; };
}
</code></pre>
<p>It has converted Cabal's build plan into a Nix expression that selects
dependencies from <code>hackage.nix</code>. All local packages in the project are
generated with <code>cabal-to-nix</code> and added to the package set
description.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="updating-hackage-and-stackage-nix-expressions"><a class="header" href="#updating-hackage-and-stackage-nix-expressions">Updating Hackage and Stackage Nix expressions</a></h1>
<p>The <a href="https://github.com/input-output-hk/hackage.nix"><code>hackage.nix</code></a>
and <a href="https://github.com/input-output-hk/stackage.nix"><code>stackage.nix</code></a>
repos and corresponding files <code>hackage-src.json</code> and
<code>stackage-src.json</code> will be regularly and automatically updated using
scripts in this repo.</p>
<p>To run the updater scripts manually, use:</p>
<pre><code class="language-shell">nix-build build.nix -A maintainer-scripts.update-hackage -o update-hackage.sh
./update-hackage.sh

nix-build build.nix -A maintainer-scripts.update-stackage -o update-stackage.sh
./update-stackage.sh
</code></pre>
<p>The scripts will clone the repo, generate the latest data, then
attempt to push back to the repo and update the source JSON file.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="haskellnix-nixpkgs-pin"><a class="header" href="#haskellnix-nixpkgs-pin">Haskell.nix Nixpkgs Pin</a></h1>
<p>Haskell.nix contains several Nixpkgs pins imanaged by <code>niv</code> in
<code>nix/sources.json</code>.</p>
<p>These are used in testing various versions of nixpkgs.</p>
<p>To use haskell.nix the <code>config</code> and <code>overlays</code> need to be applied to
Nixpkgs.  Users should probably pin a suitable version of nixpkgs, although things might not work for them if their Nixpkgs version is
too different.</p>
<p>We aim to keep this pin somewhere on a channel of the <strong>Nixpkgs latest
stable release</strong>. That is currently 20.09.</p>
<p>We also execute tests on MacOS (darwin). The darwin channel is usually
behind the NixOS channel. So we follow the <code>nixpkgs-20.09-darwin</code>
channel.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ghcwithpackages-wrapper-removal"><a class="header" href="#ghcwithpackages-wrapper-removal"><code>ghcWithPackages</code> wrapper removal</a></h1>
<p>The current <a href="https://nixos.org/nixpkgs/manual/#users-guide-to-the-haskell-infrastructure">Nixpkgs Haskell infrastructure</a> and <code>haskell.nix</code> both
provide a <code>ghcWithPackages</code> derivation which contains shell script
wrappers that wrap <code>ghc</code> and <code>ghc-pkg</code>.</p>
<p>In the Nixpkgs Haskell infrastructure, the wrapper scripts are used
for building Haskell packages. However, in <code>haskell.nix</code>, the wrappers
are only used for development environments.</p>
<p>The wrapper scripts provide a <code>ghc</code> command that &quot;knows&quot; about the
package set and has all Haskell package dependencies available to it.</p>
<p>We would like to remove the wrapper scripts, but it's currently not
possible to configure all build tools using environment variables
alone.</p>
<h2 id="plain-ghc"><a class="header" href="#plain-ghc">Plain <code>ghc</code></a></h2>
<p>When using <code>ghc</code> or <code>ghci</code> by itself, the <code>GHC_ENVIRONMENT</code> variable
can point to a configuration file containing an exact package
set. This works quite well.</p>
<h2 id="ghc-pkg"><a class="header" href="#ghc-pkg"><code>ghc-pkg</code></a></h2>
<p>The package tool <code>ghc-pkg</code> does not recognize <code>GHC_ENVIRONMENT</code>, but
does recognize a <code>GHC_PACKAGE_PATH</code> pointing to a <code>package.conf.d</code>.</p>
<p>This works well. However, the <code>cabal</code> command will refuse to start if
<code>GHC_PACKAGE_PATH</code> is set.</p>
<h2 id="setuphs"><a class="header" href="#setuphs"><code>Setup.hs</code></a></h2>
<p>When invoking <code>Setup.hs configure</code>, the package database is provided
with the <code>--package-db</code> argument and exact dependencies in the package
set can be provided as <code>--dependency</code> arguments.</p>
<p>The <code>haskell.nix</code> component builder uses <code>Setup.hs</code> with these
command-line options to build Haskell packages.</p>
<h2 id="cabal-new-build"><a class="header" href="#cabal-new-build"><code>cabal new-build</code></a></h2>
<p>Cabal-install will observe the <code>CABAL_CONFIG</code> environment variable,
which points to a cabal config file. This config file can provide a
<code>package-db</code> value, but it can't specify exact versions of packages.</p>
<p>Cabal is designed to solve dependencies, not simply take the package
set which is given to it.</p>
<p>Therefore, <code>cabal</code> does not use <code>GHC_ENVIRONMENT</code>, but instead creates
its own environment file. It will not accept <code>--dependency</code> arguments.</p>
<p>As far as I know, the best way to force <code>cabal</code> to take a pre-computed
package set is to use a <code>new-freeze</code> file. However there is no
environment variable (or config file entry) which can specify a path
to a freeze file.</p>
<p>Specifying a <code>package-db</code> path in the cabal config file is not enough
for it to successfully resolve dependencies.</p>
<p>As mentioned before, <code>cabal</code> does not work when <code>GHC_PACKAGE_PATH</code> is
set. The best way to work around this is to wrap <code>ghc</code> and <code>ghc-pkg</code>
in shell scripts.</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="haskell-infrastructure-test-cases"><a class="header" href="#haskell-infrastructure-test-cases">Haskell infrastructure test cases</a></h3>
<p>To build the test cases, run from the <code>test</code> directory:</p>
<pre><code class="language-shell">nix-build --no-out-link default.nix
</code></pre>
<p>To run all tests (includes impure tests), use the script:</p>
<pre><code class="language-shell">./tests.sh
</code></pre>
<h4 id="generated-code"><a class="header" href="#generated-code">Generated code</a></h4>
<p>If you change the test Cabal files or need to regenerate the code with
nix-tools, then see <code>regen.nix</code>. Run it like this:</p>
<pre><code class="language-shell">$(nix-build --no-out-link regen.nix)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="adding-a-new-ghc-version-to-haskellnix"><a class="header" href="#adding-a-new-ghc-version-to-haskellnix">Adding a new GHC version to haskell.nix</a></h1>
<h2 id="update-overlaysbootstrapnix"><a class="header" href="#update-overlaysbootstrapnix">Update <code>overlays/bootstrap.nix</code></a></h2>
<p>Each ghc version is defined in this file.  Duplicate one of the existing
ghc version definitions and replace the version numbers.  Make sure
you update the <code>spec.sha256</code> or the other versions source will be used.
Check the LLVM version that should be used in the
<a href="https://gitlab.haskell.org/ghc/ghc/-/wikis/commentary/compiler/backends/llvm/installing">ghc wiki</a>.</p>
<h2 id="update-the-list-of-cached-ghc-versions-in-cinix"><a class="header" href="#update-the-list-of-cached-ghc-versions-in-cinix">Update the list of cached GHC versions in <code>ci.nix</code></a></h2>
<h2 id="update-supported-ghc-versions-document"><a class="header" href="#update-supported-ghc-versions-document">Update <a href="dev/../reference/supported-ghc-versions.html">supported ghc versions</a> document</a></h2>
<h2 id="add-the-materialized-files"><a class="header" href="#add-the-materialized-files">Add the materialized files</a></h2>
<p>In the haskell.nix repo run:</p>
<pre><code class="language-shell">mkdir materialized/ghc884
nix-build scripts/check-compiler-materialization --argstr compiler-nix-name ghc884
</code></pre>
<p>The <code>nix-build</code> command will fail with something like:</p>
<pre><code>Materialized nix used for dummy-data-x86_64-unknown-linux-musl-ghc-8.10.1 incorrect. To fix run: /nix/store/wnwpyrhv4nxgyljz3f20gdpspjxvm7h4-updateMaterialized
</code></pre>
<p>Run the <code>updateMaterialized</code> script and repeat the <code>nix-build</code> until it no longer fails.
If the failure is not a problem with materialization and no <code>updateMaterialized</code> script
is provided then you may need to fix the failure another way or (if it only relates to
one of the cross compilers) modify <code>scripts/check-compiler-materialization/default.nix</code>
so that it skips that compiler.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="developer-coverage-overview"><a class="header" href="#developer-coverage-overview">Developer Coverage Overview</a></h1>
<h2 id="building"><a class="header" href="#building">Building</a></h2>
<p>The implementation of coverage starts with the &quot;doCoverage&quot; flag on
the builder in <code>comp-builder.nix</code>. The doCoverage flag enables and
disables the Cabal coverage flag and copies any generated coverage
data to &quot;$out/share/hpc&quot;.</p>
<h3 id="mix-and-tix-files"><a class="header" href="#mix-and-tix-files">Mix and tix files</a></h3>
<p>The coverage information for any derivation consists of &quot;mix&quot; and
&quot;tix&quot; files.</p>
<p>Mix files record static information about a source file and are
generated at build time. They primarily contain a path to the source
file and information about expressions and regions of the source file,
which are later referenced by tix files.</p>
<p>Tix files contain dynamic information about a test run, recording when
a portion of a source file is touched by a test. These are generated
when the test is run.</p>
<h3 id="multiple-local-packages"><a class="header" href="#multiple-local-packages">Multiple local packages</a></h3>
<p>In the context of multiple local packages, there are a few types of
coverage we might be interested in:</p>
<ul>
<li>How well does the tests for this package cover the package library?</li>
<li>How well does the tests for this package cover the libraries of
other packages in this project?</li>
<li>Both of the above.</li>
</ul>
<p>To facilitate expressing any of these classifications of coverage, the
<code>lib/cover.nix</code> function provides the <code>mixLibraries</code> argument. If
you're just interested in how the tests cover the package library, you
provide that library as an argument to <code>mixLibraries</code>. If you're
interested in how the tests also cover other local packages in the
project, you can also provide those libraries as arguments to
mixLibraries.</p>
<p>The <code>projectCoverageReport</code> and <code>coverageReport</code> attributes that are
provided by default on projects and packages respectively provide
coverage information for <em>all</em> local packages in the project. This is
to mimic the behaviour of Stack, which seems to be the expectation of
most people. Of course, you can use the <code>projectCoverageReport</code> and
<code>coverageReport</code> functions to construct your own custom coverage
reports (as detailed in the <a href="dev/../tutorials/coverage.html#custom">coverage tutorial</a>).</p>
<h2 id="coverage-reports"><a class="header" href="#coverage-reports">Coverage reports</a></h2>
<h3 id="package-reports"><a class="header" href="#package-reports">Package reports</a></h3>
<p>The coverage information generated will look something like this:</p>
<pre><code class="language-shell">/nix/store/...-my-project-0.1.0.0-coverage-report/
└── share
    └── hpc
        └── vanilla
            ├── html
            │   └── my-library-0.1.0.0
            │       ├── my-library-0.1.0.0-48EVZBwW9Kj29VTaRMhBDf
            │       │   ├── My.Lib.Config.hs.html
            │       │   ├── My.Lib.Types.hs.html
            │       │   └── My.Lib.Util.hs.html
            │       ├── hpc_index_alt.html
            │       ├── hpc_index_exp.html
            │       ├── hpc_index_fun.html
            │       └── hpc_index.html
            ├── mix
            │   └── my-library-0.1.0.0
            │       └── my-library-0.1.0.0-48EVZBwW9Kj29VTaRMhBDf
            │           ├── My.Lib.Config.mix
            │           ├── My.Lib.Types.mix
            │           └── My.Lib.Util.mix
            └── tix
                └── my-library-0.1.0.0
                    ├── my-library-0.1.0.0.tix
                    ├── my-test-1
                    │   └── my-test-1.tix
                    └── unit-test
                        └── unit-test.tix
</code></pre>
<ul>
<li>The mix files are copied verbatim from the library built with
coverage.</li>
<li>The tix files for each test are copied from the check run verbatim
and are output to &quot;.../tix/<libraryname>/<testname>/<testname>.tix&quot;.</li>
<li>The tix files for each library are generated by summing the tix
files for each test, but excluding any test modules. This tix file
is output to &quot;.../tix/<libraryname>/<libraryname>.tix&quot;.
<ul>
<li>Test modules are determined by inspecting the plan for the project
(i.e. for the project &quot;my-project&quot; and test-suite &quot;my-test-1&quot;, the
test modules are read from:
<code>my-project.checks.my-test-1.config.modules</code>)</li>
</ul>
</li>
<li>The hpc HTML reports for each library are generated from their
respective tix files (i.e. the
<code>share/hpc/vanilla/html/my-library-0.1.0.0</code> report is generated from
the
<code>share/hpc/vanilla/tix/my-library-0.1.0.0/my-library-0.1.0.0.tix</code>
file)</li>
</ul>
<h3 id="project-wide-reports"><a class="header" href="#project-wide-reports">Project-wide reports</a></h3>
<p>The coverage information for an entire project will look something
like this:</p>
<pre><code class="language-shell">/nix/store/...-coverage-report
└── share
    └── hpc
        └── vanilla
            ├── html
            │   ├── index.html
            │   ├── all
            │   │   ├── my-library-0.1.0.0-ERSaOroBZhe9awsoBkhmcV
            │   │   │   ├── My.Lib.Config.hs.html
            │   │   │   ├── My.Lib.Types.hs.html
            │   │   │   └── My.Lib.Util.hs.html
            │   │   ├── other-library-0.1.0.0-48EVZBwW9Kj29VTaRMhBDf
            │   │   │   ├── Other.Lib.A.hs.html
            │   │   │   └── Other.Lib.B.hs.html
            │   │   ├── hpc_index_alt.html
            │   │   ├── hpc_index_exp.html
            │   │   ├── hpc_index_fun.html
            │   │   └── hpc_index.html
            │   ├── my-library-0.1.0.0
            │   │   ├── my-library-0.1.0.0-ERSaOroBZhe9awsoBkhmcV
            │   │   │   ├── My.Lib.Config.hs.html
            │   │   │   ├── My.Lib.Types.hs.html
            │   │   │   └── My.Lib.Util.hs.html
            │   │   ├── hpc_index_alt.html
            │   │   ├── hpc_index_exp.html
            │   │   ├── hpc_index_fun.html
            │   │   └── hpc_index.html
            │   └── other-libray-0.1.0.0
            │       ├── other-library-0.1.0.0-48EVZBwW9Kj29VTaRMhBDf
            │       │   ├── Other.Lib.A.hs.html
            │       │   └── Other.Lib.B.hs.html
            │       ├── hpc_index_alt.html
            │       ├── hpc_index_exp.html
            │       ├── hpc_index_fun.html
            │       └── hpc_index.html
            ├── mix
            │   ├── my-library-0.1.0.0-ERSaOroBZhe9awsoBkhmcV
            │   │   ├── My.Lib.Config.mix
            │   │   ├── My.Lib.Types.mix
            │   │   └── My.Lib.Util.mix
            │   └── other-library-0.1.0.0-48EVZBwW9Kj29VTaRMhBDf
            │       ├── Other.Lib.A.mix
            │       └── Other.Lib.B.mix
            └── tix
                ├── all
                │   └── all.tix
                ├── my-library-0.1.0.0
                │   ├── my-library-0.1.0.0.tix
                │   ├── my-test-1
                │   │   └── my-test-1.tix
                │   └── unit-test
                │       └── unit-test.tix
                └── another-library-0.1.0.0
                    ├── another-library-0.1.0.0.tix
                    ├── my-test-2
                    │   └── my-test-2.tix
                    └── unit-test
                        └── unit-test.tix
</code></pre>
<p>All of the coverage information is copied verbatim from the coverage
reports for each of the constituent packages. A few additions are
made:</p>
<ul>
<li><code>tix/all/all.tix</code> is generated from the union of all the library
tix files.
<ul>
<li>We use this file when generating coverage reports for
&quot;coveralls.io&quot;.</li>
</ul>
</li>
<li>An index page (<code>html/index.html</code>) is generated which links to the
HTML coverage reports of the constituent packages.</li>
<li>A synthetic HTML report is generated from the <code>tix/all/all.tix</code>
file. This shows the union of all the coverage information
generated by each constituent coverage report.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="making-changes-to-hix"><a class="header" href="#making-changes-to-hix">Making changes to Hix</a></h1>
<p>When making changes to the way Hix works it is often useful to be able to
test the changes locally before uploading them to github.</p>
<h2 id="hix-command-wrappers"><a class="header" href="#hix-command-wrappers">Hix Command Wrappers</a></h2>
<p>Install the hix command wrappers after making changes to a local clone of haskell.nix:</p>
<pre><code class="language-shell">nix-env -iA hix -f /path/to/local/haskell.nix
hix-shell
</code></pre>
<p>Or override the version of haskell.nix used by the commands with the <code>HIX_ROOT</code> environment variable:</p>
<pre><code class="language-shell">HIX_ROOT=/path/to/local/haskell.nix hix-shell
</code></pre>
<h2 id="flakes"><a class="header" href="#flakes">Flakes</a></h2>
<p>For flakes use <code>--override-input</code> to point to the modified haskell.nix:</p>
<pre><code class="language-shell">nix develop --override-input haskellNix /path/to/local/haskell.nix
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>This file contains a summary of changes to Haskell.nix and <code>nix-tools</code>
that will impact users.</p>
<h2 id="jul-27-2022"><a class="header" href="#jul-27-2022">Jul 27, 2022</a></h2>
<ul>
<li>
<p>Removed reliance on <code>builtins.currentSystem</code>.  It was used it to provide
<code>pkgs.evalPackages</code> via an overlay that it used to run derivations
used in imports from derivation (IFDs).</p>
<p>These derivations are now run on <code>buildPackages</code> by default.</p>
<p>Passsing <code>evalPackages</code> to a project function will change where all the
derivations used in IFDs are run for that project (including shell tools):
evalPackages = import nixpkgs haskellNix.nixpkgsArgs;</p>
<p>Passing <code>evalSystem</code> instead will use create a suitable <code>nixpkgs</code> using <code>pkgs.path</code>
and <code>pkgs.overlay</code>:
evalSystem = &quot;x86_64-linux&quot;;
or
evalSystem = builtins.currentSystem;</p>
<p>The <code>haskellLib.cleanGit</code> function is also affected by this change.  If you are cross
compiling and using <code>cleanGit</code> you should probably do something like:
pkgs = import nixpkgs haskellNix.nixpkgsArgs;
evalPackages = import nixpkgs (haskellNix.nixpkgsArgs // { system = evalSystem; });
p = pkgs.pkgsCross.mingwW64.haskell-nix.cabalProject {
inherit evalPackages;
src = evalPackages.haskell-nix.haskellLib.cleanGit { src = ./.; };
};</p>
</li>
</ul>
<h2 id="feb-16-2022"><a class="header" href="#feb-16-2022">Feb 16, 2022</a></h2>
<ul>
<li>Removed lookupSha256 argument from project functions.
Pass a <code>sha256map</code> instead.</li>
<li>Added better support for <code>repository</code> in <code>cabal.project</code>.  These
blocks should now work without the need for passing <code>extra-hackages</code> and
<code>extra-hackage-tarballs</code>.</li>
</ul>
<h2 id="aug-6-2021"><a class="header" href="#aug-6-2021">Aug 6, 2021</a></h2>
<ul>
<li>Included dependencies of haskell.nix that were tracked in <code>nix/sources.json</code>
as flake inputs (<code>flake.lock</code> replaces <code>nix/sources.json</code>).</li>
<li>Uses <code>flake-compat</code> to continue to provide a compatible interface for non
flake projects.</li>
</ul>
<h2 id="jul-23-2021"><a class="header" href="#jul-23-2021">Jul 23, 2021</a></h2>
<ul>
<li><code>source-repository-package</code> references in <code>cabal.project</code> files are now
left as a <code>source-repository-package</code> when calculating the the <code>plan-nix</code> for
<code>cabalProject</code> based functions.
This makes haskell.nix match the behaviour of <code>cabal</code> better.
Materialized files for projects that use <code>source-repository-package</code>
references will need to be updated.</li>
<li>Only planned components are included in a haskell.nix cabal project.
If cabal solver does not include the component in the <code>plan.json</code> file it
will not be present in <code>hsPkgs.pkg.components</code>.</li>
<li>When the same package occurs more than once in a plan.json file
the latest version is picked by haskell.nix.</li>
</ul>
<h2 id="apr-8-2021"><a class="header" href="#apr-8-2021">Apr 8, 2021</a></h2>
<ul>
<li>Project arguments are now validated with the Nix module system.
If unexpected argments are passed to a project function this may now
result in an error.</li>
</ul>
<h2 id="feb-22-2021"><a class="header" href="#feb-22-2021">Feb 22, 2021</a></h2>
<ul>
<li>Add <code>.dwarf</code> to build any component with DWARF dubug info on linux
(ghc &gt;=8.10.2).</li>
<li>Pass <code>enableDWARF</code> to <code>shellFor</code> for to get a shell where all the
components are the <code>.dwarf</code> ones.</li>
</ul>
<h2 id="feb-18-2021"><a class="header" href="#feb-18-2021">Feb 18, 2021</a></h2>
<ul>
<li><code>ghcOptions</code> has been moved from package and is now a list of strings.
old: packages.x.package.ghcOptions = &quot;someGHCoption&quot;;
new: packages.x.ghcOptions = [&quot;someGHCoption&quot;];
To specify ghcOptions for all packages:
ghcOptions = [&quot;someGHCoption&quot;];
For a single component:
packages.x.compoents.library.ghcOptions = [&quot;someGHCoption&quot;];</li>
</ul>
<h2 id="feb-8-2021"><a class="header" href="#feb-8-2021">Feb 8, 2021</a></h2>
<ul>
<li>Removed older versions of haskell-language-server from custom-tools
(0.8.0 is in hackage so we can still get that version).</li>
</ul>
<h2 id="jan-14-2021"><a class="header" href="#jan-14-2021">Jan 14, 2021</a></h2>
<ul>
<li>Added support for cross package refs (with a project).  Relative
directory references between packages within a project should now
work.</li>
<li>Added <code>includeSiblings</code> to <code>cleanSourceWith</code>.  When <code>true</code> it
prevents the <code>subDir</code> arg from causing filtering of other directories.</li>
<li>Added <code>keepGitDir</code> to <code>cleanGit</code> to allow <code>.git</code> directory to be kept
(useful for components that use the <code>githash</code> package).</li>
</ul>
<h2 id="nov-26-2020"><a class="header" href="#nov-26-2020">Nov 26, 2020</a></h2>
<ul>
<li>Renamed <code>otherShells</code> arg for <code>shellFor</code> to `inputsFrom</li>
</ul>
<h2 id="nov-25-2020"><a class="header" href="#nov-25-2020">Nov 25, 2020</a></h2>
<ul>
<li>The <code>shellFor</code> <code>makeConfigFiles</code> <code>ghcWithHoogle</code> and <code>ghcWithPackages</code>
functions have been removed from <code>project.hsPkgs</code>.  Instead access
them from <code>project</code> itself (e.g. change <code>p.hsPkgs.shellFor</code> to <code>p.shellFor</code>).</li>
<li>The reflex-platform like <code>project.shells.ghc</code> has been removed.
If needed, add something like <code>p // { shells.ghc = p.shellFor {} }</code>
to <code>shell.nix</code>.</li>
</ul>
<h2 id="nov-24-2020"><a class="header" href="#nov-24-2020">Nov 24, 2020</a></h2>
<ul>
<li>Added <code>${targetPrefix}cabal</code> wrapper script for running cross
compilers in <code>shellFor</code>.</li>
<li><code>otherShells</code> arg added to <code>shellFor</code>.</li>
</ul>
<h2 id="oct-31-2020"><a class="header" href="#oct-31-2020">Oct 31, 2020</a></h2>
<ul>
<li>Passing <code>tools.hoogle</code> to <code>shellFor</code> with a value suitable for <code>haskel-nix.tool</code> will
use the specified <code>hoogle</code> inside <code>shellFor</code>. This allows for materialization
of <code>hoogle</code>.</li>
</ul>
<h2 id="oct-28-2020"><a class="header" href="#oct-28-2020">Oct 28, 2020</a></h2>
<ul>
<li>Passing <code>compiler-nix-name</code> to project functions for <code>stack.yaml</code>
based projects now overrides the compiler used (was ignored before).</li>
</ul>
<h2 id="sep-8-2020"><a class="header" href="#sep-8-2020">Sep 8, 2020</a></h2>
<ul>
<li>Added the ability to generate coverage reports for packages and
projects.</li>
<li>Added the <code>doCoverage</code> module option that allows users to choose
packages to enable coverage for.</li>
<li>Added a <code>doCoverage</code> flag to the component builder that outputs HPC
information when coverage is enabled.</li>
<li>Added test for coverage.</li>
</ul>
<h2 id="july-21-2020"><a class="header" href="#july-21-2020">July 21, 2020</a></h2>
<ul>
<li>Removed <code>components.all</code>, use <code>symlinkJoin</code> on components.exes or
<code>shellFor</code> if you need a shell.</li>
<li>Added <code>components</code> argument to <code>shellFor</code>.</li>
</ul>
<h2 id="july-21-2020-1"><a class="header" href="#july-21-2020-1">July 21, 2020</a></h2>
<ul>
<li>Added GHC 8.8.4 and replaced 8.8.3 in tests and as the ghc
used to build nix-tools for stack projects.</li>
</ul>
<h2 id="july-20-2020"><a class="header" href="#july-20-2020">July 20, 2020</a></h2>
<ul>
<li>Changed <code>haskell-nix.roots</code> and <code>p.roots</code> to single derivations.</li>
</ul>
<h2 id="july-8-2020"><a class="header" href="#july-8-2020">July 8, 2020</a></h2>
<ul>
<li>Removed <code>sources.nixpkgs-default</code>, use <code>sources.nixpkgs</code> instead.</li>
<li>Removed <code>./nixpkgs</code> directory, use  <code>(import ./. {}).sources</code>
or <code>./nix/sources.nix</code> instead.</li>
<li>Removes V1 interface for details on how to fix old code see:
https://github.com/input-output-hk/haskell.nix/issues/709</li>
<li>Removed defaultCompilerNixName.</li>
<li>cabalProject, cabalProject', hackage-project and hackage-package
now require a <code>compiler-nix-name</code> argument.</li>
<li><code>haskell-nix.tool</code> and <code>.tools</code> now require a <code>compiler-nix-name</code> argument.
New functions <code>p.tool</code> and <code>p.tools</code> (where p is a project) do not.
Like <code>shellFor { tools = ... }</code> they will use the compiler nix name
from the project (including stack projects where it is derived from
the resolver).</li>
<li><code>haskell-nix.alex</code> and <code>haskell-nix.happy</code> have been removed. Use
<code>p.tool &quot;alex&quot; &quot;3.2.5&quot;</code> or <code>shellFor { tools = { alex = &quot;3.2.5&quot;; } }</code>.</li>
<li><code>haskell-nix.nix-tools</code> -&gt; <code>haskell-nix.nix-tools.ghc883</code> (it includes
the hpack exe now).</li>
<li><code>haskell-nix.cabal-install</code> -&gt;
<code>p.tool &quot;cabal&quot; &quot;3.2.0.0&quot;</code> or <code>shellFor { tools = { cabal = &quot;3.2.0.0&quot;; } }</code></li>
<li><code>haskell-nix.haskellNixRoots</code> -&gt; <code>haskell-nix.roots ghc883</code> or <code>p.roots</code></li>
</ul>
<h2 id="june-25-2020"><a class="header" href="#june-25-2020">June 25, 2020</a></h2>
<ul>
<li>Haddock docs are now built in their own derivation when needed (not as part
of the component build).
They should build automatically when something (such as <code>shellFor</code>) attempts
to accesses the <code>.doc</code> attribute of component.</li>
</ul>
<h2 id="december-27-2019"><a class="header" href="#december-27-2019">December 27, 2019</a></h2>
<ul>
<li>Fix overlays/bootstrap.nix to provide LLVM 6, not LLVM 5, to ghc-8.6.X compilers.</li>
</ul>
<h2 id="november-18-2019"><a class="header" href="#november-18-2019">November 18, 2019</a></h2>
<ul>
<li>Changed the <code>cleanSourceHaskell</code> to accept an attrset of <code>src</code> and
(optional) <code>name</code> parameters. This allows you to keep the source
derivation name constant, so that your builds are always
cached. Usage of <code>cleanSourceHaskell</code> will need to be updated.</li>
</ul>
<h2 id="october-12-2019"><a class="header" href="#october-12-2019">October 12, 2019</a></h2>
<ul>
<li><a href="https://input-output-hk.github.io/haskell.nix/reference/library/#shellfor"><code>shellFor</code></a> no longer sets <code>CABAL_CONFIG</code> by default.
This avoids surprising users, but means that Cabal may select a plan which is different to your Haskell.nix package set.
If you would like the old behaviour, use <code>shellFor { exactDeps = true; }</code>.</li>
</ul>
<h2 id="august-9-2019"><a class="header" href="#august-9-2019">August 9, 2019</a></h2>
<ul>
<li>Add the <a href="https://input-output-hk.github.io/haskell.nix/reference/library/#haskellLib"><code>haskellLib.collectComponents</code></a> function.</li>
</ul>
<h2 id="june-21-2019"><a class="header" href="#june-21-2019">June 21, 2019</a></h2>
<ul>
<li>Add <code>ghcWithPackages</code> and <code>ghcWithHoogle</code> to hsPkgs (<a href="https://input-output-hk.github.io/haskell.nix/reference/library/#package-set-functions">documentation</a>.</li>
<li>Benchmark components can now build successfully.</li>
<li>Reduced the closure bloat of nix-tools, and added closure size limit to CI.</li>
<li>Added more reference documentation and set up auto-generated
documentation for <a href="https://input-output-hk.github.io/haskell.nix/reference/modules/">Module Options</a>.</li>
<li>Miscellaneous bug fixes.</li>
</ul>
<h2 id="june-7-2019"><a class="header" href="#june-7-2019">June 7, 2019</a></h2>
<ul>
<li>Several additions to the <a href="https://input-output-hk.github.io/haskell.nix/">documentation</a>.
<ul>
<li>More information about getting nix-tools, Haskell.nix, pinning.</li>
<li>Updates the stack-to-nix and cabal-to-nix guides.</li>
<li>Adds a section on development environments.</li>
<li>Adds a little information about cross compilation.</li>
<li>Adds a (partially complete) reference section (command line manuals, library reference).</li>
<li>Symlinks the changelog into the documentation pages.</li>
</ul>
</li>
</ul>
<h2 id="may-29-2019"><a class="header" href="#may-29-2019">May 29, 2019</a></h2>
<ul>
<li>Added <code>shellFor</code> function to package set.</li>
</ul>
<h2 id="may-28-2019"><a class="header" href="#may-28-2019">May 28, 2019</a></h2>
<ul>
<li>Added <code>snaphots</code> and <code>haskellPackages</code> attributes to the
Haskell.nix top-level.</li>
</ul>
<h2 id="may-22-2019"><a class="header" href="#may-22-2019">May 22, 2019</a></h2>
<ul>
<li>Add the <code>cleanSourceHaskell</code> utility function to the Haskell.nix
top-level.</li>
</ul>
<h2 id="may-21-2019"><a class="header" href="#may-21-2019">May 21, 2019</a></h2>
<ul>
<li>Add the <code>callCabalProjectToNix</code> function, which uses &quot;import from
derivation&quot; (IFD) so that nix-tools doesn't need to be run
manually.</li>
<li>The <code>hackage.nix</code> update process has changed, so that Cabal index
state hashes are also included in the generated repo.</li>
</ul>
<h2 id="may-20-2019"><a class="header" href="#may-20-2019">May 20, 2019</a></h2>
<ul>
<li>Remove Travis CI in favour of Buildkite.</li>
</ul>
<h2 id="may-17-2019"><a class="header" href="#may-17-2019">May 17, 2019</a></h2>
<ul>
<li>Add the <code>callStackToNix</code> function, which uses &quot;import from
derivation&quot; (IFD) so that <code>stack-to-nix</code> doesn't need to be run
manually.</li>
</ul>
<h2 id="mar-15-2019"><a class="header" href="#mar-15-2019">Mar 15, 2019</a></h2>
<ul>
<li>
<p><code>overlays</code> was renamed to <code>extras</code> in
<a href="https://github.com/input-output-hk/haskell.nix/pull/79">#79</a>
to prevent confusion between the notion of Nix overlays.</p>
<p>Therefore <code>plan-pkgs</code> and <code>stack-pkgs</code> as generated by <code>plan-to-nix</code> and <code>stack-to-nix</code> will
expose <code>extras</code> instead of <code>overlay</code>. Similarly <code>mkStackPkgSet</code>, <code>mkPkgSet</code> and <code>mkCabalProjectPkgSet</code>
take a <code>pkg-def-extras</code> instead of <code>pkg-def-overlay</code> argument.  If you are using <code>iohk-nix</code>, the
<code>iohk-overlay</code> was parameter was renamed to <code>iohk-extras</code>.</p>
</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
