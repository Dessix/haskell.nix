<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Haskell.nix Library - Alternative Haskell Infrastructure for Nixpkgs</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="../motivation.html"><strong aria-hidden="true">2.</strong> Motivation</a></li><li class="chapter-item expanded "><a href="../architecture.html"><strong aria-hidden="true">3.</strong> Architecture</a></li><li class="chapter-item expanded "><a href="../tutorials/index.html"><strong aria-hidden="true">4.</strong> Tutorials</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../tutorials/getting-started.html"><strong aria-hidden="true">4.1.</strong> Getting started</a></li><li class="chapter-item expanded "><a href="../tutorials/getting-started-flakes.html"><strong aria-hidden="true">4.2.</strong> Getting started with Flakes</a></li><li class="chapter-item expanded "><a href="../tutorials/getting-started-hix.html"><strong aria-hidden="true">4.3.</strong> Getting started with Hix</a></li><li class="chapter-item expanded "><a href="../tutorials/development.html"><strong aria-hidden="true">4.4.</strong> Creating a development environment</a></li><li class="chapter-item expanded "><a href="../tutorials/clean-git.html"><strong aria-hidden="true">4.5.</strong> Sourcing files only part of git repository using cleanGit</a></li><li class="chapter-item expanded "><a href="../tutorials/source-repository-hashes.html"><strong aria-hidden="true">4.6.</strong> Handling git repositories in projects</a></li><li class="chapter-item expanded "><a href="../tutorials/pkg-map.html"><strong aria-hidden="true">4.7.</strong> Mapping non-Haskell dependencies to Nixpkgs</a></li><li class="chapter-item expanded "><a href="../tutorials/hackage-stackage.html"><strong aria-hidden="true">4.8.</strong> Bumping Hackage and Stackage snapshots</a></li><li class="chapter-item expanded "><a href="../tutorials/materialization.html"><strong aria-hidden="true">4.9.</strong> Materialization: Speeding up Nix evaluation</a></li><li class="chapter-item expanded "><a href="../tutorials/cross-compilation.html"><strong aria-hidden="true">4.10.</strong> Cross-compiling your project</a></li><li class="chapter-item expanded "><a href="../tutorials/coverage.html"><strong aria-hidden="true">4.11.</strong> Generating coverage information</a></li><li class="chapter-item expanded "><a href="../tutorials/building-package-from-stackage-hackage.html"><strong aria-hidden="true">4.12.</strong> Build a specific package from Hackage or Stackage</a></li><li class="chapter-item expanded "><a href="../tutorials/ca-derivations.html"><strong aria-hidden="true">4.13.</strong> Content addressed derivations</a></li></ol></li><li class="chapter-item expanded "><a href="../reference/index.html"><strong aria-hidden="true">5.</strong> Reference</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../reference/supported-ghc-versions.html"><strong aria-hidden="true">5.1.</strong> Supported GHC versions</a></li><li class="chapter-item expanded "><a href="../reference/commands.html"><strong aria-hidden="true">5.2.</strong> Command-line tools</a></li><li class="chapter-item expanded "><a href="../reference/library.html" class="active"><strong aria-hidden="true">5.3.</strong> Haskell.nix Library</a></li><li class="chapter-item expanded "><a href="../reference/modules.html"><strong aria-hidden="true">5.4.</strong> Module options</a></li><li class="chapter-item expanded "><a href="../troubleshooting.html"><strong aria-hidden="true">5.5.</strong> Troubleshooting</a></li></ol></li><li class="chapter-item expanded "><a href="../template/index.html"><strong aria-hidden="true">6.</strong> Templates / Abstraction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../template/iohk-nix.html"><strong aria-hidden="true">6.1.</strong> IOHKs nix library</a></li></ol></li><li class="chapter-item expanded "><a href="../dev/index.html"><strong aria-hidden="true">7.</strong> Dev Notes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../dev/dev-architecture.html"><strong aria-hidden="true">7.1.</strong> Architecture</a></li><li class="chapter-item expanded "><a href="../dev/installing-nix-tools.html"><strong aria-hidden="true">7.2.</strong> Installing nix-tools</a></li><li class="chapter-item expanded "><a href="../dev/nix-tools-pin.html"><strong aria-hidden="true">7.3.</strong> How to update nix-tools</a></li><li class="chapter-item expanded "><a href="../dev/manually-generating-nix-expressions.html"><strong aria-hidden="true">7.4.</strong> Manually generating Nix expressions</a></li><li class="chapter-item expanded "><a href="../dev/maintainer-scripts.html"><strong aria-hidden="true">7.5.</strong> Maintainer Scripts</a></li><li class="chapter-item expanded "><a href="../dev/nixpkgs-pin.html"><strong aria-hidden="true">7.6.</strong> Nixpkgs Pin</a></li><li class="chapter-item expanded "><a href="../dev/removing-with-package-wrapper.html"><strong aria-hidden="true">7.7.</strong> Removing withPackage wrapper</a></li><li class="chapter-item expanded "><a href="../dev/tests.html"><strong aria-hidden="true">7.8.</strong> Test Suite</a></li><li class="chapter-item expanded "><a href="../dev/adding-new-ghc.html"><strong aria-hidden="true">7.9.</strong> Adding a new GHC version</a></li><li class="chapter-item expanded "><a href="../dev/coverage.html"><strong aria-hidden="true">7.10.</strong> Coverage</a></li><li class="chapter-item expanded "><a href="../dev/hix.html"><strong aria-hidden="true">7.11.</strong> Making changes to Hix</a></li><li class="chapter-item expanded "><a href="../changelog.html"><strong aria-hidden="true">7.12.</strong> ChangeLog</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Alternative Haskell Infrastructure for Nixpkgs</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p><a href="https://github.com/input-output-hk/haskell.nix">Haskell.nix</a> contains a library of functions for creating buildable
package sets from their Nix expression descriptions. The library is
what you get when importing <a href="https://github.com/input-output-hk/haskell.nix">Haskell.nix</a>. It might be helpful to
load the library in the <a href="../tutorials/development.html#using-nix-repl">Nix REPL</a> to
test things.</p>
<ul>
<li><a href="#data-structures">Data structures</a> — the kinds of data that you will encounter working with <a href="https://github.com/input-output-hk/haskell.nix">Haskell.nix</a>.</li>
<li><a href="#top-level-attributes">Top-level attributes</a> — Functions and derivations defined in the Haskell.nix attrset.</li>
<li><a href="#package-set-functions">Package-set functions</a> — Helper functions defined on the <code>hsPkgs</code> package set.</li>
</ul>
<h1 id="data-structures"><a class="header" href="#data-structures">Data structures</a></h1>
<h2 id="package-set"><a class="header" href="#package-set">Package Set</a></h2>
<p>The result of <code>mkPkgSet</code>. This is an application of the NixOS module
system.</p>
<pre><code class="language-nix">{
  options = { ... };
  config = {
    hsPkgs = { ... };
    packages = { ... };
    compiler = {
      version = &quot;X.Y.Z&quot;;
      nix-name = &quot;ghcXYZ&quot;;
      packages = { ... };
    };
  };
}
</code></pre>
<div class="table-wrapper"><table><thead><tr><th>Attribute</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>options</code></td><td>Module options</td><td>The combination of all options set through the <code>modules</code> argument passed to <code>mkPkgsSet</code>.</td></tr>
<tr><td><code>config</code></td><td></td><td>The result of evaluating and applying the <code>options</code> with <a href="https://github.com/input-output-hk/haskell.nix">Haskell.nix</a></td></tr>
<tr><td><code>.hsPkgs</code></td><td>Attrset of <a href="#haskell-package">Haskell Packages</a></td><td>Buildable packages, created from <code>packages</code></td></tr>
<tr><td><code>.packages</code></td><td>Attrset of <a href="#haskell-package-descriptions">Haskell Package descriptions</a></td><td>Configuration for each package in <code>hsPkgs</code></td></tr>
<tr><td><code>.compiler</code></td><td>Attrset</td><td></td></tr>
</tbody></table>
</div>
<h2 id="haskell-package-description"><a class="header" href="#haskell-package-description">Haskell Package description</a></h2>
<p>The <em>Haskell package descriptions</em> are values of the
<code>pkgSet.config.packages</code> attrset. These are not derivations, but just
the configuration for building an individual package. The
configuration options are described under <code>packages.&lt;name&gt;</code> in <a href="./modules.html">Module
options</a>.</p>
<h2 id="component-description"><a class="header" href="#component-description">Component description</a></h2>
<p>The <em>component descriptions</em> are values of the
<code>pkgSet.config.packages.&lt;package&gt;.components</code> attrset. These are not
derivations, but just the configuration for building an individual
component. The configuration options are described under
<code>packages.&lt;name&gt;.components.*</code> in <a href="./modules.html">Module options</a>.</p>
<h2 id="haskell-package"><a class="header" href="#haskell-package">Haskell Package</a></h2>
<p>In <a href="https://github.com/input-output-hk/haskell.nix">Haskell.nix</a>, a <em>Haskell package</em> is a derivation which has a
<code>components</code> attribute. This derivation is actually just for the
package <code>Setup.hs</code> script, and isn't very interesting. To actually use
the package, look within the components structure.</p>
<pre><code class="language-nix">components = {
  library = COMPONENT;
  exes = { NAME = COMPONENT; };
  tests = { NAME = COMPONENT; };
  benchmarks = { NAME = COMPONENT; };
}
</code></pre>
<h2 id="component"><a class="header" href="#component">Component</a></h2>
<p>In <a href="https://github.com/input-output-hk/haskell.nix">Haskell.nix</a>, a <em>component</em> is a derivation corresponding to a
<a href="https://www.haskell.org/cabal/users-guide/developing-packages.html">Cabal component</a>
of a package.</p>
<h2 id="identifier"><a class="header" href="#identifier">Identifier</a></h2>
<p>A package identifier is an attrset pair of <code>name</code> and <code>version</code>.</p>
<h2 id="extras"><a class="header" href="#extras">Extras</a></h2>
<p>Extras allow adding more packages to the package set. These will be
functions taking a single parameter <code>hackage</code>. They should return an
attrset of package descriptions.</p>
<h2 id="modules"><a class="header" href="#modules">Modules</a></h2>
<p>Modules are the primary method of configuring building of the package
set. They are either:</p>
<ol>
<li>an attrset containing <a href="./modules.html">option declarations</a>, or</li>
<li>a function that returns an attrset containing option declarations.</li>
</ol>
<p>If using the function form of a module, the following named parameters
will be passed to it:</p>
<div class="table-wrapper"><table><thead><tr><th>Argument</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>haskellLib</code></td><td>attrset</td><td>The <a href="#haskelllib">haskellLib</a> utility functions.</td></tr>
<tr><td><code>pkgs</code></td><td></td><td>The Nixpkgs collection.</td></tr>
<tr><td><code>pkgconfPkgs</code></td><td></td><td>A mapping of cabal build-depends names to Nixpkgs packages. (TODO: more information about this)</td></tr>
<tr><td><code>buildModules</code></td><td></td><td></td></tr>
<tr><td><code>config</code></td><td></td><td></td></tr>
<tr><td><code>options</code></td><td></td><td></td></tr>
</tbody></table>
</div>
<h1 id="top-level-attributes"><a class="header" href="#top-level-attributes">Top-level attributes</a></h1>
<h2 id="project"><a class="header" href="#project">project'</a></h2>
<p>Function that accepts attribute set with a <code>src</code> attribute and looks for <code>stack.yaml</code> file relative to it.</p>
<p>If file exists, it calls <a href="#stackproject&#x27;">stackProject</a> function. Otherwise it will call <a href="#cabalproject&#x27;">cabalProject</a> function.</p>
<p><strong>Example</strong>:</p>
<pre><code class="language-nix">pkgs.haskell-nix.project' {
  # 'cleanGit' cleans a source directory based on the files known by git
  src = pkgs.haskell-nix.haskellLib.cleanGit {
    name = &quot;haskell-nix-project&quot;;
    src = ./.;
  };
}
</code></pre>
<h2 id="stackproject"><a class="header" href="#stackproject">stackProject'</a></h2>
<p>A function calling <a href="#callstacktonix">callStackToNix</a> with all arguments.</p>
<p>Then feeding its result into <a href="#mkstackpkgset">mkStackPkgSet</a> passing also
<code>pkg-def-extras</code> and <code>modules</code> arguments.</p>
<p><strong>Return value</strong>:</p>
<div class="table-wrapper"><table><thead><tr><th>Attribute</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>hsPkgs</code></td><td>Attrset of <a href="#haskell-package">Haskell Packages</a></td><td>Buildable packages, created from <code>packages</code></td></tr>
<tr><td><code>stack-nix</code></td><td></td><td><code>projectNix</code> attribute of <a href="#callstacktonix"><code>callStackToNix</code></a> return value</td></tr>
<tr><td><code>shellFor</code></td><td>Function</td><td><a href="#shellfor"><code>shellFor</code></a></td></tr>
<tr><td><code>ghcWithHoogle</code></td><td>Function</td><td><a href="#ghcwithhoogle"><code>ghcWithHoogle</code></a></td></tr>
<tr><td><code>ghcWithPackages</code></td><td>Function</td><td><a href="#ghcwithpackages"><code>ghcWithPackages</code></a></td></tr>
</tbody></table>
</div>
<h2 id="cabalproject"><a class="header" href="#cabalproject">cabalProject'</a></h2>
<p>A function calling <a href="#callcabalprojecttonix">callCabalProjectToNix</a> with all arguments.</p>
<p>Then feeding its result into <a href="#mkcabalprojectpkgset">mkCabalProjectPkgSet</a> passing also
<code>pkg-def-extras</code>, <code>extra-hackages</code> and <code>modules</code> arguments.</p>
<p><strong>Return value</strong>:</p>
<div class="table-wrapper"><table><thead><tr><th>Attribute</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>hsPkgs</code></td><td>Attrset of <a href="#haskell-package">Haskell Packages</a></td><td>Buildable packages, created from <code>packages</code></td></tr>
<tr><td><code>plan-nix</code></td><td></td><td><code>projectNix</code> attribute of <a href="#callcabalprojecttonix"><code>callCabalProjectToNix</code></a> return value</td></tr>
<tr><td><code>index-state</code></td><td></td><td><code>index-state</code> attribute of <a href="#callcabalprojecttonix"><code>callCabalProjectToNix</code></a> return value</td></tr>
<tr><td><code>shellFor</code></td><td>Function</td><td><a href="#shellfor"><code>shellFor</code></a></td></tr>
<tr><td><code>ghcWithHoogle</code></td><td>Function</td><td><a href="#ghcwithhoogle"><code>ghcWithHoogle</code></a></td></tr>
<tr><td><code>ghcWithPackages</code></td><td>Function</td><td><a href="#ghcwithpackages"><code>ghcWithPackages</code></a></td></tr>
<tr><td><code>projectCross</code></td><td>Attrset</td><td>Like <code>pkgs.pkgsCross.&lt;system&gt;</code> from nixpkgs <code>p.projectCross.&lt;system&gt;</code> returns the project results for cross compilation (where system is a member of nixpkgs lib.systems.examples).  So <code>p.projectCross.ghcjs.hsPkgs</code> is the same as <code>hsPkgs</code> but compiled with ghcjs</td></tr>
<tr><td><code>projectVariants</code></td><td>Attrset</td><td>Attribute set of variant for the project, mapped from <code>flake.variants</code> config values</td></tr>
<tr><td><code>appendModule</code></td><td>Function</td><td>Re-eval the project with an extra module (or module list).</td></tr>
<tr><td><code>extend</code> and <code>appendOverlays</code></td><td>Function</td><td>Modify a project, or add attributes, through overlays: <code>p.extend(final: prev: { })</code>. The overlays are carried-over <code>projectCross</code> and <code>appendModule</code> invocations.</td></tr>
</tbody></table>
</div>
<h2 id="project-cabalproject-and-stackproject"><a class="header" href="#project-cabalproject-and-stackproject">project, cabalProject and stackProject</a></h2>
<p>These versions of the function are the same as project', cabalProject'
and stackProject', but <code>hsPkgs</code> attributes are also included in the
return value directly.  That way a package can be referenced as
<code>(project {...}).foo</code> instead of <code>(project' {...}).hsPkgs.foo</code>.</p>
<h2 id="mkstackpkgset"><a class="header" href="#mkstackpkgset">mkStackPkgSet</a></h2>
<p>Creates a <a href="#package-set">package set</a> based on the <code>pkgs.nix</code> output
of <code>stack-to-nix</code>.</p>
<pre><code class="language-nix">mkStackPkgSet =
    { stack-pkgs, pkg-def-extras ? [], modules ? []}: ...
</code></pre>
<div class="table-wrapper"><table><thead><tr><th>Argument</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>stack-pkgs</code></td><td></td><td><code>import ./pkgs.nix</code> — The imported file generated by <code>stack‑to‑nix</code>.</td></tr>
<tr><td><code>pkg‑def‑extras</code></td><td>List of <a href="#extras">Extras</a></td><td>For overriding the package set.</td></tr>
<tr><td><code>modules</code></td><td>List of <a href="#modules">Modules</a></td><td>For overriding the package set.</td></tr>
</tbody></table>
</div>
<p><strong>Return value</strong>: a <a href="#package-set"><code>pkgSet</code></a></p>
<h2 id="mkcabalprojectpkgset"><a class="header" href="#mkcabalprojectpkgset">mkCabalProjectPkgSet</a></h2>
<p>Creates a <a href="#package-set">package set</a> based on the <code>pkgs.nix</code> output
of <code>plan-to-nix</code>.</p>
<pre><code class="language-nix">mkCabalProjectPkgSet =
    { plan-pkgs, pkg-def-extras ? [], modules ? []}: ...
</code></pre>
<div class="table-wrapper"><table><thead><tr><th>Argument</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>plan-pkgs</code></td><td></td><td><code>import ./pkgs.nix</code> — The imported file generated by <code>plan‑to‑nix</code>.</td></tr>
<tr><td><code>pkg‑def‑extras</code></td><td>List of <a href="#extras">Extras</a></td><td>For overriding the package set.</td></tr>
<tr><td><code>modules</code></td><td>List of <a href="#modules">Modules</a></td><td>For overriding the package set.</td></tr>
</tbody></table>
</div>
<p><strong>Return value</strong>: a <a href="#package-set"><code>pkgSet</code></a></p>
<h2 id="mkpkgset"><a class="header" href="#mkpkgset">mkPkgSet</a></h2>
<p>This is the base function used by both <code>mkStackPkgSet</code> and
<code>mkCabalProjectPkgSet</code>.</p>
<p><strong>Return value</strong>: a <a href="#package-set"><code>pkgSet</code></a></p>
<h2 id="snapshots"><a class="header" href="#snapshots">snapshots</a></h2>
<p>This is an attrset of <code>hsPkgs</code> packages from Stackage.</p>
<h2 id="haskellpackages"><a class="header" href="#haskellpackages">haskellPackages</a></h2>
<p>A <code>hsPkgs</code> package set, which is one of the recent LTS Haskell
releases from <a href="#snapshots"><code>snapshots</code></a>.</p>
<p>The chosen LTS is updated occasionally in <a href="https://github.com/input-output-hk/haskell.nix">Haskell.nix</a>, though a
manual process.</p>
<h2 id="nix-tools"><a class="header" href="#nix-tools">nix-tools</a></h2>
<p>A derivation containing the <code>nix-tools</code> <a href="commands.html">command-line tools</a>.</p>
<h2 id="callstacktonix"><a class="header" href="#callstacktonix">callStackToNix</a></h2>
<p>Runs <code>stack-to-nix</code> and produces the output needed for
<code>importAndFilterProject</code>.</p>
<p><strong>Example</strong>:</p>
<pre><code class="language-nix">  pkgSet = mkStackPkgSet {
    stack-pkgs = (importAndFilterProject (callStackToNix {
      src = ./.;
    })).pkgs;
    pkg-def-extras = [];
    modules = [];
  };
</code></pre>
<h2 id="callcabalprojecttonix"><a class="header" href="#callcabalprojecttonix">callCabalProjectToNix</a></h2>
<p>Runs <code>cabal new-configure</code> and <code>plan-to-nix</code> and produces the output
needed for <code>importAndFilterProject</code>.</p>
<p><strong>Example</strong>:</p>
<pre><code class="language-nix">  pkgSet = mkCabalProjectPkgSet {
    plan-pkgs = (importAndFilterProject (callCabalProjectToNix {
      index-state = &quot;2019-04-30T00:00:00Z&quot;;
      src = ./.;
    })).pkgs;
</code></pre>
<div class="table-wrapper"><table><thead><tr><th>Argument</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>name</code></td><td>String</td><td>Optional name for better error messages.</td></tr>
<tr><td><code>src</code></td><td>Path</td><td>Location of the cabal project files.</td></tr>
<tr><td><code>compiler-nix-name</code></td><td>String</td><td>The name of the ghc compiler to use eg. &quot;ghc884&quot;</td></tr>
<tr><td><code>index-state</code></td><td>Timestamp</td><td>Optional hackage index-state, eg. &quot;2019-10-10T00:00:00Z&quot;.</td></tr>
<tr><td><code>index-sha256</code></td><td>Sha256</td><td>Optional hash of the truncated hackage index-state.</td></tr>
<tr><td><code>plan-sha256</code></td><td>Sha256</td><td>Optional hash of the plan-to-nix output (makes the plan-to-nix step a fixed output derivation).</td></tr>
<tr><td><code>cabalProject</code></td><td>String</td><td>Optional cabal project file contents (defaults to readFile &quot;${src}/cabal.project&quot;).</td></tr>
<tr><td><code>cabalProjectLocal</code></td><td>String</td><td>Optional cabal project file contents (defaults to readFile &quot;${src}/cabal.project.local&quot;).</td></tr>
<tr><td><code>cabalProjectFreeze</code></td><td>String</td><td>Optional cabal project file contents (defaults to readFile &quot;${src}/cabal.project.freeze&quot;).</td></tr>
<tr><td><code>ghc</code></td><td></td><td>Deprecated. Use <code>compiler-nix-name</code> instead. Optional ghc to use</td></tr>
<tr><td><code>nix-tools</code></td><td></td><td>Optional nix-tools to use</td></tr>
<tr><td><code>hpack</code></td><td></td><td>Optional hpack to use</td></tr>
<tr><td><code>cabal-install</code></td><td></td><td>Optional cabal-install to use</td></tr>
<tr><td><code>configureArgs</code></td><td>String</td><td>Optional extra arguments to pass to <code>cabal new-configure</code> (--enable-tests is included by default, include <code>--disable-tests</code> to override that).</td></tr>
</tbody></table>
</div>
<h2 id="importandfilterproject"><a class="header" href="#importandfilterproject">importAndFilterProject</a></h2>
<p>Imports from a derivation created by <code>callStackToNix</code>
or <code>callCabalProjectToNix</code>.</p>
<p>The result is an attrset with the following values:</p>
<div class="table-wrapper"><table><thead><tr><th>Attribute</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>pkgs</code></td><td>attrset</td><td>that can be passed to <code>mkStackPkgSet</code> (as <code>stack-pkgs</code>) or <code>mkCabalProjectPkgSet</code> (as <code>plan-pkgs</code>).</td></tr>
<tr><td><code>nix</code></td><td></td><td>this can be built and cached so that the amount built in the evaluation phase is not too great (helps to avoid timeouts on Hydra).</td></tr>
</tbody></table>
</div>
<h2 id="hackage"><a class="header" href="#hackage">hackage</a></h2>
<h2 id="stackage"><a class="header" href="#stackage">stackage</a></h2>
<h2 id="fetchexternal"><a class="header" href="#fetchexternal">fetchExternal</a></h2>
<h2 id="cleansourcehaskell"><a class="header" href="#cleansourcehaskell">cleanSourceHaskell</a></h2>
<pre><code class="language-nix">cleanSourceHaskell = { src, name ? null }: ...
</code></pre>
<p>Filters a source tree removing common filenames that are not Haskell
build sources.</p>
<p>This can avoid unecessary rebuilds when these files change.</p>
<p>It's recommended to provide <code>name</code> so that the source derivation
remains constant regardless of how it was fetched.</p>
<p>Example:</p>
<pre><code class="language-nix">src = pkgs.haskell-nix.cleanSourceHaskell {
  src = ./.;
  name = &quot;myproject-src&quot;;
};
</code></pre>
<h2 id="haskellsourcefilter"><a class="header" href="#haskellsourcefilter">haskellSourceFilter</a></h2>
<pre><code class="language-nix">haskellSourceFilter = name: type: ...
</code></pre>
<p>This is a source filter function which cleans common build products
and files not needed to do a Haskell build from a source directory.</p>
<p>It should be used with <code>pkgs.lib.cleanSourceWith</code>. Alternatively,
use the convenience function <a href="#cleansourcehaskell"><code>cleanSourceHaskell</code></a>.</p>
<h2 id="haskelllib"><a class="header" href="#haskelllib">haskellLib</a></h2>
<p>Assorted functions for operating on <a href="https://github.com/input-output-hk/haskell.nix">Haskell.nix</a> data. This is
distinct from <code>pkgs.haskell.lib</code> in the current Nixpkgs Haskell
Infrastructure.</p>
<h3 id="collectcomponents-collectcomponents"><a class="header" href="#collectcomponents-collectcomponents">collectComponents, collectComponents'</a></h3>
<p>Extracts a selection of components from a Haskell <a href="#package-set">package set</a>.</p>
<p>This can be used to filter out all test suites or benchmarks of
your project, so that they can be built in Hydra (see check if you
want to run the tests as well as build them).</p>
<p><code>collectComponents'</code> is an alias of <code>collectComponents</code> without
predicate for filtering.</p>
<pre><code class="language-nix">collectComponents =
    group: packageSel: haskellPackages: ...
collectComponents' = group: collectComponents (_: true)
</code></pre>
<div class="table-wrapper"><table><thead><tr><th>Argument</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>group</code></td><td>String</td><td>A <a href="#subComponentTypes">sub-component type</a>.</td></tr>
<tr><td><code>packageSel</code></td><td>A function <code>Package -&gt; Bool</code></td><td>A predicate to filter packages with.</td></tr>
<tr><td><code>haskellPackages</code></td><td><a href="#package-set">Package set</a></td><td>All packages in the build.</td></tr>
</tbody></table>
</div>
<p><strong>Return value</strong>: a recursive attrset mapping package names → component names → components.</p>
<p><strong>Example</strong>:</p>
<pre><code class="language-nix">tests = collectComponents &quot;tests&quot; (package: package.identifier.name == &quot;mypackage&quot;) hsPkgs;
</code></pre>
<p>Will result in moving derivations from <code>hsPkgs.mypackage.components.tests.unit-tests</code>
to <code>tests.mypackage.unit-tests</code>.</p>
<h3 id="collectchecks-collectchecks"><a class="header" href="#collectchecks-collectchecks">collectChecks, collectChecks'</a></h3>
<p>These are just like <code>collectComponents</code> and <code>collectComponents'</code>, except that they collect
the <code>checks</code> attributes of packages (which aren't components, and so can't be collected
by the other functions.</p>
<h4 id="check"><a class="header" href="#check">check</a></h4>
<p>This function turns a derivation that builds a test into one to run it.</p>
<div class="table-wrapper"><table><thead><tr><th>Argument</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>drv</code></td><td>Derivation</td><td>One of <code>$pkg.components.tests.$test</code>.</td></tr>
</tbody></table>
</div>
<p>For convenience <code>$pkg.components.tests</code> are mapped with this function
to <code>$pkg.checks</code>.</p>
<p>This function is intended for use with <code>tests</code> but it should also work
for <code>exes</code> and <code>benchmarks</code> if you just want to run them to make sure
they execute.</p>
<h4 id="subcomponenttypes"><a class="header" href="#subcomponenttypes">subComponentTypes</a></h4>
<p>Sub-component types identify <a href="#component">components</a> and are one of:</p>
<ul>
<li><code>sublibs</code></li>
<li><code>foreignlibs</code></li>
<li><code>exes</code></li>
<li><code>tests</code></li>
<li><code>benchmarks</code></li>
</ul>
<h1 id="project-functions"><a class="header" href="#project-functions">Project functions</a></h1>
<p>These functions are included in the <code>project</code> return values.
In the past they also existed within <code>project.hsPkgs</code>,
but have now been removed from there.</p>
<h2 id="shellfor"><a class="header" href="#shellfor">shellFor</a></h2>
<p>Create a <code>nix-shell</code> <a href="../tutorials/development.html">development
environment</a> for developing one or more
packages with <code>ghci</code> or <code>cabal v2-build</code> (but not Stack).</p>
<pre><code class="language-nix">shellFor =
    { packages, withHoogle ? true, exactDeps ? false, ...}: ...
</code></pre>
<div class="table-wrapper"><table><thead><tr><th>Argument</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>packages</code></td><td>Function</td><td>Package selection function. It takes a list of <a href="#haskell-package">Haskell packages</a> and returns a subset of these packages.</td></tr>
<tr><td><code>components</code></td><td>Function</td><td>Similar to <code>packages</code>, by default all the components of the selected packages are selected.</td></tr>
<tr><td><code>additional</code></td><td>Function</td><td>Similar to <code>packages</code>, but the selected packages are built and included in <code>ghc-pkg list</code> (not just their dependencies).</td></tr>
<tr><td><code>withHoogle</code></td><td>Boolean</td><td>Whether to build a Hoogle documentation index and provide the <code>hoogle</code> command.</td></tr>
<tr><td><code>exactDeps</code></td><td>Boolean</td><td>Prevents the Cabal solver from choosing any package dependency other than what are in the package set.</td></tr>
<tr><td><code>tools</code></td><td>Function</td><td>AttrSet of tools to make available e.g. <code>{ cabal = &quot;3.2.0.0&quot;; }</code> or <code>{ cabal = { version = &quot;3.2.0.0&quot;; }; }</code>. If an AttrSet is provided for a tool, the additional arguments will be passed to the function creating the derivation for that tool. So you can provide an <code>index-state</code> or a <code>materialized</code> argument like that <code>{ cabal = { version = &quot;3.2.0.0&quot;; index-state = &quot;2020-10-30T00:00:00Z&quot;; materialized = ./cabal.materialized; }; }</code> for example. You can specify and materialize the version of hoogle used to construct the hoogle index by including something like <code>{ hoogle = { version = &quot;5.0.17.15&quot;; index-state = &quot;2020-05-31T00:00:00Z&quot;; materialized = ./hoogle.materialized; }</code>. Uses a default version of hoogle if omitted.</td></tr>
<tr><td><code>inputsFrom</code></td><td>List</td><td>List of other shells to include in this one.  The <code>buildInputs</code> and <code>nativeBuildInputs</code> of each will be included using <a href="https://nixos.org/manual/nixpkgs/stable/#sec-pkgs-mkShell">mkShell</a>.</td></tr>
<tr><td><code>crossPlatforms</code></td><td>Function</td><td>Platform selection function for cross compilation targets to support eg. <code>ps: with ps; [ghcjs mingwW64]</code> (see nixpkgs lib.systems.examples for list of platform names).</td></tr>
<tr><td><code>{ ... }</code></td><td>Attrset</td><td>All the other arguments are passed to <a href="https://nixos.org/nixpkgs/manual/#sec-using-stdenv"><code>mkDerivation</code></a>.</td></tr>
</tbody></table>
</div>
<p><strong>Return value</strong>: a derivation</p>
<blockquote>
<p>⚠️ <strong>Warning:</strong></p>
<p><code>exactDeps = true</code> will set the <code>CABAL_CONFIG</code> environment variable
to disable remote package servers. This is a
<a href="../dev/removing-with-package-wrapper.html">known limitation</a>
which we would like to solve. Use <code>exactDeps = false</code> if this is a
problem.</p>
</blockquote>
<h2 id="ghcwithpackages"><a class="header" href="#ghcwithpackages">ghcWithPackages</a></h2>
<p>Creates a <code>nix-shell</code> <a href="../tutorials/development.html">development
environment</a> including the given
packages selected from this package set.</p>
<p><strong>Parameter</strong>: a package selection function.</p>
<p><strong>Return value</strong>: a derivation</p>
<p><strong>Example</strong>:</p>
<pre><code class="language-nix">haskell.haskellPackages.ghcWithPackages (ps: with ps; [ lens conduit ])
</code></pre>
<h2 id="ghcwithhoogle"><a class="header" href="#ghcwithhoogle">ghcWithHoogle</a></h2>
<p>The same as <code>ghcWithPackages</code>, except, a <code>hoogle</code> command with a
Hoogle documentation index of the packages will be included in the
shell.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../reference/commands.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../reference/modules.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../reference/commands.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../reference/modules.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
