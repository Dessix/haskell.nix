<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  
  <link rel="shortcut icon" href="../img/favicon.ico">
  <title>Haskell.nix Library - Alternative Haskell Infrastructure for Nixpkgs</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700" />

  <link rel="stylesheet" href="../css/theme.css" />
  <link rel="stylesheet" href="../css/theme_extra.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/github.min.css" />
  
  <script>
    // Current page data
    var mkdocs_page_name = "Haskell.nix Library";
    var mkdocs_page_input_path = "reference/library.md";
    var mkdocs_page_url = null;
  </script>
  
  <script src="../js/jquery-2.1.1.min.js" defer></script>
  <script src="../js/modernizr-2.8.3.min.js" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
        <a href="../index.html" class="icon icon-home"> Alternative Haskell Infrastructure for Nixpkgs</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../index.html">Introduction</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../motivation.html">Motivation</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../architecture.html">Architecture</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">Tutorials</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../tutorials/getting-started.html">Getting started</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../tutorials/getting-started-flakes.html">Getting started with Flakes</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../tutorials/getting-started-hix.html">Getting started with Hix</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../tutorials/development.html">Creating a development environment</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../tutorials/clean-git.html">Sourcing files only part of git repository using cleanGit</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../tutorials/source-repository-hashes.html">Handling git repositories in projects</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../tutorials/pkg-map.html">Mapping non-Haskell dependencies to Nixpkgs</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../tutorials/hackage-stackage.html">Bumping Hackage and Stackage snapshots</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../tutorials/materialization.html">Materialization: Speeding up Nix evaluation</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../tutorials/cross-compilation.html">Cross-compiling your project</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../tutorials/coverage.html">Generating coverage information</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../tutorials/building-package-from-stackage-hackage.html">Build a specific package from Hackage or Stackage</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../tutorials/ca-derivations.html">Content addressed derivations</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">Reference</span></p>
                <ul class="current">
                    <li class="toctree-l1"><a class="reference internal" href="supported-ghc-versions.html">Supported GHC versions</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="commands.html">Command-line tools</a>
                    </li>
                    <li class="toctree-l1 current"><a class="reference internal current" href="library.html">Haskell.nix Library</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#package-set">Package Set</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#haskell-package-description">Haskell Package description</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#component-description">Component description</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#haskell-package">Haskell Package</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#component">Component</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#identifier">Identifier</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#extras">Extras</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#modules">Modules</a>
    </li>
    </ul>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="modules.html">Module options</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../troubleshooting.html">Troubleshooting</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">Templates / Abstraction</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../iohk-nix.html">IOHKs nix library</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">Dev Notes</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../dev/dev-architecture.html">Architecture</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../dev/installing-nix-tools.html">Installing nix-tools</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../dev/nix-tools-pin.html">How to update nix-tools</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../dev/manually-generating-nix-expressions.html">Manually generating Nix expressions</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../dev/maintainer-scripts.html">Maintainer Scripts</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../dev/nixpkgs-pin.html">Nixpkgs Pin</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../dev/removing-with-package-wrapper.html">Removing withPackage wrapper</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../dev/tests.html">Test Suite</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../dev/adding-new-ghc.html">Adding a new GHC version</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../dev/coverage.html">Coverage</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../dev/hix.html">Making changes to Hix</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../changelog.html">ChangeLog</a>
                    </li>
                </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../index.html">Alternative Haskell Infrastructure for Nixpkgs</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../index.html">Docs</a> &raquo;</li>
    
      
        
          <li>Reference &raquo;</li>
        
      
    
    <li>Haskell.nix Library</li>
    <li class="wy-breadcrumbs-aside">
      
        <a href="https://github.com/input-output-hk/haskell.nix/edit/master/docs/reference/library.md"
          class="icon icon-github"> Edit on GitHub</a>
      
    </li>
  </ul>
  
  <hr/>
</div>

          <div role="main">
            <div class="section">
              
                <p><a href="https://github.com/input-output-hk/haskell.nix">Haskell.nix</a> contains a library of functions for creating buildable
package sets from their Nix expression descriptions. The library is
what you get when importing <a href="https://github.com/input-output-hk/haskell.nix">Haskell.nix</a>. It might be helpful to
load the library in the <a href="../tutorials/development.html#using-nix-repl">Nix REPL</a> to
test things.</p>
<ul>
<li><a href="#data-structures">Data structures</a> — the kinds of data that you will encounter working with <a href="https://github.com/input-output-hk/haskell.nix">Haskell.nix</a>.</li>
<li><a href="#top-level-attributes">Top-level attributes</a> — Functions and derivations defined in the Haskell.nix attrset.</li>
<li><a href="#package-set-functions">Package-set functions</a> — Helper functions defined on the <code>hsPkgs</code> package set.</li>
</ul>
<h1 id="data-structures">Data structures<a class="headerlink" href="#data-structures" title="Permanent link">&para;</a></h1>
<h2 id="package-set">Package Set<a class="headerlink" href="#package-set" title="Permanent link">&para;</a></h2>
<p>The result of <code>mkPkgSet</code>. This is an application of the NixOS module
system.</p>
<pre><code>{
  options = { ... };
  config = {
    hsPkgs = { ... };
    packages = { ... };
    compiler = {
      version = &quot;X.Y.Z&quot;;
      nix-name = &quot;ghcXYZ&quot;;
      packages = { ... };
    };
  };
}
</code></pre>
<table>
<thead>
<tr>
<th>Attribute</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>options</code></td>
<td>Module options</td>
<td>The combination of all options set through the <code>modules</code> argument passed to <code>mkPkgsSet</code>.</td>
</tr>
<tr>
<td><code>config</code></td>
<td></td>
<td>The result of evaluating and applying the <code>options</code> with <a href="https://github.com/input-output-hk/haskell.nix">Haskell.nix</a></td>
</tr>
<tr>
<td><code>.hsPkgs</code></td>
<td>Attrset of <a href="#haskell-package">Haskell Packages</a></td>
<td>Buildable packages, created from <code>packages</code></td>
</tr>
<tr>
<td><code>.packages</code></td>
<td>Attrset of <a href="#haskell-package-descriptions">Haskell Package descriptions</a></td>
<td>Configuration for each package in <code>hsPkgs</code></td>
</tr>
<tr>
<td><code>.compiler</code></td>
<td>Attrset</td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="haskell-package-description">Haskell Package description<a class="headerlink" href="#haskell-package-description" title="Permanent link">&para;</a></h2>
<p>The <em>Haskell package descriptions</em> are values of the
<code>pkgSet.config.packages</code> attrset. These are not derivations, but just
the configuration for building an individual package. The
configuration options are described under <code>packages.&lt;name&gt;</code> in <a href="modules.html">Module
options</a>.</p>
<h2 id="component-description">Component description<a class="headerlink" href="#component-description" title="Permanent link">&para;</a></h2>
<p>The <em>component descriptions</em> are values of the
<code>pkgSet.config.packages.&lt;package&gt;.components</code> attrset. These are not
derivations, but just the configuration for building an individual
component. The configuration options are described under
<code>packages.&lt;name&gt;.components.*</code> in <a href="modules.html">Module options</a>.</p>
<h2 id="haskell-package">Haskell Package<a class="headerlink" href="#haskell-package" title="Permanent link">&para;</a></h2>
<p>In <a href="https://github.com/input-output-hk/haskell.nix">Haskell.nix</a>, a <em>Haskell package</em> is a derivation which has a
<code>components</code> attribute. This derivation is actually just for the
package <code>Setup.hs</code> script, and isn't very interesting. To actually use
the package, look within the components structure.</p>
<pre><code>components = {
  library = COMPONENT;
  exes = { NAME = COMPONENT; };
  tests = { NAME = COMPONENT; };
  benchmarks = { NAME = COMPONENT; };
}
</code></pre>
<h2 id="component">Component<a class="headerlink" href="#component" title="Permanent link">&para;</a></h2>
<p>In <a href="https://github.com/input-output-hk/haskell.nix">Haskell.nix</a>, a <em>component</em> is a derivation corresponding to a
<a href="https://www.haskell.org/cabal/users-guide/developing-packages.html">Cabal component</a>
of a package.</p>
<h2 id="identifier">Identifier<a class="headerlink" href="#identifier" title="Permanent link">&para;</a></h2>
<p>A package identifier is an attrset pair of <code>name</code> and <code>version</code>.</p>
<h2 id="extras">Extras<a class="headerlink" href="#extras" title="Permanent link">&para;</a></h2>
<p>Extras allow adding more packages to the package set. These will be
functions taking a single parameter <code>hackage</code>. They should return an
attrset of package descriptions.</p>
<h2 id="modules">Modules<a class="headerlink" href="#modules" title="Permanent link">&para;</a></h2>
<p>Modules are the primary method of configuring building of the package
set. They are either:</p>
<ol>
<li>an attrset containing <a href="modules.html">option declarations</a>, or</li>
<li>a function that returns an attrset containing option declarations.</li>
</ol>
<p>If using the function form of a module, the following named parameters
will be passed to it:</p>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>haskellLib</code></td>
<td>attrset</td>
<td>The <a href="#haskelllib">haskellLib</a> utility functions.</td>
</tr>
<tr>
<td><code>pkgs</code></td>
<td></td>
<td>The Nixpkgs collection.</td>
</tr>
<tr>
<td><code>pkgconfPkgs</code></td>
<td></td>
<td>A mapping of cabal build-depends names to Nixpkgs packages. (TODO: more information about this)</td>
</tr>
<tr>
<td><code>buildModules</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>config</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>options</code></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h1 id="top-level-attributes">Top-level attributes<a class="headerlink" href="#top-level-attributes" title="Permanent link">&para;</a></h1>
<h2 id="project">project'<a class="headerlink" href="#project" title="Permanent link">&para;</a></h2>
<p>Function that accepts attribute set with a <code>src</code> attribute and looks for <code>stack.yaml</code> file relative to it.</p>
<p>If file exists, it calls <a href="#stackproject" title=") function. Otherwise it will call [cabalProject](#cabalproject">stackProject</a> function.</p>
<p><strong>Example</strong>:</p>
<pre><code class="language-nix">pkgs.haskell-nix.project' {
  # 'cleanGit' cleans a source directory based on the files known by git
  src = pkgs.haskell-nix.haskellLib.cleanGit {
    name = &quot;haskell-nix-project&quot;;
    src = ./.;
  };
}
</code></pre>
<h2 id="stackproject">stackProject'<a class="headerlink" href="#stackproject" title="Permanent link">&para;</a></h2>
<p>A function calling <a href="#callstacktonix">callStackToNix</a> with all arguments.</p>
<p>Then feeding its result into <a href="#mkstackpkgset">mkStackPkgSet</a> passing also
<code>pkg-def-extras</code> and <code>modules</code> arguments.</p>
<p><strong>Return value</strong>:</p>
<table>
<thead>
<tr>
<th>Attribute</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>hsPkgs</code></td>
<td>Attrset of <a href="#haskell-package">Haskell Packages</a></td>
<td>Buildable packages, created from <code>packages</code></td>
</tr>
<tr>
<td><code>stack-nix</code></td>
<td></td>
<td><code>projectNix</code> attribute of <a href="#callstacktonix"><code>callStackToNix</code></a> return value</td>
</tr>
<tr>
<td><code>shellFor</code></td>
<td>Function</td>
<td><a href="#shellfor"><code>shellFor</code></a></td>
</tr>
<tr>
<td><code>ghcWithHoogle</code></td>
<td>Function</td>
<td><a href="#ghcwithhoogle"><code>ghcWithHoogle</code></a></td>
</tr>
<tr>
<td><code>ghcWithPackages</code></td>
<td>Function</td>
<td><a href="#ghcwithpackages"><code>ghcWithPackages</code></a></td>
</tr>
</tbody>
</table>
<h2 id="cabalproject">cabalProject'<a class="headerlink" href="#cabalproject" title="Permanent link">&para;</a></h2>
<p>A function calling <a href="#callcabalprojecttonix">callCabalProjectToNix</a> with all arguments.</p>
<p>Then feeding its result into <a href="#mkcabalprojectpkgset">mkCabalProjectPkgSet</a> passing also
<code>pkg-def-extras</code>, <code>extra-hackages</code> and <code>modules</code> arguments.</p>
<p><strong>Return value</strong>:</p>
<table>
<thead>
<tr>
<th>Attribute</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>hsPkgs</code></td>
<td>Attrset of <a href="#haskell-package">Haskell Packages</a></td>
<td>Buildable packages, created from <code>packages</code></td>
</tr>
<tr>
<td><code>plan-nix</code></td>
<td></td>
<td><code>projectNix</code> attribute of <a href="#callcabalprojecttonix"><code>callCabalProjectToNix</code></a> return value</td>
</tr>
<tr>
<td><code>index-state</code></td>
<td></td>
<td><code>index-state</code> attribute of <a href="#callcabalprojecttonix"><code>callCabalProjectToNix</code></a> return value</td>
</tr>
<tr>
<td><code>shellFor</code></td>
<td>Function</td>
<td><a href="#shellfor"><code>shellFor</code></a></td>
</tr>
<tr>
<td><code>ghcWithHoogle</code></td>
<td>Function</td>
<td><a href="#ghcwithhoogle"><code>ghcWithHoogle</code></a></td>
</tr>
<tr>
<td><code>ghcWithPackages</code></td>
<td>Function</td>
<td><a href="#ghcwithpackages"><code>ghcWithPackages</code></a></td>
</tr>
<tr>
<td><code>projectCross</code></td>
<td>Attrset</td>
<td>Like <code>pkgs.pkgsCross.&lt;system&gt;</code> from nixpkgs <code>p.projectCross.&lt;system&gt;</code> returns the project results for cross compilation (where system is a member of nixpkgs lib.systems.examples).  So <code>p.projectCross.ghcjs.hsPkgs</code> is the same as <code>hsPkgs</code> but compiled with ghcjs</td>
</tr>
<tr>
<td><code>appendModule</code></td>
<td>Function</td>
<td>Re-eval the project with an extra module (or module list).</td>
</tr>
<tr>
<td><code>extend</code> and <code>appendOverlays</code></td>
<td>Function</td>
<td>Modify a project, or add attributes, through overlays: <code>p.extend(final: prev: { })</code>. The overlays are carried-over <code>projectCross</code> and <code>appendModule</code> invocations.</td>
</tr>
</tbody>
</table>
<h2 id="project-cabalproject-and-stackproject">project, cabalProject and stackProject<a class="headerlink" href="#project-cabalproject-and-stackproject" title="Permanent link">&para;</a></h2>
<p>These versions of the function are the same as project', cabalProject'
and stackProject', but <code>hsPkgs</code> attributes are also included in the
return value directly.  That way a package can be referenced as
<code>(project {...}).foo</code> instead of <code>(project' {...}).hsPkgs.foo</code>.</p>
<h2 id="mkstackpkgset">mkStackPkgSet<a class="headerlink" href="#mkstackpkgset" title="Permanent link">&para;</a></h2>
<p>Creates a <a href="#package-set">package set</a> based on the <code>pkgs.nix</code> output
of <code>stack-to-nix</code>.</p>
<pre><code class="language-nix">mkStackPkgSet =
    { stack-pkgs, pkg-def-extras ? [], modules ? []}: ...
</code></pre>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>stack-pkgs</code></td>
<td></td>
<td><code>import ./pkgs.nix</code> — The imported file generated by <code>stack‑to‑nix</code>.</td>
</tr>
<tr>
<td><code>pkg‑def‑extras</code></td>
<td>List of <a href="#extras">Extras</a></td>
<td>For overriding the package set.</td>
</tr>
<tr>
<td><code>modules</code></td>
<td>List of <a href="#modules">Modules</a></td>
<td>For overriding the package set.</td>
</tr>
</tbody>
</table>
<p><strong>Return value</strong>: a <a href="#package-set"><code>pkgSet</code></a></p>
<h2 id="mkcabalprojectpkgset">mkCabalProjectPkgSet<a class="headerlink" href="#mkcabalprojectpkgset" title="Permanent link">&para;</a></h2>
<p>Creates a <a href="#package-set">package set</a> based on the <code>pkgs.nix</code> output
of <code>plan-to-nix</code>.</p>
<pre><code class="language-nix">mkCabalProjectPkgSet =
    { plan-pkgs, pkg-def-extras ? [], modules ? []}: ...
</code></pre>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>plan-pkgs</code></td>
<td></td>
<td><code>import ./pkgs.nix</code> — The imported file generated by <code>plan‑to‑nix</code>.</td>
</tr>
<tr>
<td><code>pkg‑def‑extras</code></td>
<td>List of <a href="#extras">Extras</a></td>
<td>For overriding the package set.</td>
</tr>
<tr>
<td><code>modules</code></td>
<td>List of <a href="#modules">Modules</a></td>
<td>For overriding the package set.</td>
</tr>
</tbody>
</table>
<p><strong>Return value</strong>: a <a href="#package-set"><code>pkgSet</code></a></p>
<h2 id="mkpkgset">mkPkgSet<a class="headerlink" href="#mkpkgset" title="Permanent link">&para;</a></h2>
<p>This is the base function used by both <code>mkStackPkgSet</code> and
<code>mkCabalProjectPkgSet</code>.</p>
<p><strong>Return value</strong>: a <a href="#package-set"><code>pkgSet</code></a></p>
<h2 id="snapshots">snapshots<a class="headerlink" href="#snapshots" title="Permanent link">&para;</a></h2>
<p>This is an attrset of <code>hsPkgs</code> packages from Stackage.</p>
<h2 id="haskellpackages">haskellPackages<a class="headerlink" href="#haskellpackages" title="Permanent link">&para;</a></h2>
<p>A <code>hsPkgs</code> package set, which is one of the recent LTS Haskell
releases from <a href="#snapshots"><code>snapshots</code></a>.</p>
<p>The chosen LTS is updated occasionally in <a href="https://github.com/input-output-hk/haskell.nix">Haskell.nix</a>, though a
manual process.</p>
<h2 id="nix-tools">nix-tools<a class="headerlink" href="#nix-tools" title="Permanent link">&para;</a></h2>
<p>A derivation containing the <code>nix-tools</code> <a href="commands.html">command-line tools</a>.</p>
<h2 id="callstacktonix">callStackToNix<a class="headerlink" href="#callstacktonix" title="Permanent link">&para;</a></h2>
<p>Runs <code>stack-to-nix</code> and produces the output needed for
<code>importAndFilterProject</code>.</p>
<p><strong>Example</strong>:</p>
<pre><code class="language-nix">  pkgSet = mkStackPkgSet {
    stack-pkgs = (importAndFilterProject (callStackToNix {
      src = ./.;
    })).pkgs;
    pkg-def-extras = [];
    modules = [];
  };
</code></pre>
<h2 id="callcabalprojecttonix">callCabalProjectToNix<a class="headerlink" href="#callcabalprojecttonix" title="Permanent link">&para;</a></h2>
<p>Runs <code>cabal new-configure</code> and <code>plan-to-nix</code> and produces the output
needed for <code>importAndFilterProject</code>.</p>
<p><strong>Example</strong>:</p>
<pre><code class="language-nix">  pkgSet = mkCabalProjectPkgSet {
    plan-pkgs = (importAndFilterProject (callCabalProjectToNix {
      index-state = &quot;2019-04-30T00:00:00Z&quot;;
      src = ./.;
    })).pkgs;
</code></pre>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>name</code></td>
<td>String</td>
<td>Optional name for better error messages.</td>
</tr>
<tr>
<td><code>src</code></td>
<td>Path</td>
<td>Location of the cabal project files.</td>
</tr>
<tr>
<td><code>compiler-nix-name</code></td>
<td>String</td>
<td>The name of the ghc compiler to use eg. "ghc884"</td>
</tr>
<tr>
<td><code>index-state</code></td>
<td>Timestamp</td>
<td>Optional hackage index-state, eg. "2019-10-10T00:00:00Z".</td>
</tr>
<tr>
<td><code>index-sha256</code></td>
<td>Sha256</td>
<td>Optional hash of the truncated hackage index-state.</td>
</tr>
<tr>
<td><code>plan-sha256</code></td>
<td>Sha256</td>
<td>Optional hash of the plan-to-nix output (makes the plan-to-nix step a fixed output derivation).</td>
</tr>
<tr>
<td><code>cabalProject</code></td>
<td>String</td>
<td>Optional cabal project file contents (defaults to readFile "${src}/cabal.project").</td>
</tr>
<tr>
<td><code>cabalProjectLocal</code></td>
<td>String</td>
<td>Optional cabal project file contents (defaults to readFile "${src}/cabal.project.local").</td>
</tr>
<tr>
<td><code>cabalProjectFreeze</code></td>
<td>String</td>
<td>Optional cabal project file contents (defaults to readFile "${src}/cabal.project.freeze").</td>
</tr>
<tr>
<td><code>ghc</code></td>
<td></td>
<td>Deprecated. Use <code>compiler-nix-name</code> instead. Optional ghc to use</td>
</tr>
<tr>
<td><code>nix-tools</code></td>
<td></td>
<td>Optional nix-tools to use</td>
</tr>
<tr>
<td><code>hpack</code></td>
<td></td>
<td>Optional hpack to use</td>
</tr>
<tr>
<td><code>cabal-install</code></td>
<td></td>
<td>Optional cabal-install to use</td>
</tr>
<tr>
<td><code>configureArgs</code></td>
<td>String</td>
<td>Optional extra arguments to pass to <code>cabal new-configure</code> (--enable-tests is included by default, include <code>--disable-tests</code> to override that).</td>
</tr>
</tbody>
</table>
<h2 id="importandfilterproject">importAndFilterProject<a class="headerlink" href="#importandfilterproject" title="Permanent link">&para;</a></h2>
<p>Imports from a derivation created by <code>callStackToNix</code>
or <code>callCabalProjectToNix</code>.</p>
<p>The result is an attrset with the following values:</p>
<table>
<thead>
<tr>
<th>Attribute</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>pkgs</code></td>
<td>attrset</td>
<td>that can be passed to <code>mkStackPkgSet</code> (as <code>stack-pkgs</code>) or <code>mkCabalProjectPkgSet</code> (as <code>plan-pkgs</code>).</td>
</tr>
<tr>
<td><code>nix</code></td>
<td></td>
<td>this can be built and cached so that the amount built in the evaluation phase is not too great (helps to avoid timeouts on Hydra).</td>
</tr>
</tbody>
</table>
<h2 id="hackage">hackage<a class="headerlink" href="#hackage" title="Permanent link">&para;</a></h2>
<h2 id="stackage">stackage<a class="headerlink" href="#stackage" title="Permanent link">&para;</a></h2>
<h2 id="fetchexternal">fetchExternal<a class="headerlink" href="#fetchexternal" title="Permanent link">&para;</a></h2>
<h2 id="cleansourcehaskell">cleanSourceHaskell<a class="headerlink" href="#cleansourcehaskell" title="Permanent link">&para;</a></h2>
<pre><code>cleanSourceHaskell = { src, name ? null }: ...
</code></pre>
<p>Filters a source tree removing common filenames that are not Haskell
build sources.</p>
<p>This can avoid unecessary rebuilds when these files change.</p>
<p>It's recommended to provide <code>name</code> so that the source derivation
remains constant regardless of how it was fetched.</p>
<p>Example:</p>
<pre><code>src = pkgs.haskell-nix.cleanSourceHaskell {
  src = ./.;
  name = &quot;myproject-src&quot;;
};
</code></pre>
<h2 id="haskellsourcefilter">haskellSourceFilter<a class="headerlink" href="#haskellsourcefilter" title="Permanent link">&para;</a></h2>
<pre><code>haskellSourceFilter = name: type: ...
</code></pre>
<p>This is a source filter function which cleans common build products
and files not needed to do a Haskell build from a source directory.</p>
<p>It should be used with <code>pkgs.lib.cleanSourceWith</code>. Alternatively,
use the convenience function <a href="#cleansourcehaskell"><code>cleanSourceHaskell</code></a>.</p>
<h2 id="haskelllib">haskellLib<a class="headerlink" href="#haskelllib" title="Permanent link">&para;</a></h2>
<p>Assorted functions for operating on <a href="https://github.com/input-output-hk/haskell.nix">Haskell.nix</a> data. This is
distinct from <code>pkgs.haskell.lib</code> in the current Nixpkgs Haskell
Infrastructure.</p>
<h3 id="collectcomponents-collectcomponents">collectComponents, collectComponents'<a class="headerlink" href="#collectcomponents-collectcomponents" title="Permanent link">&para;</a></h3>
<p>Extracts a selection of components from a Haskell <a href="#package-set">package set</a>.</p>
<p>This can be used to filter out all test suites or benchmarks of
your project, so that they can be built in Hydra (see check if you
want to run the tests as well as build them).</p>
<p><code>collectComponents'</code> is an alias of <code>collectComponents</code> without
predicate for filtering.</p>
<pre><code>collectComponents =
    group: packageSel: haskellPackages: ...
collectComponents' = group: collectComponents (_: true)
</code></pre>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>group</code></td>
<td>String</td>
<td>A <a href="#subComponentTypes">sub-component type</a>.</td>
</tr>
<tr>
<td><code>packageSel</code></td>
<td>A function <code>Package -&gt; Bool</code></td>
<td>A predicate to filter packages with.</td>
</tr>
<tr>
<td><code>haskellPackages</code></td>
<td><a href="#package-set">Package set</a></td>
<td>All packages in the build.</td>
</tr>
</tbody>
</table>
<p><strong>Return value</strong>: a recursive attrset mapping package names → component names → components.</p>
<p><strong>Example</strong>:</p>
<pre><code class="language-nix">tests = collectComponents &quot;tests&quot; (package: package.identifier.name == &quot;mypackage&quot;) hsPkgs;
</code></pre>
<p>Will result in moving derivations from <code>hsPkgs.mypackage.components.tests.unit-tests</code>
to <code>tests.mypackage.unit-tests</code>.</p>
<h3 id="collectchecks-collectchecks">collectChecks, collectChecks'<a class="headerlink" href="#collectchecks-collectchecks" title="Permanent link">&para;</a></h3>
<p>These are just like <code>collectComponents</code> and <code>collectComponents'</code>, except that they collect
the <code>checks</code> attributes of packages (which aren't components, and so can't be collected
by the other functions.</p>
<h4 id="check">check<a class="headerlink" href="#check" title="Permanent link">&para;</a></h4>
<p>This function turns a derivation that builds a test into one to run it.</p>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>drv</code></td>
<td>Derivation</td>
<td>One of <code>$pkg.components.tests.$test</code>.</td>
</tr>
</tbody>
</table>
<p>For convenience <code>$pkg.components.tests</code> are mapped with this function
to <code>$pkg.checks</code>.</p>
<p>This function is intended for use with <code>tests</code> but it should also work
for <code>exes</code> and <code>benchmarks</code> if you just want to run them to make sure
they execute.</p>
<h4 id="subcomponenttypes">subComponentTypes<a class="headerlink" href="#subcomponenttypes" title="Permanent link">&para;</a></h4>
<p>Sub-component types identify <a href="#component">components</a> and are one of:</p>
<ul>
<li><code>sublibs</code></li>
<li><code>foreignlibs</code></li>
<li><code>exes</code></li>
<li><code>tests</code></li>
<li><code>benchmarks</code></li>
</ul>
<h1 id="project-functions">Project functions<a class="headerlink" href="#project-functions" title="Permanent link">&para;</a></h1>
<p>These functions are included in the <code>project</code> return values.
In the past they also existed within <code>project.hsPkgs</code>,
but have now been removed from there.</p>
<h2 id="shellfor">shellFor<a class="headerlink" href="#shellfor" title="Permanent link">&para;</a></h2>
<p>Create a <code>nix-shell</code> <a href="../tutorials/development.html">development
environment</a> for developing one or more
packages with <code>ghci</code> or <code>cabal v2-build</code> (but not Stack).</p>
<pre><code>shellFor =
    { packages, withHoogle ? true, exactDeps ? false, ...}: ...
</code></pre>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>packages</code></td>
<td>Function</td>
<td>Package selection function. It takes a list of <a href="#haskell-package">Haskell packages</a> and returns a subset of these packages.</td>
</tr>
<tr>
<td><code>components</code></td>
<td>Function</td>
<td>Similar to <code>packages</code>, by default all the components of the selected packages are selected.</td>
</tr>
<tr>
<td><code>additional</code></td>
<td>Function</td>
<td>Similar to <code>packages</code>, but the selected packages are built and included in <code>ghc-pkg list</code> (not just their dependencies).</td>
</tr>
<tr>
<td><code>withHoogle</code></td>
<td>Boolean</td>
<td>Whether to build a Hoogle documentation index and provide the <code>hoogle</code> command.</td>
</tr>
<tr>
<td><code>exactDeps</code></td>
<td>Boolean</td>
<td>Prevents the Cabal solver from choosing any package dependency other than what are in the package set.</td>
</tr>
<tr>
<td><code>tools</code></td>
<td>Function</td>
<td>AttrSet of tools to make available e.g. <code>{ cabal = "3.2.0.0"; }</code> or <code>{ cabal = { version = "3.2.0.0"; }; }</code>. If an AttrSet is provided for a tool, the additional arguments will be passed to the function creating the derivation for that tool. So you can provide an <code>index-state</code> or a <code>materialized</code> argument like that <code>{ cabal = { version = "3.2.0.0"; index-state = "2020-10-30T00:00:00Z"; materialized = ./cabal.materialized; }; }</code> for example. You can specify and materialize the version of hoogle used to construct the hoogle index by including something like <code>{ hoogle = { version = "5.0.17.15"; index-state = "2020-05-31T00:00:00Z"; materialized = ./hoogle.materialized; }</code>. Uses a default version of hoogle if omitted.</td>
</tr>
<tr>
<td><code>inputsFrom</code></td>
<td>List</td>
<td>List of other shells to include in this one.  The <code>buildInputs</code> and <code>nativeBuildInputs</code> of each will be included using <a href="https://nixos.org/manual/nixpkgs/stable/#sec-pkgs-mkShell">mkShell</a>.</td>
</tr>
<tr>
<td><code>crossPlatforms</code></td>
<td>Function</td>
<td>Platform selection function for cross compilation targets to support eg. <code>ps: with ps; [ghcjs mingwW64]</code> (see nixpkgs lib.systems.examples for list of platform names).</td>
</tr>
<tr>
<td><code>{ ... }</code></td>
<td>Attrset</td>
<td>All the other arguments are passed to <a href="https://nixos.org/nixpkgs/manual/#sec-using-stdenv"><code>mkDerivation</code></a>.</td>
</tr>
</tbody>
</table>
<p><strong>Return value</strong>: a derivation</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p><code>exactDeps = true</code> will set the <code>CABAL_CONFIG</code> environment variable
to disable remote package servers. This is a
<a href="../dev/removing-with-package-wrapper.html">known limitation</a>
which we would like to solve. Use <code>exactDeps = false</code> if this is a
problem.</p>
</div>
<h2 id="ghcwithpackages">ghcWithPackages<a class="headerlink" href="#ghcwithpackages" title="Permanent link">&para;</a></h2>
<p>Creates a <code>nix-shell</code> <a href="../tutorials/development.html">development
environment</a> including the given
packages selected from this package set.</p>
<p><strong>Parameter</strong>: a package selection function.</p>
<p><strong>Return value</strong>: a derivation</p>
<p><strong>Example</strong>:</p>
<pre><code>haskell.haskellPackages.ghcWithPackages (ps: with ps; [ lens conduit ])
</code></pre>
<h2 id="ghcwithhoogle">ghcWithHoogle<a class="headerlink" href="#ghcwithhoogle" title="Permanent link">&para;</a></h2>
<p>The same as <code>ghcWithPackages</code>, except, a <code>hoogle</code> command with a
Hoogle documentation index of the packages will be included in the
shell.</p>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="modules.html" class="btn btn-neutral float-right" title="Module options">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href="commands.html" class="btn btn-neutral" title="Command-line tools"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
        <span>
          <a href="https://github.com/input-output-hk/haskell.nix/" class="fa fa-github" style="color: #fcfcfc"> GitHub</a>
        </span>
    
    
      <span><a href="commands.html" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="modules.html" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script>var base_url = '..';</script>
    <script src="../js/theme_extra.js" defer></script>
    <script src="../js/theme.js" defer></script>
      <script src="../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
